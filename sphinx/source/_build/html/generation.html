

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>botorch.generation &mdash; BoTorch  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css?v=ca3e82f4" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="botorch.posteriors" href="posteriors.html" />
    <link rel="prev" title="botorch.models" href="models.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BoTorch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">botorch.models</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">botorch.generation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.generation.gen">Candidate Generation Utilities for Acquisition Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.gen.gen_candidates_scipy"><code class="docutils literal notranslate"><span class="pre">gen_candidates_scipy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.gen.gen_candidates_torch"><code class="docutils literal notranslate"><span class="pre">gen_candidates_torch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.gen.get_best_candidates"><code class="docutils literal notranslate"><span class="pre">get_best_candidates()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.generation.sampling">Sampling Strategies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.sampling.SamplingStrategy"><code class="docutils literal notranslate"><span class="pre">SamplingStrategy</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.generation.sampling.SamplingStrategy.forward"><code class="docutils literal notranslate"><span class="pre">SamplingStrategy.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.sampling.MaxPosteriorSampling"><code class="docutils literal notranslate"><span class="pre">MaxPosteriorSampling</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.generation.sampling.MaxPosteriorSampling.forward"><code class="docutils literal notranslate"><span class="pre">MaxPosteriorSampling.forward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.generation.sampling.MaxPosteriorSampling.maximize_samples"><code class="docutils literal notranslate"><span class="pre">MaxPosteriorSampling.maximize_samples()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.sampling.BoltzmannSampling"><code class="docutils literal notranslate"><span class="pre">BoltzmannSampling</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.generation.sampling.BoltzmannSampling.forward"><code class="docutils literal notranslate"><span class="pre">BoltzmannSampling.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.generation.sampling.ConstrainedMaxPosteriorSampling"><code class="docutils literal notranslate"><span class="pre">ConstrainedMaxPosteriorSampling</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.generation.sampling.ConstrainedMaxPosteriorSampling.forward"><code class="docutils literal notranslate"><span class="pre">ConstrainedMaxPosteriorSampling.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.generation.utils">Utilities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_utils.html">botorch.test_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">botorch.utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BoTorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">botorch.generation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/generation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-botorch.generation">
<span id="botorch-generation"></span><h1>botorch.generation<a class="headerlink" href="#module-botorch.generation" title="Link to this heading"></a></h1>
<section id="module-botorch.generation.gen">
<span id="candidate-generation-utilities-for-acquisition-functions"></span><h2>Candidate Generation Utilities for Acquisition Functions<a class="headerlink" href="#module-botorch.generation.gen" title="Link to this heading"></a></h2>
<p>Candidate generation utilities.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.generation.gen.gen_candidates_scipy">
<span class="sig-prename descclassname"><span class="pre">botorch.generation.gen.</span></span><span class="sig-name descname"><span class="pre">gen_candidates_scipy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_conditions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acquisition_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonlinear_inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout_sec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/gen.html#gen_candidates_scipy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.gen.gen_candidates_scipy" title="Link to this definition"></a></dt>
<dd><p>Generate a set of candidates using <cite>scipy.optimize.minimize</cite>.</p>
<p>Optimizes an acquisition function starting from a set of initial candidates
using <cite>scipy.optimize.minimize</cite> via a numpy converter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_conditions</strong> (<em>Tensor</em>) – Starting points for optimization, with shape
(b) x q x d.</p></li>
<li><p><strong>acquisition_function</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction"><em>AcquisitionFunction</em></a>) – Acquisition function to be used.</p></li>
<li><p><strong>lower_bounds</strong> (<em>float</em><em> | </em><em>Tensor</em><em> | </em><em>None</em>) – Minimum values for each column of initial_conditions.</p></li>
<li><p><strong>upper_bounds</strong> (<em>float</em><em> | </em><em>Tensor</em><em> | </em><em>None</em>) – Maximum values for each column of initial_conditions.</p></li>
<li><p><strong>constraints</strong> (<em>equality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>constraints</strong> – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
<li><p><strong>nonlinear_inequality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Callable</em><em>, </em><em>bool</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of tuples representing the nonlinear
inequality constraints. The first element in the tuple is a callable
representing a constraint of the form <cite>callable(x) &gt;= 0</cite>. In case of an
intra-point constraint, <cite>callable()`takes in an one-dimensional tensor of
shape `d</cite> and returns a scalar. In case of an inter-point constraint,
<cite>callable()</cite> takes a two dimensional tensor of shape <cite>q x d</cite> and again
returns a scalar. The second element is a boolean, indicating if it is an
intra-point or inter-point constraint (<cite>True</cite> for intra-point. <cite>False</cite> for
inter-point). For more information on intra-point vs inter-point
constraints, see the docstring of the <cite>inequality_constraints</cite> argument to
<cite>optimize_acqf()</cite>. The constraints will later be passed to the scipy
solver.</p></li>
<li><p><strong>options</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>] </em><em>| </em><em>None</em>) – Options used to control the optimization including “method”
and “maxiter”. Select method for <cite>scipy.minimize</cite> using the
“method” key. By default uses L-BFGS-B for box-constrained problems
and SLSQP if inequality or equality constraints are present. If
<cite>with_grad=False</cite>, then we use a two-point finite difference estimate
of the gradient.</p></li>
<li><p><strong>fixed_features</strong> (<em>dict</em><em>[</em><em>int</em><em>, </em><em>float</em><em> | </em><em>None</em><em>] </em><em>| </em><em>None</em>) – This is a dictionary of feature indices to values, where
all generated candidates will have features fixed to these values.
If the dictionary value is None, then that feature will just be
fixed to the clamped value and not optimized. Assumes values to be
compatible with lower_bounds and upper_bounds!</p></li>
<li><p><strong>timeout_sec</strong> (<em>float</em><em> | </em><em>None</em>) – Timeout (in seconds) for <cite>scipy.optimize.minimize</cite> routine -
if provided, optimization will stop after this many seconds and return
the best solution found so far.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>)</p></li>
<li><p><strong>equality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>The set of generated candidates.</p></li>
<li><p>The acquisition value for each t-batch.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qEI</span> <span class="o">=</span> <span class="n">qExpectedImprovement</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">best_f</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xinit</span> <span class="o">=</span> <span class="n">gen_batch_initial_conditions</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">qEI</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_restarts</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">raw_samples</span><span class="o">=</span><span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_candidates</span><span class="p">,</span> <span class="n">batch_acq_values</span> <span class="o">=</span> <span class="n">gen_candidates_scipy</span><span class="p">(</span>
<span class="go">        initial_conditions=Xinit,</span>
<span class="go">        acquisition_function=qEI,</span>
<span class="go">        lower_bounds=bounds[0],</span>
<span class="go">        upper_bounds=bounds[1],</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.generation.gen.gen_candidates_torch">
<span class="sig-prename descclassname"><span class="pre">botorch.generation.gen.</span></span><span class="sig-name descname"><span class="pre">gen_candidates_torch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_conditions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acquisition_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer=&lt;class</span> <span class="pre">'torch.optim.adam.Adam'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_features=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout_sec=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/gen.html#gen_candidates_torch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.gen.gen_candidates_torch" title="Link to this definition"></a></dt>
<dd><p>Generate a set of candidates using a <cite>torch.optim</cite> optimizer.</p>
<p>Optimizes an acquisition function starting from a set of initial candidates
using an optimizer from <cite>torch.optim</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_conditions</strong> (<em>Tensor</em>) – Starting points for optimization.</p></li>
<li><p><strong>acquisition_function</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction"><em>AcquisitionFunction</em></a>) – Acquisition function to be used.</p></li>
<li><p><strong>lower_bounds</strong> (<em>float</em><em> | </em><em>Tensor</em><em> | </em><em>None</em>) – Minimum values for each column of initial_conditions.</p></li>
<li><p><strong>upper_bounds</strong> (<em>float</em><em> | </em><em>Tensor</em><em> | </em><em>None</em>) – Maximum values for each column of initial_conditions.</p></li>
<li><p><strong>optimizer</strong> (<em>Optimizer</em>) – The pytorch optimizer to use to perform
candidate search.</p></li>
<li><p><strong>options</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><em>float</em><em> | </em><em>str</em><em>] </em><em>| </em><em>None</em>) – Options used to control the optimization. Includes
maxiter: Maximum number of iterations</p></li>
<li><p><strong>callback</strong> (<em>Callable</em><em>[</em><em>[</em><em>int</em><em>, </em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em><em>, </em><em>NoReturn</em><em>] </em><em>| </em><em>None</em>) – A callback function accepting the current iteration, loss,
and gradients as arguments. This function is executed after computing
the loss and gradients, but before calling the optimizer.</p></li>
<li><p><strong>fixed_features</strong> (<em>dict</em><em>[</em><em>int</em><em>, </em><em>float</em><em> | </em><em>None</em><em>] </em><em>| </em><em>None</em>) – This is a dictionary of feature indices to values, where
all generated candidates will have features fixed to these values.
If the dictionary value is None, then that feature will just be
fixed to the clamped value and not optimized. Assumes values to be
compatible with lower_bounds and upper_bounds!</p></li>
<li><p><strong>timeout_sec</strong> (<em>float</em><em> | </em><em>None</em>) – Timeout (in seconds) for optimization. If provided,
<cite>gen_candidates_torch</cite> will stop after this many seconds and return
the best solution found so far.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>The set of generated candidates.</p></li>
<li><p>The acquisition value for each t-batch.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qEI</span> <span class="o">=</span> <span class="n">qExpectedImprovement</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">best_f</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xinit</span> <span class="o">=</span> <span class="n">gen_batch_initial_conditions</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">qEI</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_restarts</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">raw_samples</span><span class="o">=</span><span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_candidates</span><span class="p">,</span> <span class="n">batch_acq_values</span> <span class="o">=</span> <span class="n">gen_candidates_torch</span><span class="p">(</span>
<span class="go">        initial_conditions=Xinit,</span>
<span class="go">        acquisition_function=qEI,</span>
<span class="go">        lower_bounds=bounds[0],</span>
<span class="go">        upper_bounds=bounds[1],</span>
<span class="go">    )</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.generation.gen.get_best_candidates">
<span class="sig-prename descclassname"><span class="pre">botorch.generation.gen.</span></span><span class="sig-name descname"><span class="pre">get_best_candidates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_candidates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_values</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/gen.html#get_best_candidates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.gen.get_best_candidates" title="Link to this definition"></a></dt>
<dd><p>Extract best (q-batch) candidate from batch of candidates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_candidates</strong> (<em>Tensor</em>) – A <cite>b x q x d</cite> tensor of <cite>b</cite> q-batch candidates, or a
<cite>b x d</cite> tensor of <cite>b</cite> single-point candidates.</p></li>
<li><p><strong>batch_values</strong> (<em>Tensor</em>) – A tensor with <cite>b</cite> elements containing the value of the
respective candidate (higher is better).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of size <cite>q x d</cite> (if q-batch mode) or <cite>d</cite> from batch_candidates
with the highest associated value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qEI</span> <span class="o">=</span> <span class="n">qExpectedImprovement</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">best_f</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xinit</span> <span class="o">=</span> <span class="n">gen_batch_initial_conditions</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">qEI</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_restarts</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">raw_samples</span><span class="o">=</span><span class="mi">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_candidates</span><span class="p">,</span> <span class="n">batch_acq_values</span> <span class="o">=</span> <span class="n">gen_candidates_scipy</span><span class="p">(</span>
<span class="go">        initial_conditions=Xinit,</span>
<span class="go">        acquisition_function=qEI,</span>
<span class="go">        lower_bounds=bounds[0],</span>
<span class="go">        upper_bounds=bounds[1],</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">best_candidates</span> <span class="o">=</span> <span class="n">get_best_candidates</span><span class="p">(</span><span class="n">batch_candidates</span><span class="p">,</span> <span class="n">batch_acq_values</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-botorch.generation.sampling">
<span id="sampling-strategies"></span><h2>Sampling Strategies<a class="headerlink" href="#module-botorch.generation.sampling" title="Link to this heading"></a></h2>
<p>Sampling-based generation strategies.</p>
<p>A SamplingStrategy returns samples from the input points (i.e. Tensors in feature
space), rather than the value for a set of tensors, as acquisition functions do.
The q-batch dimension has similar semantics as for acquisition functions in that the
points across the q-batch are considered jointly for sampling (where as for
q-acquisition functions we evaluate the joint value of the q-batch).</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.generation.sampling.SamplingStrategy">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.generation.sampling.</span></span><span class="sig-name descname"><span class="pre">SamplingStrategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#SamplingStrategy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.SamplingStrategy" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for sampling-based generation strategies.</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p>
<dl class="field-list simple">
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.generation.sampling.SamplingStrategy.forward">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#SamplingStrategy.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.SamplingStrategy.forward" title="Link to this definition"></a></dt>
<dd><p>Sample according to the SamplingStrategy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape x N x d</cite>-dim Tensor from which to sample (in the <cite>N</cite>
dimension).</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x num_samples x d</cite>-dim Tensor of samples from <cite>X</cite>, where
<cite>X[…, i, :]</cite> is the <cite>i</cite>-th sample.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.generation.sampling.MaxPosteriorSampling">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.generation.sampling.</span></span><span class="sig-name descname"><span class="pre">MaxPosteriorSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posterior_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#MaxPosteriorSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.MaxPosteriorSampling" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.generation.sampling.SamplingStrategy" title="botorch.generation.sampling.SamplingStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingStrategy</span></code></a></p>
<p>Sample from a set of points according to their max posterior value.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MPS</span> <span class="o">=</span> <span class="n">MaxPosteriorSampling</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>  <span class="c1"># model w/ feature dim d=3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampled_X</span> <span class="o">=</span> <span class="n">MPS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Constructor for the SamplingStrategy base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – A fitted model.</p></li>
<li><p><strong>objective</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.objective.MCAcquisitionObjective" title="botorch.acquisition.objective.MCAcquisitionObjective"><em>MCAcquisitionObjective</em></a><em> | </em><em>None</em>) – The MCAcquisitionObjective under which the samples are
evaluated. Defaults to <cite>IdentityMCObjective()</cite>.</p></li>
<li><p><strong>posterior_transform</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.objective.PosteriorTransform" title="botorch.acquisition.objective.PosteriorTransform"><em>PosteriorTransform</em></a><em> | </em><em>None</em>) – An optional PosteriorTransform.</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, sample with replacement.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.generation.sampling.MaxPosteriorSampling.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#MaxPosteriorSampling.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.MaxPosteriorSampling.forward" title="Link to this definition"></a></dt>
<dd><p>Sample from the model posterior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape x N x d</cite>-dim Tensor from which to sample (in the <cite>N</cite>
dimension) according to the maximum posterior value under the objective.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw.</p></li>
<li><p><strong>observation_noise</strong> (<em>bool</em>) – If True, sample with observation noise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x num_samples x d</cite>-dim Tensor of samples from <cite>X</cite>, where
<cite>X[…, i, :]</cite> is the <cite>i</cite>-th sample.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.generation.sampling.MaxPosteriorSampling.maximize_samples">
<span class="sig-name descname"><span class="pre">maximize_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#MaxPosteriorSampling.maximize_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.MaxPosteriorSampling.maximize_samples" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.generation.sampling.BoltzmannSampling">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.generation.sampling.</span></span><span class="sig-name descname"><span class="pre">BoltzmannSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">acq_func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#BoltzmannSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.BoltzmannSampling" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.generation.sampling.SamplingStrategy" title="botorch.generation.sampling.SamplingStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">SamplingStrategy</span></code></a></p>
<p>Sample from a set of points according to a tempered acquisition value.</p>
<p>Given an acquisition function <cite>acq_func</cite>, this sampling strategies draws
samples from a <cite>batch_shape x N x d</cite>-dim tensor <cite>X</cite> according to a multinomial
distribution over its indices given by</p>
<blockquote>
<div><p>weight(X[…, i, :]) ~ exp(eta * standardize(acq_func(X[…, i, :])))</p>
</div></blockquote>
<p>where <cite>standardize(Y)</cite> standardizes <cite>Y</cite> to zero mean and unit variance. As the
temperature parameter <cite>eta -&gt; 0</cite>, this approaches uniform sampling, while as
<cite>eta -&gt; infty</cite>, this approaches selecting the maximizer(s) of the acquisition
function <cite>acq_func</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">UCB</span> <span class="o">=</span> <span class="n">UpperConfidenceBound</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BMUCB</span> <span class="o">=</span> <span class="n">BoltzmannSampling</span><span class="p">(</span><span class="n">UCB</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampled_X</span> <span class="o">=</span> <span class="n">BMUCB</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Boltzmann Acquisition Value Sampling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>acq_func</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction"><em>AcquisitionFunction</em></a>) – The acquisition function; to be evaluated in batch at the
individual points of a q-batch (not jointly, as is the case for
acquisition functions). Can be analytic or Monte-Carlo.</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – The temperature parameter in the softmax.</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, sample with replacement.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.generation.sampling.BoltzmannSampling.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#BoltzmannSampling.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.BoltzmannSampling.forward" title="Link to this definition"></a></dt>
<dd><p>Sample from a tempered value of the acquisition function value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape x N x d</cite>-dim Tensor from which to sample (in the <cite>N</cite>
dimension) according to the maximum posterior value under the objective.
Note that if a batched model is used in the underlying acquisition
function, then its batch shape must be broadcastable to <cite>batch_shape</cite>.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x num_samples x d</cite>-dim Tensor of samples from <cite>X</cite>, where
<cite>X[…, i, :]</cite> is the <cite>i</cite>-th sample.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.generation.sampling.ConstrainedMaxPosteriorSampling">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.generation.sampling.</span></span><span class="sig-name descname"><span class="pre">ConstrainedMaxPosteriorSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posterior_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#ConstrainedMaxPosteriorSampling"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.ConstrainedMaxPosteriorSampling" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.generation.sampling.MaxPosteriorSampling" title="botorch.generation.sampling.MaxPosteriorSampling"><code class="xref py py-class docutils literal notranslate"><span class="pre">MaxPosteriorSampling</span></code></a></p>
<p>Constrained max posterior sampling.</p>
<p>Posterior sampling where we try to maximize an objective function while
simulatenously satisfying a set of constraints c1(x) &lt;= 0, c2(x) &lt;= 0,
…, cm(x) &lt;= 0 where c1, c2, …, cm are black-box constraint functions.
Each constraint function is modeled by a seperate GP model. We follow the
procedure as described in <a class="reference external" href="https://doi.org/10.48550/arxiv.2002.08526">https://doi.org/10.48550/arxiv.2002.08526</a>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">CMPS</span> <span class="o">=</span> <span class="n">ConstrainedMaxPosteriorSampling</span><span class="p">(</span>
<span class="go">        model,</span>
<span class="go">        constraint_model=ModelListGP(cmodel1, cmodel2),</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sampled_X</span> <span class="o">=</span> <span class="n">CMPS</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Constructor for the SamplingStrategy base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – A fitted model.</p></li>
<li><p><strong>objective</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.objective.MCAcquisitionObjective" title="botorch.acquisition.objective.MCAcquisitionObjective"><em>MCAcquisitionObjective</em></a><em> | </em><em>None</em>) – The MCAcquisitionObjective under which the samples are evaluated.
Defaults to <cite>IdentityMCObjective()</cite>.</p></li>
<li><p><strong>posterior_transform</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.objective.PosteriorTransform" title="botorch.acquisition.objective.PosteriorTransform"><em>PosteriorTransform</em></a><em> | </em><em>None</em>) – An optional PosteriorTransform for the objective
function (corresponding to <cite>model</cite>).</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, sample with replacement.</p></li>
<li><p><strong>constraint_model</strong> (<a class="reference internal" href="models.html#botorch.models.model_list_gp_regression.ModelListGP" title="botorch.models.model_list_gp_regression.ModelListGP"><em>ModelListGP</em></a><em> | </em><a class="reference internal" href="models.html#botorch.models.multitask.MultiTaskGP" title="botorch.models.multitask.MultiTaskGP"><em>MultiTaskGP</em></a>) – either a ModelListGP where each submodel is a GP model for
one constraint function, or a MultiTaskGP model where each task is one
constraint function. All constraints are of the form c(x) &lt;= 0. In the
case when the constraint model predicts that all candidates
violate constraints, we pick the candidates with minimum violation.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.generation.sampling.ConstrainedMaxPosteriorSampling.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/generation/sampling.html#ConstrainedMaxPosteriorSampling.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.generation.sampling.ConstrainedMaxPosteriorSampling.forward" title="Link to this definition"></a></dt>
<dd><p>Sample from the model posterior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape x N x d</cite>-dim Tensor from which to sample (in the <cite>N</cite>
dimension) according to the maximum posterior value under the objective.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw.</p></li>
<li><p><strong>observation_noise</strong> (<em>bool</em>) – If True, sample with observation noise.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>batch_shape x num_samples x d</cite>-dim Tensor of samples from <cite>X</cite>, where</dt><dd><p><cite>X[…, i, :]</cite> is the <cite>i</cite>-th sample.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.generation.utils">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-botorch.generation.utils" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="models.html" class="btn btn-neutral float-left" title="botorch.models" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="posteriors.html" class="btn btn-neutral float-right" title="botorch.posteriors" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>