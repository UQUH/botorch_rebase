

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>botorch.utils &mdash; BoTorch  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css?v=ca3e82f4" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="botorch.exceptions" href="exceptions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            BoTorch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="generation.html">botorch.generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_utils.html">botorch.test_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">botorch.utils</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.constraints">Constraints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.constraints.get_outcome_constraint_transforms"><code class="docutils literal notranslate"><span class="pre">get_outcome_constraint_transforms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.constraints.get_monotonicity_constraints"><code class="docutils literal notranslate"><span class="pre">get_monotonicity_constraints()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.constraints.NonTransformedInterval"><code class="docutils literal notranslate"><span class="pre">NonTransformedInterval</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.constraints.NonTransformedInterval.transform"><code class="docutils literal notranslate"><span class="pre">NonTransformedInterval.transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.constraints.NonTransformedInterval.inverse_transform"><code class="docutils literal notranslate"><span class="pre">NonTransformedInterval.inverse_transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.constraints.LogTransformedInterval"><code class="docutils literal notranslate"><span class="pre">LogTransformedInterval</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.constraints.LogTransformedInterval.transform"><code class="docutils literal notranslate"><span class="pre">LogTransformedInterval.transform()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.constraints.LogTransformedInterval.inverse_transform"><code class="docutils literal notranslate"><span class="pre">LogTransformedInterval.inverse_transform()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.containers">Containers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.containers.BotorchContainer"><code class="docutils literal notranslate"><span class="pre">BotorchContainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.BotorchContainer.event_shape"><code class="docutils literal notranslate"><span class="pre">BotorchContainer.event_shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.BotorchContainer.shape"><code class="docutils literal notranslate"><span class="pre">BotorchContainer.shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.BotorchContainer.device"><code class="docutils literal notranslate"><span class="pre">BotorchContainer.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.BotorchContainer.dtype"><code class="docutils literal notranslate"><span class="pre">BotorchContainer.dtype</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.containers.DenseContainer"><code class="docutils literal notranslate"><span class="pre">DenseContainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.DenseContainer.values"><code class="docutils literal notranslate"><span class="pre">DenseContainer.values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.DenseContainer.event_shape"><code class="docutils literal notranslate"><span class="pre">DenseContainer.event_shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.DenseContainer.shape"><code class="docutils literal notranslate"><span class="pre">DenseContainer.shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.DenseContainer.device"><code class="docutils literal notranslate"><span class="pre">DenseContainer.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.DenseContainer.dtype"><code class="docutils literal notranslate"><span class="pre">DenseContainer.dtype</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.DenseContainer.clone"><code class="docutils literal notranslate"><span class="pre">DenseContainer.clone()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.containers.SliceContainer"><code class="docutils literal notranslate"><span class="pre">SliceContainer</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.values"><code class="docutils literal notranslate"><span class="pre">SliceContainer.values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.indices"><code class="docutils literal notranslate"><span class="pre">SliceContainer.indices</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.event_shape"><code class="docutils literal notranslate"><span class="pre">SliceContainer.event_shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.shape"><code class="docutils literal notranslate"><span class="pre">SliceContainer.shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.device"><code class="docutils literal notranslate"><span class="pre">SliceContainer.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.dtype"><code class="docutils literal notranslate"><span class="pre">SliceContainer.dtype</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.containers.SliceContainer.clone"><code class="docutils literal notranslate"><span class="pre">SliceContainer.clone()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.context_managers">Context Managers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint"><code class="docutils literal notranslate"><span class="pre">TensorCheckpoint</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint.values"><code class="docutils literal notranslate"><span class="pre">TensorCheckpoint.values</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint.device"><code class="docutils literal notranslate"><span class="pre">TensorCheckpoint.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint.dtype"><code class="docutils literal notranslate"><span class="pre">TensorCheckpoint.dtype</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.context_managers.delattr_ctx"><code class="docutils literal notranslate"><span class="pre">delattr_ctx()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.context_managers.parameter_rollback_ctx"><code class="docutils literal notranslate"><span class="pre">parameter_rollback_ctx()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.context_managers.module_rollback_ctx"><code class="docutils literal notranslate"><span class="pre">module_rollback_ctx()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.context_managers.zero_grad_ctx"><code class="docutils literal notranslate"><span class="pre">zero_grad_ctx()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.datasets">Datasets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset"><code class="docutils literal notranslate"><span class="pre">SupervisedDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset.X"><code class="docutils literal notranslate"><span class="pre">SupervisedDataset.X</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset.Y"><code class="docutils literal notranslate"><span class="pre">SupervisedDataset.Y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset.Yvar"><code class="docutils literal notranslate"><span class="pre">SupervisedDataset.Yvar</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset.clone"><code class="docutils literal notranslate"><span class="pre">SupervisedDataset.clone()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.datasets.RankingDataset"><code class="docutils literal notranslate"><span class="pre">RankingDataset</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset.from_joint_dataset"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset.from_joint_dataset()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset.X"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset.X</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset.Y"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset.Y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset.Yvar"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset.Yvar</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset.get_dataset_without_task_feature"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset.get_dataset_without_task_feature()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset.clone"><code class="docutils literal notranslate"><span class="pre">MultiTaskDataset.clone()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.datasets.ContextualDataset"><code class="docutils literal notranslate"><span class="pre">ContextualDataset</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.ContextualDataset.X"><code class="docutils literal notranslate"><span class="pre">ContextualDataset.X</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.ContextualDataset.Y"><code class="docutils literal notranslate"><span class="pre">ContextualDataset.Y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.ContextualDataset.Yvar"><code class="docutils literal notranslate"><span class="pre">ContextualDataset.Yvar</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.datasets.ContextualDataset.clone"><code class="docutils literal notranslate"><span class="pre">ContextualDataset.clone()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.dispatcher">Dispatcher</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.dispatcher.type_bypassing_encoder"><code class="docutils literal notranslate"><span class="pre">type_bypassing_encoder()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher"><code class="docutils literal notranslate"><span class="pre">Dispatcher</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.dispatch"><code class="docutils literal notranslate"><span class="pre">Dispatcher.dispatch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.encode_args"><code class="docutils literal notranslate"><span class="pre">Dispatcher.encode_args()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.help"><code class="docutils literal notranslate"><span class="pre">Dispatcher.help()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.source"><code class="docutils literal notranslate"><span class="pre">Dispatcher.source()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.encoder"><code class="docutils literal notranslate"><span class="pre">Dispatcher.encoder</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.name"><code class="docutils literal notranslate"><span class="pre">Dispatcher.name</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.funcs"><code class="docutils literal notranslate"><span class="pre">Dispatcher.funcs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.dispatcher.Dispatcher.doc"><code class="docutils literal notranslate"><span class="pre">Dispatcher.doc</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.low_rank">Low-Rank Cholesky Update Utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.low_rank.extract_batch_covar"><code class="docutils literal notranslate"><span class="pre">extract_batch_covar()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.low_rank.sample_cached_cholesky"><code class="docutils literal notranslate"><span class="pre">sample_cached_cholesky()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multitask">Multi-Task Distribution Utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multitask.separate_mtmvn"><code class="docutils literal notranslate"><span class="pre">separate_mtmvn()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.objective">Objective</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.objective.get_objective_weights_transform"><code class="docutils literal notranslate"><span class="pre">get_objective_weights_transform()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.objective.apply_constraints_nonnegative_soft"><code class="docutils literal notranslate"><span class="pre">apply_constraints_nonnegative_soft()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.objective.compute_feasibility_indicator"><code class="docutils literal notranslate"><span class="pre">compute_feasibility_indicator()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.objective.compute_smoothed_feasibility_indicator"><code class="docutils literal notranslate"><span class="pre">compute_smoothed_feasibility_indicator()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.objective.apply_constraints"><code class="docutils literal notranslate"><span class="pre">apply_constraints()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.rounding">Rounding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.rounding.approximate_round"><code class="docutils literal notranslate"><span class="pre">approximate_round()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.rounding.IdentitySTEFunction"><code class="docutils literal notranslate"><span class="pre">IdentitySTEFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.rounding.IdentitySTEFunction.backward"><code class="docutils literal notranslate"><span class="pre">IdentitySTEFunction.backward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.rounding.RoundSTE"><code class="docutils literal notranslate"><span class="pre">RoundSTE</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.rounding.RoundSTE.forward"><code class="docutils literal notranslate"><span class="pre">RoundSTE.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.rounding.OneHotArgmaxSTE"><code class="docutils literal notranslate"><span class="pre">OneHotArgmaxSTE</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.rounding.OneHotArgmaxSTE.forward"><code class="docutils literal notranslate"><span class="pre">OneHotArgmaxSTE.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.sampling">Sampling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.manual_seed"><code class="docutils literal notranslate"><span class="pre">manual_seed()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.draw_sobol_samples"><code class="docutils literal notranslate"><span class="pre">draw_sobol_samples()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.draw_sobol_normal_samples"><code class="docutils literal notranslate"><span class="pre">draw_sobol_normal_samples()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.sample_hypersphere"><code class="docutils literal notranslate"><span class="pre">sample_hypersphere()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.sample_simplex"><code class="docutils literal notranslate"><span class="pre">sample_simplex()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.sample_polytope"><code class="docutils literal notranslate"><span class="pre">sample_polytope()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.batched_multinomial"><code class="docutils literal notranslate"><span class="pre">batched_multinomial()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.find_interior_point"><code class="docutils literal notranslate"><span class="pre">find_interior_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler"><code class="docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler.feasible"><code class="docutils literal notranslate"><span class="pre">PolytopeSampler.feasible()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler.find_interior_point"><code class="docutils literal notranslate"><span class="pre">PolytopeSampler.find_interior_point()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler.draw"><code class="docutils literal notranslate"><span class="pre">PolytopeSampler.draw()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.HitAndRunPolytopeSampler"><code class="docutils literal notranslate"><span class="pre">HitAndRunPolytopeSampler</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.sampling.HitAndRunPolytopeSampler.draw"><code class="docutils literal notranslate"><span class="pre">HitAndRunPolytopeSampler.draw()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.DelaunayPolytopeSampler"><code class="docutils literal notranslate"><span class="pre">DelaunayPolytopeSampler</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.sampling.DelaunayPolytopeSampler.draw"><code class="docutils literal notranslate"><span class="pre">DelaunayPolytopeSampler.draw()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.normalize_sparse_linear_constraints"><code class="docutils literal notranslate"><span class="pre">normalize_sparse_linear_constraints()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.normalize_dense_linear_constraints"><code class="docutils literal notranslate"><span class="pre">normalize_dense_linear_constraints()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.get_polytope_samples"><code class="docutils literal notranslate"><span class="pre">get_polytope_samples()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.sparse_to_dense_constraints"><code class="docutils literal notranslate"><span class="pre">sparse_to_dense_constraints()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.optimize_posterior_samples"><code class="docutils literal notranslate"><span class="pre">optimize_posterior_samples()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.boltzmann_sample"><code class="docutils literal notranslate"><span class="pre">boltzmann_sample()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.sample_truncated_normal_perturbations"><code class="docutils literal notranslate"><span class="pre">sample_truncated_normal_perturbations()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.sampling.sample_perturbed_subset_dims"><code class="docutils literal notranslate"><span class="pre">sample_perturbed_subset_dims()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.testing">Testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.BotorchTestCase"><code class="docutils literal notranslate"><span class="pre">BotorchTestCase</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.BotorchTestCase.device"><code class="docutils literal notranslate"><span class="pre">BotorchTestCase.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.BotorchTestCase.setUp"><code class="docutils literal notranslate"><span class="pre">BotorchTestCase.setUp()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.BotorchTestCase.assertAllClose"><code class="docutils literal notranslate"><span class="pre">BotorchTestCase.assertAllClose()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn"><code class="docutils literal notranslate"><span class="pre">BaseTestProblemTestCaseMixIn</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn.test_forward_and_evaluate_true"><code class="docutils literal notranslate"><span class="pre">BaseTestProblemTestCaseMixIn.test_forward_and_evaluate_true()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn.functions"><code class="docutils literal notranslate"><span class="pre">BaseTestProblemTestCaseMixIn.functions</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin"><code class="docutils literal notranslate"><span class="pre">SyntheticTestFunctionTestCaseMixin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimal_value"><code class="docutils literal notranslate"><span class="pre">SyntheticTestFunctionTestCaseMixin.test_optimal_value()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimizer"><code class="docutils literal notranslate"><span class="pre">SyntheticTestFunctionTestCaseMixin.test_optimizer()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.functions"><code class="docutils literal notranslate"><span class="pre">SyntheticTestFunctionTestCaseMixin.functions</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin"><code class="docutils literal notranslate"><span class="pre">MultiObjectiveTestProblemTestCaseMixin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_attributes"><code class="docutils literal notranslate"><span class="pre">MultiObjectiveTestProblemTestCaseMixin.test_attributes()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_max_hv"><code class="docutils literal notranslate"><span class="pre">MultiObjectiveTestProblemTestCaseMixin.test_max_hv()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_ref_point"><code class="docutils literal notranslate"><span class="pre">MultiObjectiveTestProblemTestCaseMixin.test_ref_point()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.functions"><code class="docutils literal notranslate"><span class="pre">MultiObjectiveTestProblemTestCaseMixin.functions</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin"><code class="docutils literal notranslate"><span class="pre">ConstrainedTestProblemTestCaseMixin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_num_constraints"><code class="docutils literal notranslate"><span class="pre">ConstrainedTestProblemTestCaseMixin.test_num_constraints()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_evaluate_slack"><code class="docutils literal notranslate"><span class="pre">ConstrainedTestProblemTestCaseMixin.test_evaluate_slack()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.functions"><code class="docutils literal notranslate"><span class="pre">ConstrainedTestProblemTestCaseMixin.functions</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.TestCorruptedProblemsMixin"><code class="docutils literal notranslate"><span class="pre">TestCorruptedProblemsMixin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.TestCorruptedProblemsMixin.setUp"><code class="docutils literal notranslate"><span class="pre">TestCorruptedProblemsMixin.setUp()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.MockPosterior"><code class="docutils literal notranslate"><span class="pre">MockPosterior</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.device"><code class="docutils literal notranslate"><span class="pre">MockPosterior.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.dtype"><code class="docutils literal notranslate"><span class="pre">MockPosterior.dtype</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.batch_shape"><code class="docutils literal notranslate"><span class="pre">MockPosterior.batch_shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.base_sample_shape"><code class="docutils literal notranslate"><span class="pre">MockPosterior.base_sample_shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.batch_range"><code class="docutils literal notranslate"><span class="pre">MockPosterior.batch_range</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.mean"><code class="docutils literal notranslate"><span class="pre">MockPosterior.mean</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.variance"><code class="docutils literal notranslate"><span class="pre">MockPosterior.variance</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.rsample"><code class="docutils literal notranslate"><span class="pre">MockPosterior.rsample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockPosterior.rsample_from_base_samples"><code class="docutils literal notranslate"><span class="pre">MockPosterior.rsample_from_base_samples()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.get_sampler_mock"><code class="docutils literal notranslate"><span class="pre">get_sampler_mock()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.MockModel"><code class="docutils literal notranslate"><span class="pre">MockModel</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockModel.posterior"><code class="docutils literal notranslate"><span class="pre">MockModel.posterior()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockModel.num_outputs"><code class="docutils literal notranslate"><span class="pre">MockModel.num_outputs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockModel.batch_shape"><code class="docutils literal notranslate"><span class="pre">MockModel.batch_shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockModel.state_dict"><code class="docutils literal notranslate"><span class="pre">MockModel.state_dict()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockModel.load_state_dict"><code class="docutils literal notranslate"><span class="pre">MockModel.load_state_dict()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.MockAcquisitionFunction"><code class="docutils literal notranslate"><span class="pre">MockAcquisitionFunction</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.testing.MockAcquisitionFunction.set_X_pending"><code class="docutils literal notranslate"><span class="pre">MockAcquisitionFunction.set_X_pending()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.get_random_data"><code class="docutils literal notranslate"><span class="pre">get_random_data()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.get_test_posterior"><code class="docutils literal notranslate"><span class="pre">get_test_posterior()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.get_max_violation_of_bounds"><code class="docutils literal notranslate"><span class="pre">get_max_violation_of_bounds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.testing.get_max_violation_of_constraints"><code class="docutils literal notranslate"><span class="pre">get_max_violation_of_constraints()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.test_helpers">Test Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.get_model"><code class="docutils literal notranslate"><span class="pre">get_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.get_fully_bayesian_model"><code class="docutils literal notranslate"><span class="pre">get_fully_bayesian_model()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.get_fully_bayesian_model_list"><code class="docutils literal notranslate"><span class="pre">get_fully_bayesian_model_list()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.get_sample_moments"><code class="docutils literal notranslate"><span class="pre">get_sample_moments()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.standardize_moments"><code class="docutils literal notranslate"><span class="pre">standardize_moments()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.gen_multi_task_dataset"><code class="docutils literal notranslate"><span class="pre">gen_multi_task_dataset()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.get_pvar_expected"><code class="docutils literal notranslate"><span class="pre">get_pvar_expected()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform"><code class="docutils literal notranslate"><span class="pre">DummyNonScalarizingPosteriorTransform</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.scalarize"><code class="docutils literal notranslate"><span class="pre">DummyNonScalarizingPosteriorTransform.scalarize</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.evaluate"><code class="docutils literal notranslate"><span class="pre">DummyNonScalarizingPosteriorTransform.evaluate()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.forward"><code class="docutils literal notranslate"><span class="pre">DummyNonScalarizingPosteriorTransform.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.test_helpers.SimpleGPyTorchModel"><code class="docutils literal notranslate"><span class="pre">SimpleGPyTorchModel</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.test_helpers.SimpleGPyTorchModel.last_fantasize_flag"><code class="docutils literal notranslate"><span class="pre">SimpleGPyTorchModel.last_fantasize_flag</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.test_helpers.SimpleGPyTorchModel.forward"><code class="docutils literal notranslate"><span class="pre">SimpleGPyTorchModel.forward()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.torch">Torch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.torch.BufferDict"><code class="docutils literal notranslate"><span class="pre">BufferDict</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.clear"><code class="docutils literal notranslate"><span class="pre">BufferDict.clear()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.pop"><code class="docutils literal notranslate"><span class="pre">BufferDict.pop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.keys"><code class="docutils literal notranslate"><span class="pre">BufferDict.keys()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.items"><code class="docutils literal notranslate"><span class="pre">BufferDict.items()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.values"><code class="docutils literal notranslate"><span class="pre">BufferDict.values()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.update"><code class="docutils literal notranslate"><span class="pre">BufferDict.update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.torch.BufferDict.extra_repr"><code class="docutils literal notranslate"><span class="pre">BufferDict.extra_repr()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.transforms">Transformations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.standardize"><code class="docutils literal notranslate"><span class="pre">standardize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.normalize"><code class="docutils literal notranslate"><span class="pre">normalize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.unnormalize"><code class="docutils literal notranslate"><span class="pre">unnormalize()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.normalize_indices"><code class="docutils literal notranslate"><span class="pre">normalize_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.is_fully_bayesian"><code class="docutils literal notranslate"><span class="pre">is_fully_bayesian()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.is_ensemble"><code class="docutils literal notranslate"><span class="pre">is_ensemble()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.t_batch_mode_transform"><code class="docutils literal notranslate"><span class="pre">t_batch_mode_transform()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.concatenate_pending_points"><code class="docutils literal notranslate"><span class="pre">concatenate_pending_points()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.match_batch_shape"><code class="docutils literal notranslate"><span class="pre">match_batch_shape()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.transforms.convert_to_target_pre_hook"><code class="docutils literal notranslate"><span class="pre">convert_to_target_pre_hook()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.feasible_volume">Feasible Volume</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.feasible_volume.get_feasible_samples"><code class="docutils literal notranslate"><span class="pre">get_feasible_samples()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.feasible_volume.get_outcome_feasibility_probability"><code class="docutils literal notranslate"><span class="pre">get_outcome_feasibility_probability()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.feasible_volume.estimate_feasible_volume"><code class="docutils literal notranslate"><span class="pre">estimate_feasible_volume()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.types">Types and Type Hints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.types.cast"><code class="docutils literal notranslate"><span class="pre">cast()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.types.DEFAULT"><code class="docutils literal notranslate"><span class="pre">DEFAULT</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.types.MISSING"><code class="docutils literal notranslate"><span class="pre">MISSING</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.constants">Constants</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.constants.get_constants"><code class="docutils literal notranslate"><span class="pre">get_constants()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.constants.get_constants_like"><code class="docutils literal notranslate"><span class="pre">get_constants_like()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.safe_math">Safe Math</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.exp"><code class="docutils literal notranslate"><span class="pre">exp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.log"><code class="docutils literal notranslate"><span class="pre">log()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.add"><code class="docutils literal notranslate"><span class="pre">add()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.sub"><code class="docutils literal notranslate"><span class="pre">sub()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.div"><code class="docutils literal notranslate"><span class="pre">div()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.mul"><code class="docutils literal notranslate"><span class="pre">mul()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.log1mexp"><code class="docutils literal notranslate"><span class="pre">log1mexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.log1pexp"><code class="docutils literal notranslate"><span class="pre">log1pexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.logexpit"><code class="docutils literal notranslate"><span class="pre">logexpit()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.logplusexp"><code class="docutils literal notranslate"><span class="pre">logplusexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.logdiffexp"><code class="docutils literal notranslate"><span class="pre">logdiffexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.logsumexp"><code class="docutils literal notranslate"><span class="pre">logsumexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.logmeanexp"><code class="docutils literal notranslate"><span class="pre">logmeanexp()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.log_softplus"><code class="docutils literal notranslate"><span class="pre">log_softplus()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.smooth_amax"><code class="docutils literal notranslate"><span class="pre">smooth_amax()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.smooth_amin"><code class="docutils literal notranslate"><span class="pre">smooth_amin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.check_dtype_float32_or_float64"><code class="docutils literal notranslate"><span class="pre">check_dtype_float32_or_float64()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.log_fatplus"><code class="docutils literal notranslate"><span class="pre">log_fatplus()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.fatplus"><code class="docutils literal notranslate"><span class="pre">fatplus()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.fatmax"><code class="docutils literal notranslate"><span class="pre">fatmax()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.fatmin"><code class="docutils literal notranslate"><span class="pre">fatmin()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.fatmaximum"><code class="docutils literal notranslate"><span class="pre">fatmaximum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.fatminimum"><code class="docutils literal notranslate"><span class="pre">fatminimum()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.log_fatmoid"><code class="docutils literal notranslate"><span class="pre">log_fatmoid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.fatmoid"><code class="docutils literal notranslate"><span class="pre">fatmoid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.cauchy"><code class="docutils literal notranslate"><span class="pre">cauchy()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.safe_math.sigmoid"><code class="docutils literal notranslate"><span class="pre">sigmoid()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#multi-objective-utilities">Multi-Objective Utilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition">Abstract Box Decompositions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.pareto_Y"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.pareto_Y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.ref_point"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.ref_point</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.Y"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.Y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.partition_space"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.partition_space()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.get_hypercell_bounds"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.get_hypercell_bounds()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.update"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.reset"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.reset()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.compute_hypervolume"><code class="docutils literal notranslate"><span class="pre">BoxDecomposition.compute_hypervolume()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning"><code class="docutils literal notranslate"><span class="pre">FastPartitioning</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.update"><code class="docutils literal notranslate"><span class="pre">FastPartitioning.update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.partition_space"><code class="docutils literal notranslate"><span class="pre">FastPartitioning.partition_space()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.get_hypercell_bounds"><code class="docutils literal notranslate"><span class="pre">FastPartitioning.get_hypercell_bounds()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list">Box Decomposition List</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList"><code class="docutils literal notranslate"><span class="pre">BoxDecompositionList</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y"><code class="docutils literal notranslate"><span class="pre">BoxDecompositionList.pareto_Y</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point"><code class="docutils literal notranslate"><span class="pre">BoxDecompositionList.ref_point</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds"><code class="docutils literal notranslate"><span class="pre">BoxDecompositionList.get_hypercell_bounds()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update"><code class="docutils literal notranslate"><span class="pre">BoxDecompositionList.update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume"><code class="docutils literal notranslate"><span class="pre">BoxDecompositionList.compute_hypervolume()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.box_decompositions.utils">Box Decomposition Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds"><code class="docutils literal notranslate"><span class="pre">compute_local_upper_bounds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds"><code class="docutils literal notranslate"><span class="pre">get_partition_bounds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental"><code class="docutils literal notranslate"><span class="pre">update_local_upper_bounds_incremental()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d"><code class="docutils literal notranslate"><span class="pre">compute_non_dominated_hypercell_bounds_2d()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d"><code class="docutils literal notranslate"><span class="pre">compute_dominated_hypercell_bounds_2d()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.box_decompositions.dominated">Dominated Partitionings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning"><code class="docutils literal notranslate"><span class="pre">DominatedPartitioning</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.hypervolume">Hypervolume</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.infer_reference_point"><code class="docutils literal notranslate"><span class="pre">infer_reference_point()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Hypervolume"><code class="docutils literal notranslate"><span class="pre">Hypervolume</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point"><code class="docutils literal notranslate"><span class="pre">Hypervolume.ref_point</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.compute"><code class="docutils literal notranslate"><span class="pre">Hypervolume.compute()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.sort_by_dimension"><code class="docutils literal notranslate"><span class="pre">sort_by_dimension()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node"><code class="docutils literal notranslate"><span class="pre">Node</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.MultiList"><code class="docutils literal notranslate"><span class="pre">MultiList</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.MultiList.append"><code class="docutils literal notranslate"><span class="pre">MultiList.append()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.MultiList.extend"><code class="docutils literal notranslate"><span class="pre">MultiList.extend()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.MultiList.remove"><code class="docutils literal notranslate"><span class="pre">MultiList.remove()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.MultiList.reinsert"><code class="docutils literal notranslate"><span class="pre">MultiList.reinsert()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.SubsetIndexCachingMixin"><code class="docutils literal notranslate"><span class="pre">SubsetIndexCachingMixin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.SubsetIndexCachingMixin.compute_q_subset_indices"><code class="docutils literal notranslate"><span class="pre">SubsetIndexCachingMixin.compute_q_subset_indices()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.compute_subset_indices"><code class="docutils literal notranslate"><span class="pre">compute_subset_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin"><code class="docutils literal notranslate"><span class="pre">NoisyExpectedHypervolumeMixin</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin.X_baseline"><code class="docutils literal notranslate"><span class="pre">NoisyExpectedHypervolumeMixin.X_baseline</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin.set_X_pending"><code class="docutils literal notranslate"><span class="pre">NoisyExpectedHypervolumeMixin.set_X_pending()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.box_decompositions.non_dominated">Non-dominated Partitionings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning"><code class="docutils literal notranslate"><span class="pre">NondominatedPartitioning</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds"><code class="docutils literal notranslate"><span class="pre">NondominatedPartitioning.get_hypercell_bounds()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning"><code class="docutils literal notranslate"><span class="pre">FastNondominatedPartitioning</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.pareto">Pareto</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.pareto.is_non_dominated"><code class="docutils literal notranslate"><span class="pre">is_non_dominated()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.multi_objective.scalarization">Scalarization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization"><code class="docutils literal notranslate"><span class="pre">get_chebyshev_scalarization()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#probability-utilities">Probability Utilities</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.mvnxpb">Multivariate Gaussian Probabilities via Bivariate Conditioning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState"><code class="docutils literal notranslate"><span class="pre">mvnxpbState</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.step"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.step</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.perm"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.perm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.bounds"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.bounds</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.piv_chol"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.piv_chol</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.plug_ins"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.plug_ins</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.log_prob"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.log_prob</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState.log_prob_extra"><code class="docutils literal notranslate"><span class="pre">mvnxpbState.log_prob_extra</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB"><code class="docutils literal notranslate"><span class="pre">MVNXPB</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.build"><code class="docutils literal notranslate"><span class="pre">MVNXPB.build()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.solve"><code class="docutils literal notranslate"><span class="pre">MVNXPB.solve()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.select_pivot"><code class="docutils literal notranslate"><span class="pre">MVNXPB.select_pivot()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.pivot_"><code class="docutils literal notranslate"><span class="pre">MVNXPB.pivot_()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.concat"><code class="docutils literal notranslate"><span class="pre">MVNXPB.concat()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.expand"><code class="docutils literal notranslate"><span class="pre">MVNXPB.expand()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.augment"><code class="docutils literal notranslate"><span class="pre">MVNXPB.augment()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.detach"><code class="docutils literal notranslate"><span class="pre">MVNXPB.detach()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.clone"><code class="docutils literal notranslate"><span class="pre">MVNXPB.clone()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB.asdict"><code class="docutils literal notranslate"><span class="pre">MVNXPB.asdict()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.truncated_multivariate_normal">Truncated Multivariate Normal Distribution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_prob"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal.log_prob()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.rsample"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal.rsample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_partition"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal.log_partition</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.solver"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal.solver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.sampler"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal.sampler</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.expand"><code class="docutils literal notranslate"><span class="pre">TruncatedMultivariateNormal.expand()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.unified_skew_normal">Unified Skew Normal Distribution</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.arg_constraints"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal.arg_constraints</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.log_prob"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal.log_prob()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.rsample"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal.rsample()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.expand"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal.expand()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.covariance_matrix"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal.covariance_matrix</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.scale_tril"><code class="docutils literal notranslate"><span class="pre">UnifiedSkewNormal.scale_tril</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.bvn">Bivariate Normal Probabilities and Statistics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.bvn.bvn"><code class="docutils literal notranslate"><span class="pre">bvn()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.bvn.bvnu"><code class="docutils literal notranslate"><span class="pre">bvnu()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.bvn.bvnmom"><code class="docutils literal notranslate"><span class="pre">bvnmom()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.lin_ess">Elliptic Slice Sampler with Linear Constraints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler"><code class="docutils literal notranslate"><span class="pre">LinearEllipticalSliceSampler</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.lifetime_samples"><code class="docutils literal notranslate"><span class="pre">LinearEllipticalSliceSampler.lifetime_samples</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.draw"><code class="docutils literal notranslate"><span class="pre">LinearEllipticalSliceSampler.draw()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.step"><code class="docutils literal notranslate"><span class="pre">LinearEllipticalSliceSampler.step()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.lin_ess.get_index_tensors"><code class="docutils literal notranslate"><span class="pre">get_index_tensors()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.linalg">Linear Algebra Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.linalg.block_matrix_concat"><code class="docutils literal notranslate"><span class="pre">block_matrix_concat()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.linalg.augment_cholesky"><code class="docutils literal notranslate"><span class="pre">augment_cholesky()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.step"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.step</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.tril"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.tril</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.perm"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.perm</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.diag"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.diag</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.validate_init"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.validate_init</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.update_"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.update_()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.pivot_"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.pivot_()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.expand"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.expand()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.concat"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.concat()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.detach"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.detach()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky.clone"><code class="docutils literal notranslate"><span class="pre">PivotedCholesky.clone()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-botorch.utils.probability.utils">Probability Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.case_dispatcher"><code class="docutils literal notranslate"><span class="pre">case_dispatcher()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.get_constants"><code class="docutils literal notranslate"><span class="pre">get_constants()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.get_constants_like"><code class="docutils literal notranslate"><span class="pre">get_constants_like()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.gen_positional_indices"><code class="docutils literal notranslate"><span class="pre">gen_positional_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.build_positional_indices"><code class="docutils literal notranslate"><span class="pre">build_positional_indices()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.leggauss"><code class="docutils literal notranslate"><span class="pre">leggauss()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.ndtr"><code class="docutils literal notranslate"><span class="pre">ndtr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.phi"><code class="docutils literal notranslate"><span class="pre">phi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.log_phi"><code class="docutils literal notranslate"><span class="pre">log_phi()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.log_ndtr"><code class="docutils literal notranslate"><span class="pre">log_ndtr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.log_erfc"><code class="docutils literal notranslate"><span class="pre">log_erfc()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.log_erfcx"><code class="docutils literal notranslate"><span class="pre">log_erfcx()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.standard_normal_log_hazard"><code class="docutils literal notranslate"><span class="pre">standard_normal_log_hazard()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.log_prob_normal_in"><code class="docutils literal notranslate"><span class="pre">log_prob_normal_in()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.swap_along_dim_"><code class="docutils literal notranslate"><span class="pre">swap_along_dim_()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.compute_log_prob_feas_from_bounds"><code class="docutils literal notranslate"><span class="pre">compute_log_prob_feas_from_bounds()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#botorch.utils.probability.utils.percentile_of_score"><code class="docutils literal notranslate"><span class="pre">percentile_of_score()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">BoTorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">botorch.utils</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/utils.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-botorch.utils">
<span id="botorch-utils"></span><h1>botorch.utils<a class="headerlink" href="#module-botorch.utils" title="Link to this heading"></a></h1>
<section id="module-botorch.utils.constraints">
<span id="constraints"></span><h2>Constraints<a class="headerlink" href="#module-botorch.utils.constraints" title="Link to this heading"></a></h2>
<p>Helpers for handling input or outcome constraints.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constraints.get_outcome_constraint_transforms">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">get_outcome_constraint_transforms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#get_outcome_constraint_transforms"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.get_outcome_constraint_transforms" title="Link to this definition"></a></dt>
<dd><p>Create outcome constraint callables from outcome constraint tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outcome_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – A tuple of <cite>(A, b)</cite>. For <cite>k</cite> outcome constraints
and <cite>m</cite> outputs at <cite>f(x)`</cite>, <cite>A</cite> is <cite>k x m</cite> and <cite>b</cite> is <cite>k x 1</cite> such
that <cite>A f(x) &lt;= b</cite>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of callables, each mapping a Tensor of size <cite>b x q x m</cite> to a
tensor of size <cite>b x q</cite>, where <cite>m</cite> is the number of outputs of the model.
Negative values imply feasibility. The callables support broadcasting
(e.g. for calling on a tensor of shape <cite>mc_samples x b x q x m</cite>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[<em>Callable</em>[[<em>Tensor</em>], <em>Tensor</em>]] | None</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># constrain `f(x)[0] &lt;= 0`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outcome_constraints</span> <span class="o">=</span> <span class="n">get_outcome_constraint_transforms</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constraints.get_monotonicity_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">get_monotonicity_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#get_monotonicity_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.get_monotonicity_constraints" title="Link to this definition"></a></dt>
<dd><p>Returns a system of linear inequalities <cite>(A, b)</cite> that generically encodes order
constraints on the elements of a <cite>d</cite>-dimsensional space, i.e. <cite>A &#64; x &lt; b</cite> implies
<cite>x[i] &lt; x[i + 1]</cite> for a <cite>d</cite>-dimensional vector <cite>x</cite>.</p>
<p>Idea: Could encode <cite>A</cite> as sparse matrix, if it is supported well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – Dimensionality of the constraint space, i.e. number of monotonic parameters.</p></li>
<li><p><strong>descending</strong> (<em>bool</em>) – If True, forces the elements of a vector to be monotonically de-
creasing and be monotonically increasing otherwise.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The dtype of the returned Tensors.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The device of the returned Tensors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of Tensors <cite>(A, b)</cite> representing the monotonicity constraint as a system
of linear inequalities <cite>A &#64; x &lt; b</cite>. <cite>A</cite> is <cite>(d - 1) x d</cite>-dimensional and <cite>b</cite> is
<cite>(d - 1) x 1</cite>-dimensional.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.constraints.NonTransformedInterval">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">NonTransformedInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#NonTransformedInterval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.NonTransformedInterval" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></p>
<p>Modification of the GPyTorch interval class that does not apply transformations.</p>
<p>This is generally useful, and it is a requirement for the sparse parameters of the
Relevance Pursuit model <a class="reference internal" href="models.html#ament2024pursuit" id="id1"><span>[Ament2024pursuit]</span></a>, since it is not possible to achieve
exact zeros with the sigmoid transformations that are applied by default in the
GPyTorch Interval class. The variant implemented here does not apply transformations
to the parameters, instead passing the bounds constraint to the scipy L-BFGS
optimizer. This allows for the expression of exact zeros for sparse optimization
algorithms.</p>
<p>NOTE: On a high level, the cleanest solution for this would be to separate out the
1) definition and book-keeping of parameter constraints on the one hand, and
2) the re-parameterization of the variables with some monotonic transformation,
since the two steps are orthogonal, but this would require refactoring GPyTorch.</p>
<p>Constructor of the NonTransformedInterval class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower_bound</strong> (<em>float</em><em> | </em><em>Tensor</em>) – The lower bound of the interval.</p></li>
<li><p><strong>upper_bound</strong> (<em>float</em><em> | </em><em>Tensor</em>) – The upper bound of the interval.</p></li>
<li><p><strong>initial_value</strong> (<em>float</em><em> | </em><em>Tensor</em><em> | </em><em>None</em>) – The initial value of the parameter.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.constraints.NonTransformedInterval.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#NonTransformedInterval.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.NonTransformedInterval.transform" title="Link to this definition"></a></dt>
<dd><p>Transforms a tensor to satisfy the specified bounds.</p>
<p>If upper_bound is finite, we assume that <cite>self.transform</cite> saturates at 1 as tensor -&gt; infinity. Similarly,
if lower_bound is finite, we assume that <cite>self.transform</cite> saturates at 0 as tensor -&gt; -infinity.</p>
<p>Example transforms for one of the bounds being finite include torch.exp and torch.nn.functional.softplus.
An example transform for the case where both are finite is torch.nn.functional.sigmoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.constraints.NonTransformedInterval.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transformed_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#NonTransformedInterval.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.NonTransformedInterval.inverse_transform" title="Link to this definition"></a></dt>
<dd><p>Applies the inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>transformed_tensor</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.constraints.LogTransformedInterval">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.constraints.</span></span><span class="sig-name descname"><span class="pre">LogTransformedInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#LogTransformedInterval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.LogTransformedInterval" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></p>
<p>Modification of the GPyTorch interval class.</p>
<p>The Interval class in GPyTorch will map the parameter to the range [0, 1] before
applying the inverse transform. LogTransformedInterval skips this step to avoid
numerical issues, and applies the log transform directly to the parameter values.
GPyTorch automatically recognizes that the bound constraint have not been applied
yet, and passes the bounds to the optimizer instead, which then optimizes
log(parameter) under the constraints log(lower) &lt;= log(parameter) &lt;= log(upper).</p>
<p>Constructor of the LogTransformedInterval class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lower_bound</strong> (<em>float</em>) – The lower bound of the interval.</p></li>
<li><p><strong>upper_bound</strong> (<em>float</em>) – The upper bound of the interval.</p></li>
<li><p><strong>initial_value</strong> (<em>float</em><em> | </em><em>None</em>) – The initial value of the parameter.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.constraints.LogTransformedInterval.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#LogTransformedInterval.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.LogTransformedInterval.transform" title="Link to this definition"></a></dt>
<dd><p>Transform the parameter using the exponential function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tensor</strong> (<em>Tensor</em>) – Tensor of parameter values to transform.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor of transformed parameter values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.constraints.LogTransformedInterval.inverse_transform">
<span class="sig-name descname"><span class="pre">inverse_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transformed_tensor</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constraints.html#LogTransformedInterval.inverse_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constraints.LogTransformedInterval.inverse_transform" title="Link to this definition"></a></dt>
<dd><p>Untransform the parameter using the natural logarithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tensor</strong> – Tensor of parameter values to untransform.</p></li>
<li><p><strong>transformed_tensor</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor of untransformed parameter values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.containers">
<span id="containers"></span><h2>Containers<a class="headerlink" href="#module-botorch.utils.containers" title="Link to this heading"></a></h2>
<p>Representations for different kinds of data.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.containers.BotorchContainer">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.containers.</span></span><span class="sig-name descname"><span class="pre">BotorchContainer</span></span><a class="reference internal" href="_modules/botorch/utils/containers.html#BotorchContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.BotorchContainer" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Abstract base class for BoTorch’s data containers.</p>
<p>A BotorchContainer represents a tensor, which should be the sole object
returned by its <cite>__call__</cite> method. Said tensor is expected to consist of
one or more “events” (e.g. data points or feature vectors), whose shape is
given by the required <cite>event_shape</cite> field.</p>
<p>Notice: Once version 3.10 becomes standard, this class should
be reworked to take advantage of dataclasses’ <cite>kw_only</cite> flag.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.BotorchContainer.event_shape">
<span class="sig-name descname"><span class="pre">event_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.BotorchContainer.event_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.BotorchContainer.shape">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.BotorchContainer.shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.BotorchContainer.device">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.containers.BotorchContainer.device" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.BotorchContainer.dtype">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.containers.BotorchContainer.dtype" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.containers.</span></span><span class="sig-name descname"><span class="pre">DenseContainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#DenseContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.DenseContainer" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.containers.BotorchContainer" title="botorch.utils.containers.BotorchContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BotorchContainer</span></code></a></p>
<p>Basic representation of data stored as a dense Tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>event_shape</strong> (<em>Size</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.values">
<span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.values" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.event_shape">
<span class="sig-name descname"><span class="pre">event_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.event_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.shape">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.device">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.device" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.dtype">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.containers.DenseContainer.dtype" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.containers.DenseContainer.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#DenseContainer.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.DenseContainer.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.containers.DenseContainer" title="botorch.utils.containers.DenseContainer"><em>DenseContainer</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.containers.</span></span><span class="sig-name descname"><span class="pre">SliceContainer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#SliceContainer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.SliceContainer" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.containers.BotorchContainer" title="botorch.utils.containers.BotorchContainer"><code class="xref py py-class docutils literal notranslate"><span class="pre">BotorchContainer</span></code></a></p>
<p>Represent data points formed by concatenating (n-1)-dimensional slices
taken from the leading dimension of an n-dimensional source tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>indices</strong> (<em>LongTensor</em>)</p></li>
<li><p><strong>event_shape</strong> (<em>Size</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.values">
<span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.values" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">LongTensor</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.indices" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.event_shape">
<span class="sig-name descname"><span class="pre">event_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.event_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.shape">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.device">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.device" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.dtype">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.containers.SliceContainer.dtype" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.containers.SliceContainer.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/containers.html#SliceContainer.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.containers.SliceContainer.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.containers.SliceContainer" title="botorch.utils.containers.SliceContainer"><em>SliceContainer</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.context_managers">
<span id="context-managers"></span><h2>Context Managers<a class="headerlink" href="#module-botorch.utils.context_managers" title="Link to this heading"></a></h2>
<p>Utilities for optimization.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">TensorCheckpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#TensorCheckpoint"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">NamedTuple</span></code></p>
<p>Create new instance of TensorCheckpoint(values, device, dtype)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint.values">
<span class="sig-name descname"><span class="pre">values</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint.values" title="Link to this definition"></a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint.device">
<span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint.device" title="Link to this definition"></a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.context_managers.TensorCheckpoint.dtype">
<span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.context_managers.TensorCheckpoint.dtype" title="Link to this definition"></a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.delattr_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">delattr_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">attrs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enforce_hasattr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#delattr_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.delattr_ctx" title="Link to this definition"></a></dt>
<dd><p>Contextmanager for temporarily deleting attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instance</strong> (<em>object</em>)</p></li>
<li><p><strong>attrs</strong> (<em>str</em>)</p></li>
<li><p><strong>enforce_hasattr</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.parameter_rollback_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">parameter_rollback_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#parameter_rollback_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.parameter_rollback_ctx" title="Link to this definition"></a></dt>
<dd><p>Contextmanager that exits by rolling back a module’s state_dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> – Module instance.</p></li>
<li><p><strong>name_filter</strong> – Optional Boolean function used to filter items by name.</p></li>
<li><p><strong>checkpoint</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a><em>] </em><em>| </em><em>None</em>) – Optional cache of values and tensor metadata specifying the rollback
state for the module (or some subset thereof).</p></li>
<li><p><strong>**tkwargs</strong> (<em>Any</em>) – Keyword arguments passed to <cite>torch.Tensor.to</cite> when copying data from
each tensor in <cite>module.state_dict()</cite> to the internally created checkpoint.
Only adhered to when the <cite>checkpoint</cite> argument is None.</p></li>
<li><p><strong>parameters</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><em>Tensor</em><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of TensorCheckpoints for the module’s state_dict. Any in-places
changes to the checkpoint will be observed at rollback time. If the checkpoint
is cleared, no rollback will occur.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Generator</em>[dict[str, <a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a>], None, None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.module_rollback_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">module_rollback_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#module_rollback_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.module_rollback_ctx" title="Link to this definition"></a></dt>
<dd><p>Contextmanager that exits by rolling back a module’s state_dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> (<em>Module</em>) – Module instance.</p></li>
<li><p><strong>name_filter</strong> (<em>Callable</em><em>[</em><em>[</em><em>str</em><em>]</em><em>, </em><em>bool</em><em>] </em><em>| </em><em>None</em>) – Optional Boolean function used to filter items by name.</p></li>
<li><p><strong>checkpoint</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a><em>] </em><em>| </em><em>None</em>) – Optional cache of values and tensor metadata specifying the rollback
state for the module (or some subset thereof).</p></li>
<li><p><strong>**tkwargs</strong> (<em>Any</em>) – Keyword arguments passed to <cite>torch.Tensor.to</cite> when copying data from
each tensor in <cite>module.state_dict()</cite> to the internally created checkpoint.
Only adhered to when the <cite>checkpoint</cite> argument is None.</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary of TensorCheckpoints for the module’s state_dict. Any in-places
changes to the checkpoint will be observed at rollback time. If the checkpoint
is cleared, no rollback will occur.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Generator</em>[dict[str, <a class="reference internal" href="#botorch.utils.context_managers.TensorCheckpoint" title="botorch.utils.context_managers.TensorCheckpoint"><em>TensorCheckpoint</em></a>], None, None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.context_managers.zero_grad_ctx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.context_managers.</span></span><span class="sig-name descname"><span class="pre">zero_grad_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_on_enter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_on_exit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/context_managers.html#zero_grad_ctx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.context_managers.zero_grad_ctx" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameters</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>Iterable</em><em>[</em><em>Tensor</em><em>]</em>)</p></li>
<li><p><strong>zero_on_enter</strong> (<em>bool</em>)</p></li>
<li><p><strong>zero_on_exit</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.datasets">
<span id="datasets"></span><h2>Datasets<a class="headerlink" href="#module-botorch.utils.datasets" title="Link to this heading"></a></h2>
<p>Representations for different kinds of datasets.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">SupervisedDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Yvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#SupervisedDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for datasets consisting of labelled pairs <cite>(X, Y)</cite>
and an optional <cite>Yvar</cite> that stipulates observations variances so
that <cite>Y[i] ~ N(f(X[i]), Yvar[i])</cite>.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;learning_rate&quot;</span><span class="p">,</span> <span class="s2">&quot;embedding_dim&quot;</span><span class="p">]</span>
<span class="n">outcome_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;neg training loss&quot;</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">SupervisedDataset</span><span class="p">(</span>
    <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
    <span class="n">feature_names</span><span class="o">=</span><span class="n">feature_names</span><span class="p">,</span>
    <span class="n">outcome_names</span><span class="o">=</span><span class="n">outcome_names</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">SupervisedDataset</span><span class="p">(</span>
    <span class="n">X</span><span class="o">=</span><span class="n">DenseContainer</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">event_shape</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]),</span>
    <span class="n">Y</span><span class="o">=</span><span class="n">DenseContainer</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">event_shape</span><span class="o">=</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]),</span>
    <span class="n">feature_names</span><span class="o">=</span><span class="n">feature_names</span><span class="p">,</span>
    <span class="n">outcome_names</span><span class="o">=</span><span class="n">outcome_names</span><span class="p">,</span>
<span class="p">)</span>
<span class="k">assert</span> <span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
</pre></div>
</div>
<p>Constructs a <cite>SupervisedDataset</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<a class="reference internal" href="#botorch.utils.containers.BotorchContainer" title="botorch.utils.containers.BotorchContainer"><em>BotorchContainer</em></a><em> | </em><em>Tensor</em>) – A <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing the input features.</p></li>
<li><p><strong>Y</strong> (<a class="reference internal" href="#botorch.utils.containers.BotorchContainer" title="botorch.utils.containers.BotorchContainer"><em>BotorchContainer</em></a><em> | </em><em>Tensor</em>) – A <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing the outcomes.</p></li>
<li><p><strong>feature_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – A list of names of the features in <cite>X</cite>.</p></li>
<li><p><strong>outcome_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – A list of names of the outcomes in <cite>Y</cite>.</p></li>
<li><p><strong>Yvar</strong> (<a class="reference internal" href="#botorch.utils.containers.BotorchContainer" title="botorch.utils.containers.BotorchContainer"><em>BotorchContainer</em></a><em> | </em><em>Tensor</em><em> | </em><em>None</em>) – An optional <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing
the observation noise.</p></li>
<li><p><strong>validate_init</strong> (<em>bool</em>) – If <cite>True</cite>, validates the input shapes.</p></li>
<li><p><strong>group_indices</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>Tensor</cite> representing the which rows of X and Y are
grouped together. This is used to support applications in which multiple
observations should be considered as a group, e.g., learning-curve-based
modeling. If provided, its shape must be compatible with X and Y.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.X">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.X" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.Y">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.Y" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.Yvar">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Yvar</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.Yvar" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.datasets.SupervisedDataset.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deepcopy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#SupervisedDataset.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.SupervisedDataset.clone" title="Link to this definition"></a></dt>
<dd><p>Return a copy of the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deepcopy</strong> (<em>bool</em>) – If True, perform a deep copy. Otherwise, use the same
tensors/lists.</p></li>
<li><p><strong>mask</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>n</cite>-dim boolean mask indicating which rows to keep. This is used
along the -2 dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new dataset.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><em>SupervisedDataset</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.RankingDataset">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">RankingDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#RankingDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.RankingDataset" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupervisedDataset</span></code></a></p>
<p>A SupervisedDataset whose labelled pairs <cite>(x, y)</cite> consist of m-ary combinations
<cite>x ∈ Z^{m}</cite> of elements from a ground set <cite>Z = (z_1, …)</cite> and ranking vectors
<cite>y {0, …, m - 1}^{m}</cite> with properties:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>Ranks start at zero, i.e. min(y) = 0.</p></li>
<li><p>Sorted ranks are contiguous unless one or more ties are present.</p></li>
<li><p><cite>k</cite> ranks are skipped after a <cite>k</cite>-way tie.</p></li>
</ol>
</div></blockquote>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">SliceContainer</span><span class="p">(</span>
    <span class="n">values</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">indices</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="mi">16</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]),</span>
    <span class="n">event_shape</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]),</span>
<span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">DenseContainer</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]),</span>
    <span class="n">event_shape</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;item_0&quot;</span><span class="p">,</span> <span class="s2">&quot;item_1&quot;</span><span class="p">]</span>
<span class="n">outcome_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ranking outcome&quot;</span><span class="p">]</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">RankingDataset</span><span class="p">(</span>
    <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span>
    <span class="n">Y</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span>
    <span class="n">feature_names</span><span class="o">=</span><span class="n">feature_names</span><span class="p">,</span>
    <span class="n">outcome_names</span><span class="o">=</span><span class="n">outcome_names</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Construct a <cite>RankingDataset</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<a class="reference internal" href="#botorch.utils.containers.SliceContainer" title="botorch.utils.containers.SliceContainer"><em>SliceContainer</em></a>) – A <cite>SliceContainer</cite> representing the input features being ranked.</p></li>
<li><p><strong>Y</strong> (<a class="reference internal" href="#botorch.utils.containers.BotorchContainer" title="botorch.utils.containers.BotorchContainer"><em>BotorchContainer</em></a><em> | </em><em>Tensor</em>) – A <cite>Tensor</cite> or <cite>BotorchContainer</cite> representing the rankings.</p></li>
<li><p><strong>feature_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – A list of names of the features in X.</p></li>
<li><p><strong>outcome_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – A list of names of the outcomes in Y.</p></li>
<li><p><strong>validate_init</strong> (<em>bool</em>) – If <cite>True</cite>, validates the input shapes.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">MultiTaskDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datasets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_outcome_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_feature_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#MultiTaskDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupervisedDataset</span></code></a></p>
<p>This is a multi-task dataset that is constructed from the datasets of
individual tasks. It offers functionality to combine parts of individual
datasets to construct the inputs necessary for the <cite>MultiTaskGP</cite> models.</p>
<p>The datasets of individual tasks are allowed to represent different sets
of features. When there are heterogeneous feature sets, calling
<cite>MultiTaskDataset.X</cite> will result in an error.</p>
<p>Construct a <cite>MultiTaskDataset</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>datasets</strong> (<em>list</em><em>[</em><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><em>SupervisedDataset</em></a><em>]</em>) – A list of the datasets of individual tasks. Each dataset
is expected to contain data for only one outcome.</p></li>
<li><p><strong>target_outcome_name</strong> (<em>str</em>) – Name of the target outcome to be modeled.</p></li>
<li><p><strong>task_feature_index</strong> (<em>int</em><em> | </em><em>None</em>) – If the task feature is included in the Xs of the
individual datasets, this should be used to specify its index.
If omitted, the task feature will be appended while concatenating Xs.
If given, we sanity-check that the names of the task features
match between all datasets.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset.from_joint_dataset">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_joint_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_feature_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_task_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_names_per_task</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#MultiTaskDataset.from_joint_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset.from_joint_dataset" title="Link to this definition"></a></dt>
<dd><p>Construct a <cite>MultiTaskDataset</cite> from a joint dataset that includes the
data for all tasks with the task feature index.</p>
<p>This will break down the joint dataset into individual datasets by the value
of the task feature. Each resulting dataset will have its outcome name set
based on <cite>outcome_names_per_task</cite>, with the missing values defaulting to
<cite>task_&lt;task_feature&gt;</cite> (except for the target task, which will retain the
original outcome name from the dataset).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><em>SupervisedDataset</em></a>) – The joint dataset.</p></li>
<li><p><strong>task_feature_index</strong> (<em>int</em>) – The column index of the task feature in <cite>dataset.X</cite>.</p></li>
<li><p><strong>target_task_value</strong> (<em>int</em>) – The value of the task feature for the target task
in the dataset. The data for the target task is filtered according to
<cite>dataset.X[task_feature_index] == target_task_value</cite>.</p></li>
<li><p><strong>outcome_names_per_task</strong> (<em>dict</em><em>[</em><em>int</em><em>, </em><em>str</em><em>] </em><em>| </em><em>None</em>) – Optional dictionary mapping task feature values
to the outcome names for each task. If not provided, the auxiliary
tasks will be named <cite>task_&lt;task_feature&gt;</cite> and the target task will
retain the outcome name from the dataset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>MultiTaskDataset</cite> instance.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset" title="botorch.utils.datasets.MultiTaskDataset"><em>MultiTaskDataset</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset.X">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset.X" title="Link to this definition"></a></dt>
<dd><p>Appends task features, if needed, and concatenates the Xs of datasets to
produce the <cite>train_X</cite> expected by <cite>MultiTaskGP</cite> and subclasses.</p>
<p>If appending the task features, 0 is reserved for the target task and the
remaining tasks are populated with 1, 2, …, len(datasets) - 1.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset.Y">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset.Y" title="Link to this definition"></a></dt>
<dd><p>Concatenates Ys of the datasets.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset.Yvar">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Yvar</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset.Yvar" title="Link to this definition"></a></dt>
<dd><p>Concatenates Yvars of the datasets if they exist.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset.get_dataset_without_task_feature">
<span class="sig-name descname"><span class="pre">get_dataset_without_task_feature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outcome_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#MultiTaskDataset.get_dataset_without_task_feature"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset.get_dataset_without_task_feature" title="Link to this definition"></a></dt>
<dd><p>A helper for extracting the child datasets with their task features removed.</p>
<p>If the task feature index is <cite>None</cite>, the dataset will be returned as is.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>outcome_name</strong> (<em>str</em>) – The outcome name for the dataset to extract.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The dataset without the task feature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><em>SupervisedDataset</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.datasets.MultiTaskDataset.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deepcopy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#MultiTaskDataset.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.MultiTaskDataset.clone" title="Link to this definition"></a></dt>
<dd><p>Return a copy of the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deepcopy</strong> (<em>bool</em>) – If True, perform a deep copy. Otherwise, use the same
tensors/lists/datasets.</p></li>
<li><p><strong>mask</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>n</cite>-dim boolean mask indicating which rows to keep from the target
dataset. This is used along the -2 dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new dataset.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset" title="botorch.utils.datasets.MultiTaskDataset"><em>MultiTaskDataset</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.datasets.ContextualDataset">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.datasets.</span></span><span class="sig-name descname"><span class="pre">ContextualDataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datasets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_decomposition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metric_decomposition</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#ContextualDataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.ContextualDataset" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><code class="xref py py-class docutils literal notranslate"><span class="pre">SupervisedDataset</span></code></a></p>
<p>This is a contextual dataset that is constructed from either a single
dateset containing overall outcome or a list of datasets that each corresponds
to a context breakdown.</p>
<p>Construct a <cite>ContextualDataset</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>datasets</strong> (<em>list</em><em>[</em><a class="reference internal" href="#botorch.utils.datasets.SupervisedDataset" title="botorch.utils.datasets.SupervisedDataset"><em>SupervisedDataset</em></a><em>]</em>) – A list of the datasets of individual tasks. Each dataset
is expected to contain data for only one outcome.</p></li>
<li><p><strong>parameter_decomposition</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><em>list</em><em>[</em><em>str</em><em>]</em><em>]</em>) – Dict from context name to list of feature
names corresponding to that context.</p></li>
<li><p><strong>metric_decomposition</strong> (<em>dict</em><em>[</em><em>str</em><em>, </em><em>list</em><em>[</em><em>str</em><em>]</em><em>] </em><em>| </em><em>None</em>) – Context breakdown metrics. Keys are context names.
Values are the lists of metric names belonging to the context:
{‘context1’: [‘m1_c1’], ‘context2’: [‘m1_c2’],}.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.ContextualDataset.X">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.datasets.ContextualDataset.X" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.ContextualDataset.Y">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.datasets.ContextualDataset.Y" title="Link to this definition"></a></dt>
<dd><p>Concatenates the Ys from the child datasets to create the Y expected
by LCEM model if there are multiple datasets; Or return the Y expected
by LCEA model if there is only one dataset.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.datasets.ContextualDataset.Yvar">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Yvar</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.datasets.ContextualDataset.Yvar" title="Link to this definition"></a></dt>
<dd><p>Concatenates the Yvars from the child datasets to create the Y expected
by LCEM model if there are multiple datasets; Or return the Yvar expected
by LCEA model if there is only one dataset.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.datasets.ContextualDataset.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deepcopy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/datasets.html#ContextualDataset.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.datasets.ContextualDataset.clone" title="Link to this definition"></a></dt>
<dd><p>Return a copy of the dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deepcopy</strong> (<em>bool</em>) – If True, perform a deep copy. Otherwise, use the same
tensors/lists/datasets.</p></li>
<li><p><strong>mask</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>n</cite>-dim boolean mask indicating which rows to keep. This is used
along the -2 dimension. <cite>n</cite> here corresponds to the number of rows in
an individual dataset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new dataset.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.datasets.ContextualDataset" title="botorch.utils.datasets.ContextualDataset"><em>ContextualDataset</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.dispatcher">
<span id="dispatcher"></span><h2>Dispatcher<a class="headerlink" href="#module-botorch.utils.dispatcher" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.type_bypassing_encoder">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.dispatcher.</span></span><span class="sig-name descname"><span class="pre">type_bypassing_encoder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#type_bypassing_encoder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.type_bypassing_encoder" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>arg</strong> (<em>Any</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>type</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.dispatcher.</span></span><span class="sig-name descname"><span class="pre">Dispatcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doc=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoder=&lt;class</span> <span class="pre">'type'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Dispatcher</span></code></p>
<p>Clearing house for multiple dispatch functionality. This class extends
<cite>&lt;multipledispatch.Dispatcher&gt;</cite> by: (i) generalizing the argument encoding
convention during method lookup, (ii) implementing <cite>__getitem__</cite> as a dedicated
method lookup function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – A string identifier for the <cite>Dispatcher</cite> instance.</p></li>
<li><p><strong>doc</strong> (<em>str</em><em> | </em><em>None</em>) – A docstring for the multiply dispatched method(s).</p></li>
<li><p><strong>encoder</strong> (<em>Callable</em><em>[</em><em>Any</em><em>, </em><em>type</em><em>]</em>) – A callable that individually transforms the arguments passed
at runtime in order to construct the key used for method lookup as
<cite>tuple(map(encoder, args))</cite>. Defaults to <cite>type</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.dispatch">
<span class="sig-name descname"><span class="pre">dispatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">types</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.dispatch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.dispatch" title="Link to this definition"></a></dt>
<dd><p>Method lookup strategy. Checks for an exact match before traversing
the set of registered methods according to the current ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>types</strong> (<em>type</em>) – A tuple of types that gets compared with the signatures
of registered methods to determine compatibility.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The first method encountered with a matching signature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Callable</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.encode_args">
<span class="sig-name descname"><span class="pre">encode_args</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.encode_args"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.encode_args" title="Link to this definition"></a></dt>
<dd><p>Converts arguments into a tuple of types used during method lookup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>args</strong> (<em>Any</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[type]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.help">
<span class="sig-name descname"><span class="pre">help</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.help"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.help" title="Link to this definition"></a></dt>
<dd><p>Prints the retrieved method’s docstring.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> (<em>Any</em>)</p></li>
<li><p><strong>kwargs</strong> (<em>Any</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/dispatcher.html#Dispatcher.source"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.source" title="Link to this definition"></a></dt>
<dd><p>Prints the retrieved method’s source types.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.encoder">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">encoder</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">type</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.encoder" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.name">
<span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.funcs">
<span class="sig-name descname"><span class="pre">funcs</span></span><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.funcs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.dispatcher.Dispatcher.doc">
<span class="sig-name descname"><span class="pre">doc</span></span><a class="headerlink" href="#botorch.utils.dispatcher.Dispatcher.doc" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.low_rank">
<span id="low-rank-cholesky-update-utils"></span><h2>Low-Rank Cholesky Update Utils<a class="headerlink" href="#module-botorch.utils.low_rank" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.low_rank.extract_batch_covar">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.low_rank.</span></span><span class="sig-name descname"><span class="pre">extract_batch_covar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mt_mvn</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/low_rank.html#extract_batch_covar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.low_rank.extract_batch_covar" title="Link to this definition"></a></dt>
<dd><p>Extract a batched independent covariance matrix from an MTMVN.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mt_mvn</strong> (<em>MultitaskMultivariateNormal</em>) – A multi-task multivariate normal with a block diagonal
covariance matrix.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A lazy covariance matrix consisting of a batch of the blocks of</dt><dd><p>the diagonal of the MultitaskMultivariateNormal.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>LinearOperator</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.low_rank.sample_cached_cholesky">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.low_rank.</span></span><span class="sig-name descname"><span class="pre">sample_cached_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">baseline_L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/low_rank.html#sample_cached_cholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.low_rank.sample_cached_cholesky" title="Link to this definition"></a></dt>
<dd><p>Get posterior samples at the <cite>q</cite> new points from the joint multi-output
posterior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posterior</strong> (<a class="reference internal" href="posteriors.html#botorch.posteriors.gpytorch.GPyTorchPosterior" title="botorch.posteriors.gpytorch.GPyTorchPosterior"><em>GPyTorchPosterior</em></a>) – The joint posterior is over (X_baseline, X).</p></li>
<li><p><strong>baseline_L</strong> (<em>Tensor</em>) – The baseline lower triangular cholesky factor.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – The number of new points in X.</p></li>
<li><p><strong>base_samples</strong> (<em>Tensor</em>) – The base samples.</p></li>
<li><p><strong>sample_shape</strong> (<em>Size</em>) – The sample shape.</p></li>
<li><p><strong>max_tries</strong> (<em>int</em>) – The number of tries for computing the Cholesky
decomposition with increasing jitter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>sample_shape x batch_shape x q x m</cite>-dim tensor of posterior</dt><dd><p>samples at the new points.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.multitask">
<span id="multi-task-distribution-utils"></span><h2>Multi-Task Distribution Utils<a class="headerlink" href="#module-botorch.utils.multitask" title="Link to this heading"></a></h2>
<p>Helpers for multitask modeling.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multitask.separate_mtmvn">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multitask.</span></span><span class="sig-name descname"><span class="pre">separate_mtmvn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mvn</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multitask.html#separate_mtmvn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multitask.separate_mtmvn" title="Link to this definition"></a></dt>
<dd><p>Separate a MTMVN into a list of MVNs, where covariance across data within each task
are preserved, while covariance across task are dropped.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mvn</strong> (<em>MultitaskMultivariateNormal</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[<em>MultivariateNormal</em>]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.objective">
<span id="objective"></span><h2>Objective<a class="headerlink" href="#module-botorch.utils.objective" title="Link to this heading"></a></h2>
<p>Helpers for handling objectives.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.get_objective_weights_transform">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">get_objective_weights_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#get_objective_weights_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.get_objective_weights_transform" title="Link to this definition"></a></dt>
<dd><p>Create a linear objective callable from a set of weights.</p>
<p>Create a callable mapping a Tensor of size <cite>b x q x m</cite> and an (optional)
Tensor of size <cite>b x q x d</cite> to a Tensor of size <cite>b x q</cite>, where <cite>m</cite> is the
number of outputs of the model using scalarization via the objective weights.
This callable supports broadcasting (e.g. for calling on a tensor of shape
<cite>mc_samples x b x q x m</cite>). For <cite>m = 1</cite>, the objective weight is used to
determine the optimization direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>weights</strong> (<em>Tensor</em><em> | </em><em>None</em>) – a 1-dimensional Tensor containing a weight for each task.
If not provided, the identity mapping is used.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transform function using the objective weights.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Callable</em>[[<em>Tensor</em>, <em>Tensor</em> | None], <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">get_objective_weights_transform</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.apply_constraints_nonnegative_soft">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">apply_constraints_nonnegative_soft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#apply_constraints_nonnegative_soft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.apply_constraints_nonnegative_soft" title="Link to this definition"></a></dt>
<dd><p>Applies constraints to a non-negative objective.</p>
<p>This function uses a sigmoid approximation to an indicator function for
each constraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q (x m’)</cite>-dim Tensor of objective values.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>eta</strong> (<em>Tensor</em><em> | </em><em>float</em>) – The temperature parameter for the sigmoid function. Can be either a float
or a 1-dim tensor. In case of a float the same eta is used for every
constraint in constraints. In case of a tensor the length of the tensor
must match the number of provided constraints. The i-th constraint is
then estimated with the i-th eta value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_samples x b x q (x m’)</cite>-dim tensor of feasibility-weighted objectives.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.compute_feasibility_indicator">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">compute_feasibility_indicator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marginalize_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#compute_feasibility_indicator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.compute_feasibility_indicator" title="Link to this definition"></a></dt>
<dd><p>Computes the feasibility of a list of constraints given posterior samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of callables, each mapping a batch_shape x q x m`-dim Tensor
to a <cite>batch_shape x q</cite>-dim Tensor, where negative values imply feasibility.</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A batch_shape x q x m`-dim Tensor of posterior samples.</p></li>
<li><p><strong>marginalize_dim</strong> (<em>int</em><em> | </em><em>None</em>) – A batch dimension that should be marginalized.
For example, this is useful when using a batched fully Bayesian
model.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x q</cite>-dim tensor of Boolean feasibility values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.compute_smoothed_feasibility_indicator">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">compute_smoothed_feasibility_indicator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#compute_smoothed_feasibility_indicator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.compute_smoothed_feasibility_indicator" title="Link to this definition"></a></dt>
<dd><p>Computes the smoothed feasibility indicator of a list of constraints.</p>
<p>Given posterior samples, using a sigmoid to smoothly approximate the feasibility
indicator of each individual constraint to ensure differentiability and high
gradient signal. The <cite>fat</cite> and <cite>log</cite> options improve the numerical behavior of
the smooth approximation.</p>
<p>NOTE: <em>Negative</em> constraint values are associated with feasibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>eta</strong> (<em>Tensor</em><em> | </em><em>float</em>) – The temperature parameter for the sigmoid function. Can be either a float
or a 1-dim tensor. In case of a float the same eta is used for every
constraint in constraints. In case of a tensor the length of the tensor
must match the number of provided constraints. The i-th constraint is
then estimated with the i-th eta value.</p></li>
<li><p><strong>log</strong> (<em>bool</em>) – Toggles the computation of the log-feasibility indicator.</p></li>
<li><p><strong>fat</strong> (<em>bool</em>) – Toggles the computation of the fat-tailed feasibility indicator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_samples x b x q</cite>-dim tensor of feasibility indicator values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.objective.apply_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.objective.</span></span><span class="sig-name descname"><span class="pre">apply_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infeasible_cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/objective.html#apply_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.objective.apply_constraints" title="Link to this definition"></a></dt>
<dd><p>Apply constraints using an infeasible_cost <cite>M</cite> for negative objectives.</p>
<p>This allows feasibility-weighting an objective for the case where the
objective can be negative by using the following strategy:
(1) Add <cite>M</cite> to make obj non-negative;
(2) Apply constraints using the sigmoid approximation;
(3) Shift by <cite>-M</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>obj</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q (x m’)</cite>-dim Tensor of objective values.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of size <cite>b x q x m</cite>
to a Tensor of size <cite>b x q</cite>, where negative values imply feasibility.
This callable must support broadcasting. Only relevant for multi-
output models (<cite>m</cite> &gt; 1).</p></li>
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>n_samples x b x q x m</cite> Tensor of samples drawn from the posterior.</p></li>
<li><p><strong>infeasible_cost</strong> (<em>float</em>) – The infeasible value.</p></li>
<li><p><strong>eta</strong> (<em>Tensor</em><em> | </em><em>float</em>) – The temperature parameter of the sigmoid function. Can be either a float
or a 1-dim tensor. In case of a float the same eta is used for every
constraint in constraints. In case of a tensor the length of the tensor
must match the number of provided constraints. The i-th constraint is
then estimated with the i-th eta value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_samples x b x q (x m’)</cite>-dim tensor of feasibility-weighted objectives.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.rounding">
<span id="rounding"></span><h2>Rounding<a class="headerlink" href="#module-botorch.utils.rounding" title="Link to this heading"></a></h2>
<p>Discretization (rounding) functions for acquisition optimization.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="daulton2022bopr" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Daulton2022bopr<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p>S. Daulton, X. Wan, D. Eriksson, M. Balandat, M. A. Osborne, E. Bakshy.
Bayesian Optimization over Discrete and Mixed Spaces via Probabilistic
Reparameterization. Advances in Neural Information Processing Systems
35, 2022.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.rounding.approximate_round">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">approximate_round</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#approximate_round"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.approximate_round" title="Link to this definition"></a></dt>
<dd><p>Diffentiable approximate rounding function.</p>
<p>This method is a piecewise approximation of a rounding function where
each piece is a hyperbolic tangent function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – The tensor to round to the nearest integer (element-wise).</p></li>
<li><p><strong>tau</strong> (<em>float</em>) – A temperature hyperparameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The approximately rounded input tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.rounding.IdentitySTEFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">IdentitySTEFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#IdentitySTEFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.IdentitySTEFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></p>
<p>Base class for functions using straight through gradient estimators.</p>
<p>This class approximates the gradient with the identity function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.rounding.IdentitySTEFunction.backward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">backward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grad_output</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#IdentitySTEFunction.backward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.IdentitySTEFunction.backward" title="Link to this definition"></a></dt>
<dd><p>Use a straight-through estimator the gradient.</p>
<p>This uses the identity function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>grad_output</strong> (<em>Tensor</em>) – A tensor of gradients.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The provided tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.rounding.RoundSTE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">RoundSTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#RoundSTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.RoundSTE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.rounding.IdentitySTEFunction" title="botorch.utils.rounding.IdentitySTEFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentitySTEFunction</span></code></a></p>
<p>Round the input tensor and use a straight-through gradient estimator.</p>
<p><a class="reference internal" href="#daulton2022bopr" id="id2"><span>[Daulton2022bopr]</span></a> proposes using this in acquisition optimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.rounding.RoundSTE.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#RoundSTE.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.RoundSTE.forward" title="Link to this definition"></a></dt>
<dd><p>Round the input tensor element-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – The tensor to be rounded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor where each element is rounded to the nearest integer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.rounding.OneHotArgmaxSTE">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.rounding.</span></span><span class="sig-name descname"><span class="pre">OneHotArgmaxSTE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#OneHotArgmaxSTE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.OneHotArgmaxSTE" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.rounding.IdentitySTEFunction" title="botorch.utils.rounding.IdentitySTEFunction"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentitySTEFunction</span></code></a></p>
<p>Discretize a continuous relaxation of a one-hot encoded categorical.</p>
<p>This returns a one-hot encoded categorical and use a straight-through
gradient estimator via an identity function.</p>
<p><a class="reference internal" href="#daulton2022bopr" id="id3"><span>[Daulton2022bopr]</span></a> proposes using this in acquisition optimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.rounding.OneHotArgmaxSTE.forward">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/rounding.html#OneHotArgmaxSTE.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.rounding.OneHotArgmaxSTE.forward" title="Link to this definition"></a></dt>
<dd><p>Discretize the input tensor.</p>
<p>This applies a argmax along the last dimensions of the input tensor
and one-hot encodes the result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>) – The tensor to be rounded.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor where each element is rounded to the nearest integer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.sampling">
<span id="sampling"></span><h2>Sampling<a class="headerlink" href="#module-botorch.utils.sampling" title="Link to this heading"></a></h2>
<p>Utilities for MC and qMC sampling.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="trikalinos2014polytope" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">Trikalinos2014polytope</a><span class="fn-bracket">]</span></span>
<p>T. A. Trikalinos and G. van Valkenhoef. Efficient sampling from uniform
density n-polytopes. Technical report, Brown University, 2014.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.manual_seed">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">manual_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#manual_seed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.manual_seed" title="Link to this definition"></a></dt>
<dd><p>Contextmanager for manual setting the torch.random seed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed to set the random number generator to.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generator</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Generator</em>[None, None, None]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.draw_sobol_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">draw_sobol_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#draw_sobol_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.draw_sobol_samples" title="Link to this definition"></a></dt>
<dd><p>Draw qMC samples from the box defined by bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite> dimensional tensor specifying box constraints on a
<cite>d</cite>-dimensional space, where bounds[0, :] and bounds[1, :] correspond
to lower and upper bounds, respectively.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of (q-batch) samples. As a best practice, use powers of 2.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – The size of each q-batch.</p></li>
<li><p><strong>batch_shape</strong> (<em>Iterable</em><em>[</em><em>int</em><em>] </em><em>| </em><em>Size</em><em> | </em><em>None</em>) – The batch shape of the samples. If given, returns samples
of shape <cite>n x batch_shape x q x d</cite>, where each batch is an
<cite>n x q x d</cite>-dim tensor of qMC samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed used for initializing Owen scrambling. If None (default),
use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x batch_shape x q x d</cite>-dim tensor of qMC samples from the box
defined by bounds.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">draw_sobol_samples</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.draw_sobol_normal_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">draw_sobol_normal_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#draw_sobol_normal_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.draw_sobol_normal_samples" title="Link to this definition"></a></dt>
<dd><p>Draw qMC samples from a multi-variate standard normal N(0, I_d).</p>
<p>A primary use-case for this functionality is to compute an QMC average
of f(X) over X where each element of X is drawn N(0, 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the normal distribution.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return. As a best practice, use powers of 2.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The torch dtype.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed used for initializing Owen scrambling. If None (default),
use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of qMC standard normal samples with dimension <cite>n x d</cite> with device
and dtype specified by the input.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">draw_sobol_normal_samples</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_hypersphere">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_hypersphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_hypersphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_hypersphere" title="Link to this definition"></a></dt>
<dd><p>Sample uniformly from a unit d-sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the hypersphere.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use QMC Sobol sampling (instead of i.i.d. uniform).</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The torch dtype.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An  <cite>n x d</cite> tensor of uniform samples from from the d-hypersphere.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_hypersphere</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_simplex">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_simplex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_simplex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_simplex" title="Link to this definition"></a></dt>
<dd><p>Sample uniformly from a d-simplex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the simplex.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of samples to return.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – If True, use QMC Sobol sampling (instead of i.i.d. uniform).</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – If provided, use as a seed for the RNG.</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>) – The torch device.</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>) – The torch dtype.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An <cite>n x d</cite> tensor of uniform samples from from the d-simplex.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_simplex</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_polytope">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_polytope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_polytope"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_polytope" title="Link to this definition"></a></dt>
<dd><p>Hit and run sampler from uniform sampling points from a polytope,
described via inequality constraints A*x&lt;=b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>Tensor</em>) – A <cite>m x d</cite>-dim Tensor describing inequality constraints
so that all samples satisfy <cite>Ax &lt;= b</cite>.</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim Tensor describing the inequality constraints
so that all samples satisfy <cite>Ax &lt;= b</cite>.</p></li>
<li><p><strong>x0</strong> (<em>Tensor</em>) – A <cite>d</cite>-dim Tensor representing a starting point of the chain
satisfying the constraints.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of resulting samples kept in the output.</p></li>
<li><p><strong>n0</strong> (<em>int</em>) – The number of burn-in samples. The chain will produce
n+n0 samples but the first n0 samples are not saved.</p></li>
<li><p><strong>n_thinning</strong> (<em>int</em>) – The amount of thinnning. This function will return every
<cite>n_thinning</cite>-th sample from the chain (after burn-in).</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed for the sampler. If omitted, use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(n, d) dim Tensor containing the resulting samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.batched_multinomial">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">batched_multinomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#batched_multinomial"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.batched_multinomial" title="Link to this definition"></a></dt>
<dd><p>Sample from multinomial with an arbitrary number of batch dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>Tensor</em>) – A <cite>batch_shape x num_categories</cite> tensor of weights. For each batch
index <cite>i, j, …</cite>, this functions samples from a multinomial with <cite>input</cite>
<cite>weights[i, j, …, :]</cite>. Note that the weights need not sum to one, but must
be non-negative, finite and have a non-zero sum.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples to draw for each batch index. Must be smaller
than <cite>num_categories</cite> if <cite>replacement=False</cite>.</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, samples are drawn with replacement.</p></li>
<li><p><strong>generator</strong> (<em>Generator</em><em> | </em><em>None</em>) – A a pseudorandom number generator for sampling.</p></li>
<li><p><strong>out</strong> (<em>Tensor</em><em> | </em><em>None</em>) – The output tensor (optional). If provided, must be of size
<cite>batch_shape x num_samples</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x num_samples</cite> tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>LongTensor</em></p>
</dd>
</dl>
<p>This is a thin wrapper around <cite>torch.multinomial</cite> that allows weight (<cite>input</cite>)
tensors with an arbitrary number of batch dimensions (<cite>torch.multinomial</cite> only
allows a single batch dimension). The calling signature is the same as for
<cite>torch.multinomial</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">samples</span> <span class="o">=</span> <span class="n">batched_multinomial</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># shape is 2 x 3 x 4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.find_interior_point">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">find_interior_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A_eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_eq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#find_interior_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.find_interior_point" title="Link to this definition"></a></dt>
<dd><p>Find an interior point of a polytope via linear programming.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarType_co</em><em>]</em><em>]</em>) – A <cite>n_ineq x d</cite>-dim numpy array containing the coefficients of the
constraint inequalities.</p></li>
<li><p><strong>b</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarType_co</em><em>]</em><em>]</em>) – A <cite>n_ineq x 1</cite>-dim numpy array containing the right hand sides of
the constraint inequalities.</p></li>
<li><p><strong>A_eq</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarType_co</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A <cite>n_eq x d</cite>-dim numpy array containing the coefficients of the
constraint equalities.</p></li>
<li><p><strong>b_eq</strong> (<em>ndarray</em><em>[</em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em><em>, </em><em>dtype</em><em>[</em><em>_ScalarType_co</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A <cite>n_eq x 1</cite>-dim numpy array containing the right hand sides of
the constraint equalities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>d</cite>-dim numpy array containing an interior point of the polytope.
This function will raise a ValueError if there is no such point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ndarray</em>[tuple[int, …], <em>dtype</em>[<em>_ScalarType_co</em>]]</p>
</dd>
</dl>
<p>This method solves the following Linear Program:</p>
<blockquote>
<div><p>min -s subject to A &#64; x &lt;= b - 2 * s, s &gt;= 0, A_eq &#64; x = b_eq</p>
</div></blockquote>
<p>In case the polytope is unbounded, then it will also constrain the slack
variable <cite>s</cite> to <cite>s&lt;=1</cite>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">PolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Base class for samplers that sample points from a polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A &#64; x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C &#64; x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>2 x d</cite>-dim tensor of box bounds, where <cite>inf</cite> (<cite>-inf</cite>) means
that the respective dimension is unbounded above (below).</p></li>
<li><p><strong>interior_point</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>d x 1</cite>-dim Tensor presenting a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler.feasible">
<span class="sig-name descname"><span class="pre">feasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler.feasible"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler.feasible" title="Link to this definition"></a></dt>
<dd><p>Check whether a point is contained in the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – A <cite>d x 1</cite>-dim Tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if <cite>x</cite> is contained inside the polytope (incl. its boundary),
False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler.find_interior_point">
<span class="sig-name descname"><span class="pre">find_interior_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler.find_interior_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler.find_interior_point" title="Link to this definition"></a></dt>
<dd><p>Find an interior point of the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>d x 1</cite>-dim Tensor representing a point contained in the polytope.
This function will raise a ValueError if there is no such point.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.PolytopeSampler.draw">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#PolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.PolytopeSampler.draw" title="Link to this definition"></a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.HitAndRunPolytopeSampler">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">HitAndRunPolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#HitAndRunPolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.HitAndRunPolytopeSampler" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler" title="botorch.utils.sampling.PolytopeSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></a></p>
<p>A sampler for sampling from a polyope using a hit-and-run algorithm.</p>
<p>A sampler for sampling from a polyope using a hit-and-run algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A &#64; x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C &#64; x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>2 x d</cite>-dim tensor of box bounds, where <cite>inf</cite> (<cite>-inf</cite>) means
that the respective dimension is unbounded from above (below). If
omitted, no bounds (in addition to the above constraints) are applied.</p></li>
<li><p><strong>interior_point</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>d x 1</cite>-dim Tensor representing a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
<li><p><strong>n_burnin</strong> (<em>int</em>) – The number of burn in samples. The sampler will discard
<cite>n_burnin</cite> samples before returning the first sample.</p></li>
<li><p><strong>n_thinning</strong> (<em>int</em>) – The amount of thinning. The sampler will return every
<cite>n_thinning</cite> sample (after burn-in). This may need to be increased
for sets of constraints that are difficult to satisfy (i.e. in which
case the volume of the constraint polytope is small relative to that
of its bounding box).</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The random seed.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.HitAndRunPolytopeSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#HitAndRunPolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.HitAndRunPolytopeSampler.draw" title="Link to this definition"></a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.sampling.DelaunayPolytopeSampler">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">DelaunayPolytopeSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#DelaunayPolytopeSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.DelaunayPolytopeSampler" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler" title="botorch.utils.sampling.PolytopeSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></a></p>
<p>A polytope sampler using Delaunay triangulation.</p>
<p>This sampler first enumerates the vertices of the constraint polytope and
then uses a Delaunay triangulation to tesselate its convex hull.</p>
<p>The sampling happens in two stages:
1. First, we sample from the set of hypertriangles generated by the
Delaunay triangulation (i.e. which hyper-triangle to draw the sample
from) with probabilities proportional to the triangle volumes.
2. Then, we sample uniformly from the chosen hypertriangle by sampling
uniformly from the unit simplex of the appropriate dimension, and
then computing the convex combination of the vertices of the
hypertriangle according to that draw from the simplex.</p>
<p>The best reference (not exactly the same, but functionally equivalent) is
<a class="reference internal" href="#trikalinos2014polytope" id="id4"><span>[Trikalinos2014polytope]</span></a>. A simple R implementation is available at
<a class="reference external" href="https://github.com/gertvv/tesselample">https://github.com/gertvv/tesselample</a>.</p>
<p>Initialize DelaunayPolytopeSampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(A, b)</cite> describing inequality
constraints <cite>A &#64; x &lt;= b</cite>, where <cite>A</cite> is a <cite>n_ineq_con x d</cite>-dim
Tensor and <cite>b</cite> is a <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite>
the number of inequalities and <cite>d</cite> the dimension of the sample space.</p></li>
<li><p><strong>equality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(C, d)</cite> describing the equality constraints
<cite>C &#64; x = d</cite>, where <cite>C</cite> is a <cite>n_eq_con x d</cite>-dim Tensor and <cite>d</cite> is a
<cite>n_eq_con x 1</cite>-dim Tensor with <cite>n_eq_con</cite> the number of equalities.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>2 x d</cite>-dim tensor of box bounds, where <cite>inf</cite> (<cite>-inf</cite>) means
that the respective dimension is unbounded from above (below).</p></li>
<li><p><strong>interior_point</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>d x 1</cite>-dim Tensor representing a point in the
(relative) interior of the polytope. If omitted, determined
automatically by solving a Linear Program.</p></li>
</ul>
</dd>
</dl>
<p>Warning: The vertex enumeration performed in this algorithm can become
extremely costly if there are a large number of inequalities. Similarly,
the triangulation can get very expensive in high dimensions. Only use
this algorithm for moderate dimensions / moderately complex constraint sets.
An alternative is the <cite>HitAndRunPolytopeSampler</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.sampling.DelaunayPolytopeSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#DelaunayPolytopeSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.DelaunayPolytopeSampler.draw" title="Link to this definition"></a></dt>
<dd><p>Draw samples from the polytope.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite> Tensor of samples from the polytope.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.normalize_sparse_linear_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">normalize_sparse_linear_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#normalize_sparse_linear_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.normalize_sparse_linear_constraints" title="Link to this definition"></a></dt>
<dd><p>Normalize sparse linear constraints to the unit cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the box bounds.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em>) – A list of tuples (<cite>indices</cite>, <cite>coefficients</cite>, <cite>rhs</cite>), with
<cite>indices</cite> and <cite>coefficients</cite> one-dimensional tensors and <cite>rhs</cite> a
scalar, where each tuple encodes an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite> or
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[tuple[<em>Tensor</em>, <em>Tensor</em>, float]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.normalize_dense_linear_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">normalize_dense_linear_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#normalize_dense_linear_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.normalize_dense_linear_constraints" title="Link to this definition"></a></dt>
<dd><p>Normalize dense linear constraints to the unit cube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the box bounds.</p></li>
<li><p><strong>constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>]</em>) – A tensor tuple <cite>(A, b)</cite> describing constraints
<cite>A &#64; x (&lt;)= b</cite>, where <cite>A</cite> is a <cite>n_con x d</cite>-dim Tensor and
<cite>b</cite> is a <cite>n_con x 1</cite>-dim Tensor, with <cite>n_con</cite> the number of
constraints and <cite>d</cite> the dimension of the sample space.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor tuple <cite>(A_nlz, b_nlz)</cite> of normalized constraints.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.get_polytope_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">get_polytope_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">32</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#get_polytope_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.get_polytope_samples" title="Link to this definition"></a></dt>
<dd><p>Sample from polytope defined by box bounds and (in)equality constraints.</p>
<p>This uses a hit-and-run Markov chain sampler.</p>
<p>NOTE: Much of the functionality of this method has been moved into
<cite>HitAndRunPolytopeSampler</cite>. If you want to repeatedly draw samples, you should
use <cite>HitAndRunPolytopeSampler</cite> directly in order to avoid repeatedly running
a burn-in of the chain. To do so, you need to convert the sparse constraint
format that <cite>get_polytope_samples</cite> expects to the dense constraint format that
<cite>HitAndRunPolytopeSampler</cite> expects. This can be done via the
<cite>sparse_to_dense_constraints</cite> method (but remember to adjust the constraint
from the <cite>Ax &gt;= b</cite> format expecxted here to the <cite>Ax &lt;= b</cite> format expected by
<cite>PolytopeSampler</cite> by multiplying both <cite>A</cite> and <cite>b</cite> by -1.)</p>
<p>NOTE: This method does not support the kind of “inter-point constraints” that
are supported by <cite>optimize_acqf()</cite>. To achieve this behavior, you need define the
problem on the joint space over <cite>q</cite> points and impose use constraints, see:
<a class="reference external" href="https://github.com/pytorch/botorch/issues/2468#issuecomment-2287706461">https://github.com/pytorch/botorch/issues/2468#issuecomment-2287706461</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of samples.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the box bounds.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of tuples (<cite>indices</cite>, <cite>coefficients</cite>, <cite>rhs</cite>),
with <cite>indices</cite> and <cite>coefficients</cite> one-dimensional tensors and <cite>rhs</cite> a
scalar, where each tuple encodes an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>equality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of tuples (<cite>indices</cite>, <cite>coefficients</cite>, <cite>rhs</cite>),
with <cite>indices</cite> and <cite>coefficients</cite> one-dimensional tensors and <cite>rhs</cite> a
scalar, where each tuple encodes an equality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The random seed.</p></li>
<li><p><strong>n_burnin</strong> (<em>int</em>) – The number of burn-in samples for the Markov chain sampler.</p></li>
<li><p><strong>n_thinning</strong> (<em>int</em>) – The amount of thinnning. This function will return every
<cite>n_thinning</cite>-th sample from the chain (after burn-in).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n x d</cite>-dim tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sparse_to_dense_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sparse_to_dense_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sparse_to_dense_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sparse_to_dense_constraints" title="Link to this definition"></a></dt>
<dd><p>Convert parameter constraints from a sparse format into a dense format.</p>
<p>This method converts sparse triples of the form (indices, coefficients, rhs)
to constraints of the form Ax &gt;= b or Ax = b.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – The input dimension.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>]</em>) – A list of tuples (<cite>indices</cite>, <cite>coefficients</cite>, <cite>rhs</cite>),
with <cite>indices</cite> and <cite>coefficients</cite> one-dimensional tensors and <cite>rhs</cite> a
scalar, where each tuple encodes an (in)equality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite> or
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A: A <cite>n_constraints x d</cite>-dim tensor of coefficients.</p></li>
<li><p>b: A <cite>n_constraints x 1</cite>-dim tensor of right hand sides.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A two-element tuple containing</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.optimize_posterior_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">optimize_posterior_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_restarts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_transformed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#optimize_posterior_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.optimize_posterior_samples" title="Link to this definition"></a></dt>
<dd><p>Cheaply maximizes posterior samples by random querying followed by
gradient-based optimization using SciPy’s L-BFGS-B routine.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>paths</strong> (<a class="reference internal" href="models.html#botorch.models.deterministic.GenericDeterministicModel" title="botorch.models.deterministic.GenericDeterministicModel"><em>GenericDeterministicModel</em></a>) – Random Fourier Feature-based sample paths from the GP</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – The bounds on the search space.</p></li>
<li><p><strong>raw_samples</strong> (<em>int</em>) – The number of samples with which to query the samples initially.</p></li>
<li><p><strong>num_restarts</strong> (<em>int</em>) – The number of points selected for gradient-based optimization.</p></li>
<li><p><strong>sample_transform</strong> (<em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – A callable transform of the sample outputs (e.g.
MCAcquisitionObjective or ScalarizedPosteriorTransform.evaluate) used to
negate the objective or otherwise transform the output.</p></li>
<li><p><strong>return_transformed</strong> (<em>bool</em>) – A boolean indicating whether to return the transformed
or non-transformed samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>X_opt: A <cite>num_optima x [batch_size] x d</cite>-dim tensor of optimal inputs x*.</p></li>
<li><dl class="simple">
<dt>f_opt: A <cite>num_optima x [batch_size] x m</cite>-dim, optionally</dt><dd><p><cite>num_optima x [batch_size] x 1</cite>-dim,  tensor of optimal outputs f*.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A two-element tuple containing</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.boltzmann_sample">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">boltzmann_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_decrease</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#boltzmann_sample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.boltzmann_sample" title="Link to this definition"></a></dt>
<dd><p>Perform Boltzmann sampling from a set of function values, weighted by the
exponentiated difference between function values and their standardized mean.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function_values</strong> (<em>Tensor</em>) – A [batch_shape] x N  tensor of function values.</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – The number of samples (restarts) to draw.</p></li>
<li><p><strong>eta</strong> (<em>float</em>) – The Boltzmann temperature, controls the sharpness of the weighting. If the
temperature is too high, causing NaN values, the eta parameter is
succesively decreased by ‘temp_decrease’.</p></li>
<li><p><strong>replacement</strong> (<em>bool</em>) – If True, samples are drawn with replacement, allowing duplicates.</p></li>
<li><p><strong>temp_decrease</strong> (<em>float</em>) – The rate at which temperature decreases in case of inf weights.</p></li>
<li><p><strong>Returns</strong></p></li>
<li><p><strong>positions.</strong> (<em>A</em><em> [</em><em>batch_shape</em><em>] </em><em>x num_samples tensor</em><em> of </em><em>indices</em><em> of </em><em>sampled</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_truncated_normal_perturbations">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_truncated_normal_perturbations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_discrete_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_truncated_normal_perturbations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_truncated_normal_perturbations" title="Link to this definition"></a></dt>
<dd><p>Sample points around <cite>X</cite>.</p>
<p>Sample perturbed points around <cite>X</cite> such that the added perturbations
are sampled from N(0, sigma^2 I) and truncated to be within [0,1]^d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>n x d</cite>-dim tensor starting points.</p></li>
<li><p><strong>n_discrete_points</strong> (<em>int</em>) – The number of points to sample.</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – The standard deviation of the additive gaussian noise for
perturbing the points.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite>-dim tensor containing the bounds.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – A boolean indicating whether to use qmc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_discrete_points x d</cite>-dim tensor containing the sampled points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.sampling.sample_perturbed_subset_dims">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.sampling.</span></span><span class="sig-name descname"><span class="pre">sample_perturbed_subset_dims</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_discrete_points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qmc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_perturb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/sampling.html#sample_perturbed_subset_dims"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.sampling.sample_perturbed_subset_dims" title="Link to this definition"></a></dt>
<dd><p>Sample around <cite>X</cite> by perturbing a subset of the dimensions.</p>
<p>By default, dimensions are perturbed with probability equal to
<cite>min(20 / d, 1)</cite>. As shown in <a class="reference internal" href="optim.html#regis" id="id5"><span>[Regis]</span></a>, perturbing a small number
of dimensions can be beneificial. The perturbations are sampled
from N(0, sigma^2 I) and truncated to be within [0,1]^d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>n x d</cite>-dim tensor starting points. <cite>X</cite>
must be normalized to be within <cite>[0, 1]^d</cite>.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – The bounds to sample perturbed values from</p></li>
<li><p><strong>n_discrete_points</strong> (<em>int</em>) – The number of points to sample.</p></li>
<li><p><strong>sigma</strong> (<em>float</em>) – The standard deviation of the additive gaussian noise for
perturbing the points.</p></li>
<li><p><strong>qmc</strong> (<em>bool</em>) – A boolean indicating whether to use qmc.</p></li>
<li><p><strong>prob_perturb</strong> (<em>float</em><em> | </em><em>None</em>) – The probability of perturbing each dimension. If omitted,
defaults to <cite>min(20 / d, 1)</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>n_discrete_points x d</cite>-dim tensor containing the sampled points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.testing">
<span id="testing"></span><h2>Testing<a class="headerlink" href="#module-botorch.utils.testing" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">BotorchTestCase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TestCase</span></code></p>
<p>Basic test case for Botorch.</p>
<dl class="simple">
<dt>This</dt><dd><ol class="arabic simple">
<li><p>sets the default device to be <cite>torch.device(“cpu”)</cite></p></li>
<li><p>ensures that no warnings are suppressed by default.</p></li>
</ol>
</dd>
</dl>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.device">
<span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">device(type='cpu')</span></em><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.device" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.setUp">
<span class="sig-name descname"><span class="pre">setUp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suppress_input_warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase.setUp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.setUp" title="Link to this definition"></a></dt>
<dd><p>Set up the test case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>suppress_input_warnings</strong> (<em>bool</em>) – If True, suppress common input warnings
(see below).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BotorchTestCase.assertAllClose">
<span class="sig-name descname"><span class="pre">assertAllClose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equal_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BotorchTestCase.assertAllClose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BotorchTestCase.assertAllClose" title="Link to this definition"></a></dt>
<dd><p>Assert that two tensors are close.</p>
<p>Calls torch.testing.assert_close, using the signature and default behavior
of torch.allclose.</p>
<p>The formula asserted is abs(input - other) &lt;= atol + rtol * abs(other).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input</strong> (<em>Any</em>) – First tensor or tensor-or-scalar-like to compare</p></li>
<li><p><strong>other</strong> (<em>Any</em>) – Second tensor or tensor-or-scalar-like to compare</p></li>
<li><p><strong>rtol</strong> (<em>float</em>) – Relative tolerance</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – Absolute tolerance</p></li>
<li><p><strong>equal_nan</strong> (<em>bool</em>) – If True, consider NaN values as equal</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
<dl>
<dt>Example output:</dt><dd><p>AssertionError: Scalars are not close!</p>
<p>Absolute difference: 1.0000034868717194 (up to 0.0001 allowed)
Relative difference: 0.8348668001940709 (up to 1e-05 allowed)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemTestCaseMixIn">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">BaseTestProblemTestCaseMixIn</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#BaseTestProblemTestCaseMixIn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin for testing BaseTestProblem (functions) implementations.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemTestCaseMixIn.test_forward_and_evaluate_true">
<span class="sig-name descname"><span class="pre">test_forward_and_evaluate_true</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#BaseTestProblemTestCaseMixIn.test_forward_and_evaluate_true"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn.test_forward_and_evaluate_true" title="Link to this definition"></a></dt>
<dd><p>Run every BaseTestProblem in <cite>self.functions</cite> on random inputs.
Runs both <cite>forward</cite> and <cite>evaluate_true</cite>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.BaseTestProblemTestCaseMixIn.functions">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.BaseTestProblemTestCaseMixIn.functions" title="Link to this definition"></a></dt>
<dd><p>The functions that should be tested.</p>
<p>Typically defined as a class attribute on the test case subclassing this class.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">SyntheticTestFunctionTestCaseMixin</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionTestCaseMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin for testing synthetic <cite>BaseTestProblem</cite> aka test functions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimal_value">
<span class="sig-name descname"><span class="pre">test_optimal_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionTestCaseMixin.test_optimal_value"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimal_value" title="Link to this definition"></a></dt>
<dd><p>Test that a function’s optimal_value is correctly computed,
and defined if it should be.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimizer">
<span class="sig-name descname"><span class="pre">test_optimizer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#SyntheticTestFunctionTestCaseMixin.test_optimizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.test_optimizer" title="Link to this definition"></a></dt>
<dd><p>Test that optimizers are correctly computed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.functions">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.SyntheticTestFunctionTestCaseMixin.functions" title="Link to this definition"></a></dt>
<dd><p>The functions that should be tested.</p>
<p>Typically defined as a class attribute on the test case subclassing this class.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MultiObjectiveTestProblemTestCaseMixin</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin for testing multi-objective test problems.</p>
<p>This class provides test cases for attributes,
maximum hypervolume, and reference points
of multi-objective test problems.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_attributes">
<span class="sig-name descname"><span class="pre">test_attributes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin.test_attributes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_attributes" title="Link to this definition"></a></dt>
<dd><p>Test that each function has the required attributes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_max_hv">
<span class="sig-name descname"><span class="pre">test_max_hv</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin.test_max_hv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_max_hv" title="Link to this definition"></a></dt>
<dd><p>Test the maximum hypervolume (max_hv) attribute for each function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_ref_point">
<span class="sig-name descname"><span class="pre">test_ref_point</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MultiObjectiveTestProblemTestCaseMixin.test_ref_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.test_ref_point" title="Link to this definition"></a></dt>
<dd><p>Test the reference point (ref_point) attribute
for each function (for each dtype).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.functions">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.MultiObjectiveTestProblemTestCaseMixin.functions" title="Link to this definition"></a></dt>
<dd><p>The functions that should be tested.</p>
<p>Typically defined as a class attribute on the test case subclassing this class.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">ConstrainedTestProblemTestCaseMixin</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedTestProblemTestCaseMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mixin for testing constrained test problems.</p>
<p>This class provides test cases for attributes and methods
of constrained test problems, including testing the number of
constraints and the evaluation of constraint slack.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_num_constraints">
<span class="sig-name descname"><span class="pre">test_num_constraints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedTestProblemTestCaseMixin.test_num_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_num_constraints" title="Link to this definition"></a></dt>
<dd><p>Test that each function has the required num_constraints attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_evaluate_slack">
<span class="sig-name descname"><span class="pre">test_evaluate_slack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#ConstrainedTestProblemTestCaseMixin.test_evaluate_slack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.test_evaluate_slack" title="Link to this definition"></a></dt>
<dd><p>Test the evaluate_slack method for each function.</p>
<p>This test verifies that:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>The evaluate_slack_true and evaluate_slack methods</dt><dd><p>return tensors of the expected shape</p>
</dd>
</dl>
</li>
</ol>
<p>2. The relationship between evaluate_slack and evaluate_slack_true
is consistent with the constraint_noise_std attribute of the function</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.functions">
<em class="property"><span class="k"><span class="pre">abstract</span></span><span class="w"> </span><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">functions</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="test_functions.html#botorch.test_functions.base.BaseTestProblem" title="botorch.test_functions.base.BaseTestProblem"><span class="pre">BaseTestProblem</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.ConstrainedTestProblemTestCaseMixin.functions" title="Link to this definition"></a></dt>
<dd><p>The functions that should be tested.</p>
<p>Typically defined as a class attribute on the test case subclassing this class.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.TestCorruptedProblemsMixin">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">TestCorruptedProblemsMixin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#TestCorruptedProblemsMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.TestCorruptedProblemsMixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.testing.BotorchTestCase" title="botorch.utils.testing.BotorchTestCase"><code class="xref py py-class docutils literal notranslate"><span class="pre">BotorchTestCase</span></code></a></p>
<p>Mixin for testing corrupted test problems.</p>
<p>This class provides setup and utility functions
for testing corrupted test problems using a specified outlier generator
and a Rosenbrock problem.</p>
<p>Create an instance of the class that will use the named test
method when executed. Raises a ValueError if the instance does
not have a method with the specified name.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.TestCorruptedProblemsMixin.setUp">
<span class="sig-name descname"><span class="pre">setUp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suppress_input_warnings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#TestCorruptedProblemsMixin.setUp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.TestCorruptedProblemsMixin.setUp" title="Link to this definition"></a></dt>
<dd><p>Set up the test case with a dummy outlier generator
and a Rosenbrock problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>suppress_input_warnings</strong> (<em>bool</em>) – If True, suppress common input warnings.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockPosterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="posteriors.html#botorch.posteriors.posterior.Posterior" title="botorch.posteriors.posterior.Posterior"><code class="xref py py-class docutils literal notranslate"><span class="pre">Posterior</span></code></a></p>
<p>This class is used to simulate a posterior with specified mean,
variance, and samples.</p>
<p>Everything is deterministic in this class.</p>
<p>Initialize the MockPosterior with specified attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mean</strong> (<em>torch.Tensor</em><em> | </em><em>None</em>) – The mean of the posterior.</p></li>
<li><p><strong>variance</strong> (<em>torch.Tensor</em><em> | </em><em>None</em>) – The variance of the posterior.</p></li>
<li><p><strong>samples</strong> (<em>torch.Tensor</em><em> | </em><em>None</em>) – Samples to return from <cite>rsample</cite>,
unless <cite>base_samples</cite> is provided.</p></li>
<li><p><strong>base_shape</strong> (<em>torch.Size</em><em> | </em><em>None</em>) – If given, this is returned as <cite>base_sample_shape</cite>,
and also used as the base of the <cite>_extended_shape</cite>.</p></li>
<li><p><strong>batch_range</strong> (<em>tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>] </em><em>| </em><em>None</em>) – If given, this is returned as <cite>batch_range</cite>.
Defaults to (0, -2).</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.device">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">device</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.device" title="Link to this definition"></a></dt>
<dd><p>Return the device of the posterior.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.dtype">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.dtype" title="Link to this definition"></a></dt>
<dd><p>Return the data type of the posterior.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.batch_shape">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.batch_shape" title="Link to this definition"></a></dt>
<dd><p>Return the batch shape of the posterior.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.base_sample_shape">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">base_sample_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.base_sample_shape" title="Link to this definition"></a></dt>
<dd><p>Return the base sample shape of the posterior.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.batch_range">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_range</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.testing.MockPosterior.batch_range" title="Link to this definition"></a></dt>
<dd><p>Return the batch range of the posterior.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.mean">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mean</span></span><a class="headerlink" href="#botorch.utils.testing.MockPosterior.mean" title="Link to this definition"></a></dt>
<dd><p>Return the mean of the posterior.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.variance">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">variance</span></span><a class="headerlink" href="#botorch.utils.testing.MockPosterior.variance" title="Link to this definition"></a></dt>
<dd><p>Return the variance of the posterior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior.rsample" title="Link to this definition"></a></dt>
<dd><p>Return mock samples by extending the shape
of the initially specified samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sample_shape</strong> (<em>Size</em><em> | </em><em>None</em>) – The shape of the samples to generate.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of samples with the specified shape.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockPosterior.rsample_from_base_samples">
<span class="sig-name descname"><span class="pre">rsample_from_base_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_samples</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockPosterior.rsample_from_base_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockPosterior.rsample_from_base_samples" title="Link to this definition"></a></dt>
<dd><p>Sample from the posterior (with gradients) using base samples.</p>
<p>This is intended to be used with a sampler that produces the corresponding base
samples, and enables acquisition optimization via Sample Average Approximation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_shape</strong> (<em>Size</em>) – A <cite>torch.Size</cite> object specifying the sample shape. To
draw <cite>n</cite> samples, set to <cite>torch.Size([n])</cite>. To draw <cite>b</cite> batches
of <cite>n</cite> samples each, set to <cite>torch.Size([b, n])</cite>.</p></li>
<li><p><strong>base_samples</strong> (<em>Tensor</em>) – The base samples, obtained from the appropriate sampler.
This is a tensor of shape <cite>sample_shape x base_sample_shape</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Samples from the posterior, a tensor of shape
<cite>self._extended_shape(sample_shape=sample_shape)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.testing.get_sampler_mock">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">get_sampler_mock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#get_sampler_mock"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.get_sampler_mock" title="Link to this definition"></a></dt>
<dd><p>Get a <cite>StochasticSampler</cite> with the specified <cite>sample_shape</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posterior</strong> (<a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior"><em>MockPosterior</em></a>) – Used only for dispatching so that <cite>get_sampler</cite>
works with a <cite>MockPosterior</cite>.</p></li>
<li><p><strong>sample_shape</strong> (<em>Size</em>) – The shape of the samples to generate.</p></li>
<li><p><strong>kwargs</strong> (<em>Any</em>) – Passed to <cite>StochasticSampler</cite></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>StochasticSampler</cite> for the mock posterior.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="sampling.html#botorch.sampling.base.MCSampler" title="botorch.sampling.base.MCSampler"><em>MCSampler</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, <a class="reference internal" href="models.html#botorch.models.model.FantasizeMixin" title="botorch.models.model.FantasizeMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">FantasizeMixin</span></code></a></p>
<p>Mock <code class="docutils literal notranslate"><span class="pre">Model</span></code> that implements dummy methods and feeds through specified outputs.</p>
<p>Its <code class="docutils literal notranslate"><span class="pre">posterior</span></code> is a <code class="docutils literal notranslate"><span class="pre">MockPosterior</span></code>.</p>
<p>Initialize the MockModel with a specified posterior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>posterior</strong> (<a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior"><em>MockPosterior</em></a>) – The mock posterior to use for the model.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.posterior">
<span class="sig-name descname"><span class="pre">posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">posterior_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observation_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.posterior" title="Link to this definition"></a></dt>
<dd><p>Return the posterior of the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – Ignored; present for compatibility with super class.</p></li>
<li><p><strong>output_indices</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em>) – Ignored; present for compatibility with super class.</p></li>
<li><p><strong>posterior_transform</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.objective.PosteriorTransform" title="botorch.acquisition.objective.PosteriorTransform"><em>PosteriorTransform</em></a><em> | </em><em>None</em>) – Optional.</p></li>
<li><p><strong>observation_noise</strong> (<em>bool</em><em> | </em><em>Tensor</em>) – Ignored; present for compatibility with super class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The posterior of the model, possibly transformed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.testing.MockPosterior" title="botorch.utils.testing.MockPosterior"><em>MockPosterior</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.num_outputs">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_outputs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.num_outputs" title="Link to this definition"></a></dt>
<dd><p>Return the number of outputs of the model.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.batch_shape">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">batch_shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Size</span></em><a class="headerlink" href="#botorch.utils.testing.MockModel.batch_shape" title="Link to this definition"></a></dt>
<dd><p>Return the batch shape of the model.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.state_dict">
<span class="sig-name descname"><span class="pre">state_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.state_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.state_dict" title="Link to this definition"></a></dt>
<dd><p>Dummy method, has no effect</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockModel.load_state_dict">
<span class="sig-name descname"><span class="pre">load_state_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockModel.load_state_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockModel.load_state_dict" title="Link to this definition"></a></dt>
<dd><p>Dummy method, has no effect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_dict</strong> (<em>OrderedDict</em><em> | </em><em>None</em>) – The state dictionary to load.</p></li>
<li><p><strong>strict</strong> (<em>bool</em>) – Whether to strictly enforce that the keys in state_dict match
the keys returned by this module’s state_dict function.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.testing.MockAcquisitionFunction">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">MockAcquisitionFunction</span></span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockAcquisitionFunction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockAcquisitionFunction" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Mock acquisition function object that implements dummy methods.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.testing.MockAcquisitionFunction.set_X_pending">
<span class="sig-name descname"><span class="pre">set_X_pending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_pending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#MockAcquisitionFunction.set_X_pending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.MockAcquisitionFunction.set_X_pending" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X_pending</strong> (<em>Tensor</em><em> | </em><em>None</em>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.testing.get_random_data">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">get_random_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#get_random_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.get_random_data" title="Link to this definition"></a></dt>
<dd><p>Generate random data for testing purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>Size</em>) – The batch shape of the data.</p></li>
<li><p><strong>m</strong> (<em>int</em>) – The number of outputs.</p></li>
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the input.</p></li>
<li><p><strong>n</strong> (<em>int</em>) – The number of data points.</p></li>
<li><p><strong>tkwargs</strong> – <cite>device</cite> and <cite>dtype</cite> tensor constructor kwargs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple <cite>(train_X, train_Y)</cite> with randomly generated training data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.testing.get_test_posterior">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">get_test_posterior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interleaved</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">independent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#get_test_posterior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.get_test_posterior" title="Link to this definition"></a></dt>
<dd><p>Generate a Posterior for testing purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>Size</em>) – The batch shape of the data.</p></li>
<li><p><strong>q</strong> (<em>int</em>) – The number of candidates</p></li>
<li><p><strong>m</strong> (<em>int</em>) – The number of outputs.</p></li>
<li><p><strong>interleaved</strong> (<em>bool</em>) – A boolean indicating the format of the
MultitaskMultivariateNormal</p></li>
<li><p><strong>lazy</strong> (<em>bool</em>) – A boolean indicating if the posterior should be lazy</p></li>
<li><p><strong>independent</strong> (<em>bool</em>) – A boolean indicating whether the outputs are independent</p></li>
<li><p><strong>tkwargs</strong> – <cite>device</cite> and <cite>dtype</cite> tensor constructor kwargs.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="posteriors.html#botorch.posteriors.gpytorch.GPyTorchPosterior" title="botorch.posteriors.gpytorch.GPyTorchPosterior"><em>GPyTorchPosterior</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.testing.get_max_violation_of_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">get_max_violation_of_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#get_max_violation_of_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.get_max_violation_of_bounds" title="Link to this definition"></a></dt>
<dd><p>The maximum value by which samples lie outside bounds.</p>
<p>A negative value indicates that all samples lie within bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>Tensor</em>) – An <cite>n x q x d</cite> - dimension tensor, as might be returned from
<cite>sample_q_batches_from_polytope</cite>.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite> tensor of lower and upper bounds for each column.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.testing.get_max_violation_of_constraints">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.testing.</span></span><span class="sig-name descname"><span class="pre">get_max_violation_of_constraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">equality</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/testing.html#get_max_violation_of_constraints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.testing.get_max_violation_of_constraints" title="Link to this definition"></a></dt>
<dd><p>Amount by which equality constraints are not obeyed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>Tensor</em>) – An <cite>n x q x d</cite> - dimension tensor, as might be returned from
<cite>sample_q_batches_from_polytope</cite>.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) = rhs</cite>, or <cite>&gt;=</cite> if
<cite>equality</cite> is False.</p></li>
<li><p><strong>equality</strong> (<em>bool</em>) – Whether these are equality constraints (not inequality).</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.test_helpers">
<span id="test-helpers"></span><h2>Test Helpers<a class="headerlink" href="#module-botorch.utils.test_helpers" title="Link to this heading"></a></h2>
<p>Dummy classes and other helpers that are used in multiple test files
should be defined here to avoid relative imports.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.get_model">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">get_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_model_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#get_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.get_model" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_X</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>train_Y</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>standardize_model</strong> (<em>bool</em>)</p></li>
<li><p><strong>use_model_list</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="models.html#botorch.models.gp_regression.SingleTaskGP" title="botorch.models.gp_regression.SingleTaskGP"><em>SingleTaskGP</em></a> | <a class="reference internal" href="models.html#botorch.models.model_list_gp_regression.ModelListGP" title="botorch.models.model_list_gp_regression.ModelListGP"><em>ModelListGP</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.get_fully_bayesian_model">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">get_fully_bayesian_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_models</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_noise</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#get_fully_bayesian_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.get_fully_bayesian_model" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_X</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>train_Y</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>num_models</strong> (<em>int</em>)</p></li>
<li><p><strong>standardize_model</strong> (<em>bool</em>)</p></li>
<li><p><strong>infer_noise</strong> (<em>bool</em>)</p></li>
<li><p><strong>tkwargs</strong> (<em>Any</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="models.html#botorch.models.fully_bayesian.SaasFullyBayesianSingleTaskGP" title="botorch.models.fully_bayesian.SaasFullyBayesianSingleTaskGP"><em>SaasFullyBayesianSingleTaskGP</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.get_fully_bayesian_model_list">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">get_fully_bayesian_model_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_models</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">standardize_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infer_noise</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#get_fully_bayesian_model_list"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.get_fully_bayesian_model_list" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_X</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>train_Y</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>num_models</strong> (<em>int</em>)</p></li>
<li><p><strong>standardize_model</strong> (<em>bool</em>)</p></li>
<li><p><strong>infer_noise</strong> (<em>bool</em>)</p></li>
<li><p><strong>tkwargs</strong> (<em>Any</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="models.html#botorch.models.model_list_gp_regression.ModelListGP" title="botorch.models.model_list_gp_regression.ModelListGP"><em>ModelListGP</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.get_sample_moments">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">get_sample_moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#get_sample_moments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.get_sample_moments" title="Link to this definition"></a></dt>
<dd><p>Computes the mean and covariance of a set of samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>Tensor</em>) – A tensor of shape <cite>sample_shape x batch_shape x q</cite>.</p></li>
<li><p><strong>sample_shape</strong> (<em>Size</em>) – The sample_shape input used while generating the samples using
the pathwise sampling API.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.standardize_moments">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">standardize_moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#standardize_moments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.standardize_moments" title="Link to this definition"></a></dt>
<dd><p>Standardizes the loc and covariance_matrix using the mean and standard
deviations from a Standardize transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transform</strong> (<a class="reference internal" href="models.html#botorch.models.transforms.outcome.Standardize" title="botorch.models.transforms.outcome.Standardize"><em>Standardize</em></a>)</p></li>
<li><p><strong>loc</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.gen_multi_task_dataset">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">gen_multi_task_dataset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yvar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_task_features_in_datasets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#gen_multi_task_dataset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.gen_multi_task_dataset" title="Link to this definition"></a></dt>
<dd><p>Constructs a multi-task dataset with two tasks, each with 10 data points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>yvar</strong> (<em>float</em><em> | </em><em>None</em>) – The noise level to use for <cite>train_Yvar</cite>. If None, uses <cite>train_Yvar=None</cite>.</p></li>
<li><p><strong>task_values</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em>) – The values of the task features. If None, uses [0, 1].</p></li>
<li><p><strong>skip_task_features_in_datasets</strong> (<em>bool</em>) – If True, the task features are not included in
Xs of the datasets used to construct the datasets. This is useful for
testing <cite>MultiTaskDataset</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#botorch.utils.datasets.MultiTaskDataset" title="botorch.utils.datasets.MultiTaskDataset"><em>MultiTaskDataset</em></a>, tuple[<em>Tensor</em>, <em>Tensor</em>, <em>Tensor</em> | None]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.get_pvar_expected">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">get_pvar_expected</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#get_pvar_expected"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.get_pvar_expected" title="Link to this definition"></a></dt>
<dd><p>Computes the expected variance of a posterior after adding the
predictive noise from the likelihood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>posterior</strong> (<a class="reference internal" href="posteriors.html#botorch.posteriors.torch.TorchPosterior" title="botorch.posteriors.torch.TorchPosterior"><em>TorchPosterior</em></a>) – The posterior to compute the variance of. Must be a
<cite>TorchPosterior</cite> object.</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The model that generated the posterior. If <cite>m &gt; 1</cite>, this must be
a <cite>BatchedMultiOutputGPyTorchModel</cite>.</p></li>
<li><p><strong>X</strong> (<em>Tensor</em>) – The test inputs.</p></li>
<li><p><strong>m</strong> (<em>int</em>) – The number of outputs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The expected variance of the posterior after adding the observation
noise from the likelihood.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">DummyNonScalarizingPosteriorTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#DummyNonScalarizingPosteriorTransform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="acquisition.html#botorch.acquisition.objective.PosteriorTransform" title="botorch.acquisition.objective.PosteriorTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">PosteriorTransform</span></code></a></p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p>
<dl class="field-list simple">
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.scalarize">
<span class="sig-name descname"><span class="pre">scalarize</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.scalarize" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#DummyNonScalarizingPosteriorTransform.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.evaluate" title="Link to this definition"></a></dt>
<dd><p>Evaluate the transform on a set of outcomes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> – A <cite>batch_shape x q x m</cite>-dim tensor of outcomes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape x q’ [x m’]</cite>-dim tensor of transformed outcomes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">posterior</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#DummyNonScalarizingPosteriorTransform.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.DummyNonScalarizingPosteriorTransform.forward" title="Link to this definition"></a></dt>
<dd><p>Compute the transformed posterior.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>posterior</strong> – The posterior to be transformed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The transformed posterior object.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.SimpleGPyTorchModel">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.test_helpers.</span></span><span class="sig-name descname"><span class="pre">SimpleGPyTorchModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#SimpleGPyTorchModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.SimpleGPyTorchModel" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="models.html#botorch.models.gpytorch.GPyTorchModel" title="botorch.models.gpytorch.GPyTorchModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">GPyTorchModel</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ExactGP</span></code>, <a class="reference internal" href="models.html#botorch.models.model.FantasizeMixin" title="botorch.models.model.FantasizeMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">FantasizeMixin</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_X</strong> – A tensor of inputs, passed to self.transform_inputs.</p></li>
<li><p><strong>train_Y</strong> – Passed to outcome_transform.</p></li>
<li><p><strong>outcome_transform</strong> – Transform applied to train_Y.</p></li>
<li><p><strong>input_transform</strong> – A Module that performs the input transformation, passed to
self.transform_inputs.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.SimpleGPyTorchModel.last_fantasize_flag">
<span class="sig-name descname"><span class="pre">last_fantasize_flag</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#botorch.utils.test_helpers.SimpleGPyTorchModel.last_fantasize_flag" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.test_helpers.SimpleGPyTorchModel.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/test_helpers.html#SimpleGPyTorchModel.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.test_helpers.SimpleGPyTorchModel.forward" title="Link to this definition"></a></dt>
<dd><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.torch">
<span id="torch"></span><h2>Torch<a class="headerlink" href="#module-botorch.utils.torch" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.torch.</span></span><span class="sig-name descname"><span class="pre">BufferDict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>Holds buffers in a dictionary.</p>
<p>BufferDict can be indexed like a regular Python dictionary, but buffers it
contains are properly registered, and will be visible by all Module methods.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> is an <strong>ordered</strong> dictionary that respects</p>
<ul class="simple">
<li><p>the order of insertion, and</p></li>
<li><p>in <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>, the order of the merged <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>
or another <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> (the argument to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code>).</p></li>
</ul>
<p>Note that <code class="xref py py-meth docutils literal notranslate"><span class="pre">update()</span></code> with other unordered mapping
types (e.g., Python’s plain <code class="docutils literal notranslate"><span class="pre">dict</span></code>) does not preserve the order of the
merged mapping.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffers</strong> (<em>iterable</em><em>, </em><em>optional</em>) – a mapping (dictionary) of
(string : <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>) or an iterable of key-value pairs
of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyModule</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyModule</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">({</span>
                <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
                <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="p">})</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffers</strong> – A mapping (dictionary) from string to <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, or
an iterable of key-value pairs of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.clear" title="Link to this definition"></a></dt>
<dd><p>Remove all items from the BufferDict.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.pop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.pop" title="Link to this definition"></a></dt>
<dd><p>Remove key from the BufferDict and return its buffer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>key</strong> (<em>string</em>) – key to pop from the BufferDict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.keys"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.keys" title="Link to this definition"></a></dt>
<dd><p>Return an iterable of the BufferDict keys.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.items">
<span class="sig-name descname"><span class="pre">items</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.items"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.items" title="Link to this definition"></a></dt>
<dd><p>Return an iterable of the BufferDict key/value pairs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.values"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.values" title="Link to this definition"></a></dt>
<dd><p>Return an iterable of the BufferDict values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffers</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.update" title="Link to this definition"></a></dt>
<dd><p>Update the <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code> with the key-value pairs from a
mapping or an iterable, overwriting existing keys.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="xref py py-attr docutils literal notranslate"><span class="pre">buffers</span></code> is an <code class="docutils literal notranslate"><span class="pre">OrderedDict</span></code>, a <code class="xref py py-class docutils literal notranslate"><span class="pre">BufferDict</span></code>,
or an iterable of key-value pairs, the order of new elements in it is
preserved.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>buffers</strong> (<em>iterable</em>) – a mapping (dictionary) from string to
<code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>, or an iterable of
key-value pairs of type (string, <code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.torch.BufferDict.extra_repr">
<span class="sig-name descname"><span class="pre">extra_repr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/torch.html#BufferDict.extra_repr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.torch.BufferDict.extra_repr" title="Link to this definition"></a></dt>
<dd><p>Return the extra representation of the module.</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.transforms">
<span id="transformations"></span><h2>Transformations<a class="headerlink" href="#module-botorch.utils.transforms" title="Link to this heading"></a></h2>
<p>Some basic data transformation helpers.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.standardize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">standardize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#standardize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.standardize" title="Link to this definition"></a></dt>
<dd><p>Standardizes (zero mean, unit variance) a tensor by dim=-2.</p>
<p>If the tensor is single-dimensional, simply standardizes the tensor.
If for some batch index all elements are equal (or if there is only a single
data point), this function will return 0 for that batch index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>batch_shape x n x m</cite>-dim tensor.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The standardized <cite>Y</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y_standardized</span> <span class="o">=</span> <span class="n">standardize</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.normalize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_constant_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#normalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.normalize" title="Link to this definition"></a></dt>
<dd><p>Min-max normalize X w.r.t. the provided bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – <cite>… x d</cite> tensor of data</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – <cite>2 x d</cite> tensor of lower and upper bounds for each of the X’s d
columns.</p></li>
<li><p><strong>update_constant_bounds</strong> (<em>bool</em>) – If <cite>True</cite>, update the constant bounds in order to
avoid division by zero issues. When the upper and lower bounds are
identical for a dimension, that dimension will not be scaled. Such
dimensions will only be shifted as
<cite>new_X[…, i] = X[…, i] - bounds[0, i]</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>… x d</cite>-dim tensor of normalized data, given by</dt><dd><p><cite>(X - bounds[0]) / (bounds[1] - bounds[0])</cite>. If all elements of <cite>X</cite>
are contained within <cite>bounds</cite>, the normalized values will be
contained within <cite>[0, 1]^d</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.unnormalize">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">unnormalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_constant_bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#unnormalize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.unnormalize" title="Link to this definition"></a></dt>
<dd><p>Un-normalizes X w.r.t. the provided bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – <cite>… x d</cite> tensor of data</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – <cite>2 x d</cite> tensor of lower and upper bounds for each of the X’s d
columns.</p></li>
<li><p><strong>update_constant_bounds</strong> (<em>bool</em>) – If <cite>True</cite>, update the constant bounds in order to
avoid division by zero issues. When the upper and lower bounds are
identical for a dimension, that dimension will not be scaled. Such
dimensions will only be shifted as
<cite>new_X[…, i] = X[…, i] + bounds[0, i]</cite>. This is the inverse of
the behavior of <cite>normalize</cite> when <cite>update_constant_bounds=True</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>… x d</cite>-dim tensor of unnormalized data, given by</dt><dd><p><cite>X * (bounds[1] - bounds[0]) + bounds[0]</cite>. If all elements of <cite>X</cite>
are contained in <cite>[0, 1]^d</cite>, the un-normalized values will be
contained within <cite>bounds</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_normalized</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">unnormalize</span><span class="p">(</span><span class="n">X_normalized</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.normalize_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">normalize_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#normalize_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.normalize_indices" title="Link to this definition"></a></dt>
<dd><p>Normalize a list of indices to ensure that they are positive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indices</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em>) – A list of indices (may contain negative indices for indexing
“from the back”).</p></li>
<li><p><strong>d</strong> (<em>int</em>) – The dimension of the tensor to index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A normalized list of indices such that each index is between <cite>0</cite> and
<cite>d-1</cite>, or None if indices is None.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[int] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.is_fully_bayesian">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">is_fully_bayesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#is_fully_bayesian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.is_fully_bayesian" title="Link to this definition"></a></dt>
<dd><p>Check if at least one model is a fully Bayesian model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – A BoTorch model (may be a <cite>ModelList</cite> or <cite>ModelListGP</cite>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if at least one model is a fully Bayesian model.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.is_ensemble">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">is_ensemble</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#is_ensemble"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.is_ensemble" title="Link to this definition"></a></dt>
<dd><p>Check if at least one model is an ensemble model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – A BoTorch model (may be a <cite>ModelList</cite> or <cite>ModelListGP</cite>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if at least one model is an ensemble model.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.t_batch_mode_transform">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">t_batch_mode_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expected_q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assert_output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#t_batch_mode_transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.t_batch_mode_transform" title="Link to this definition"></a></dt>
<dd><p>Factory for decorators enabling consistent t-batch behavior.</p>
<p>This method creates decorators for instance methods to transform an input tensor
<cite>X</cite> to t-batch mode (i.e. with at least 3 dimensions). This assumes the tensor
has a q-batch dimension. The decorator also checks the q-batch size if <cite>expected_q</cite>
is provided, and the output shape if <cite>assert_output_shape</cite> is <cite>True</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expected_q</strong> (<em>int</em><em> | </em><em>None</em>) – The expected q-batch size of <cite>X</cite>. If specified, this will raise an
AssertionError if <cite>X</cite>’s q-batch size does not equal expected_q.</p></li>
<li><p><strong>assert_output_shape</strong> (<em>bool</em>) – If <cite>True</cite>, this will raise an AssertionError if the
output shape does not match either the t-batch shape of <cite>X</cite>,
or the <cite>acqf.model.batch_shape</cite> for acquisition functions using
batched models.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decorated instance method.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Callable[[Callable[[<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction">AcquisitionFunction</a>, Any], Any]], Callable[[<a class="reference internal" href="acquisition.html#botorch.acquisition.acquisition.AcquisitionFunction" title="botorch.acquisition.acquisition.AcquisitionFunction">AcquisitionFunction</a>, Any], Any]]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">ExampleClass</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">(</span><span class="n">expected_q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span><span class="w"> </span><span class="nf">single_q_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span><span class="w"> </span><span class="nf">arbitrary_q_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.concatenate_pending_points">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">concatenate_pending_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#concatenate_pending_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.concatenate_pending_points" title="Link to this definition"></a></dt>
<dd><p>Decorator concatenating X_pending into an acquisition function’s argument.</p>
<p>This decorator works on the <cite>forward</cite> method of acquisition functions taking
a tensor <cite>X</cite> as the argument. If the acquisition function has an <cite>X_pending</cite>
attribute (that is not <cite>None</cite>), this is concatenated into the input <cite>X</cite>,
appropriately expanding the pending points to match the batch shape of <cite>X</cite>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">ExampleAcquisitionFunction</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@concatenate_pending_points</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nd">@t_batch_mode_transform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="o">...</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>method</strong> (<em>Callable</em><em>[</em><em>[</em><em>Any</em><em>, </em><em>Tensor</em><em>]</em><em>, </em><em>Any</em><em>]</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Callable</em>[[<em>Any</em>, <em>Tensor</em>], <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.match_batch_shape">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">match_batch_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#match_batch_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.match_batch_shape" title="Link to this definition"></a></dt>
<dd><p>Matches the batch dimension of a tensor to that of another tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A <cite>batch_shape_X x q x d</cite> tensor, whose batch dimensions that
correspond to batch dimensions of <cite>Y</cite> are to be matched to those
(if compatible).</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>batch_shape_Y x q’ x d</cite> tensor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>batch_shape_Y x q x d</cite> tensor containing the data of <cite>X</cite> expanded to
the batch dimensions of <cite>Y</cite> (if compatible). For instance, if <cite>X</cite> is
<cite>b’’ x b’ x q x d</cite> and <cite>Y</cite> is <cite>b x q x d</cite>, then the returned tensor is
<cite>b’’ x b x q x d</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_matched</span> <span class="o">=</span> <span class="n">match_batch_shape</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_matched</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([2, 6, 5, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.transforms.convert_to_target_pre_hook">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.transforms.</span></span><span class="sig-name descname"><span class="pre">convert_to_target_pre_hook</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/transforms.html#convert_to_target_pre_hook"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.transforms.convert_to_target_pre_hook" title="Link to this definition"></a></dt>
<dd><p>Pre-hook for automatically calling <cite>.to(X)</cite> on module prior to <cite>forward</cite></p>
</dd></dl>

</section>
<section id="module-botorch.utils.feasible_volume">
<span id="feasible-volume"></span><h2>Feasible Volume<a class="headerlink" href="#module-botorch.utils.feasible_volume" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.get_feasible_samples">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">get_feasible_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#get_feasible_samples"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.get_feasible_samples" title="Link to this definition"></a></dt>
<dd><p>Checks which of the samples satisfy all of the inequality constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>samples</strong> (<em>Tensor</em>) – A <cite>sample size x d</cite> size tensor of feature samples,
where d is a feature dimension.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>2-element tuple containing</p>
<ul class="simple">
<li><p>Samples satisfying the linear constraints.</p></li>
<li><p>Estimated proportion of samples satisfying the linear constraints.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.get_outcome_feasibility_probability">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">get_outcome_feasibility_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#get_outcome_feasibility_probability"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.get_outcome_feasibility_probability" title="Link to this definition"></a></dt>
<dd><p>Monte Carlo estimate of the feasible volume with respect to the outcome constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The model used for sampling the posterior.</p></li>
<li><p><strong>X</strong> (<em>Tensor</em>) – A tensor of dimension <cite>batch-shape x 1 x d</cite>, where d is feature dimension.</p></li>
<li><p><strong>outcome_constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply feasibility.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A lower limit for the probability of posterior samples feasibility.</p></li>
<li><p><strong>nsample_outcome</strong> (<em>int</em>) – The number of samples from the model posterior.</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed for the posterior sampler. If omitted, use a random seed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Estimated proportion of features for which posterior samples satisfy
given outcome constraints with probability above or equal to
the given threshold.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.feasible_volume.estimate_feasible_volume">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.feasible_volume.</span></span><span class="sig-name descname"><span class="pre">estimate_feasible_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outcome_constraints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_feature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsample_outcome</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/feasible_volume.html#estimate_feasible_volume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.feasible_volume.estimate_feasible_volume" title="Link to this definition"></a></dt>
<dd><p>Monte Carlo estimate of the feasible volume with respect
to feature constraints and outcome constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x d</cite> tensor of lower and upper bounds
for each column of <cite>X</cite>.</p></li>
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – The model used for sampling the outcomes.</p></li>
<li><p><strong>outcome_constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply
feasibility.</p></li>
<li><p><strong>constraints</strong> (<em>inequality</em>) – A list of tuples (indices, coefficients, rhs),
with each tuple encoding an inequality constraint of the form
<cite>sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs</cite>.</p></li>
<li><p><strong>nsample_feature</strong> (<em>int</em>) – The number of feature samples satisfying the bounds.</p></li>
<li><p><strong>nsample_outcome</strong> (<em>int</em>) – The number of outcome samples from the model posterior.</p></li>
<li><p><strong>threshold</strong> (<em>float</em>) – A lower limit for the probability of outcome feasibility</p></li>
<li><p><strong>seed</strong> (<em>int</em><em> | </em><em>None</em>) – The seed for both feature and outcome samplers. If omitted,
use a random seed.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – An indicator for whether to log the results.</p></li>
<li><p><strong>inequality_constraints</strong> (<em>list</em><em>[</em><em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>, </em><em>float</em><em>]</em><em>] </em><em>| </em><em>None</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><dl class="simple">
<dt>Estimated proportion of volume in feature space that is</dt><dd><p>feasible wrt the bounds and the inequality constraints (linear).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Estimated proportion of feasible features for which</dt><dd><p>posterior samples (outcome) satisfies the outcome constraints
with probability above the given threshold.</p>
</dd>
</dl>
</li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.types">
<span id="types-and-type-hints"></span><h2>Types and Type Hints<a class="headerlink" href="#module-botorch.utils.types" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.types.cast">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.types.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">typ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/types.html#cast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.types.cast" title="Link to this definition"></a></dt>
<dd><p>Cast an object to a type, optionally allowing None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>typ</strong> (<em>Type</em><em>[</em><em>T</em><em>]</em>) – Type to cast to</p></li>
<li><p><strong>obj</strong> (<em>Any</em>) – Object to cast</p></li>
<li><p><strong>optional</strong> (<em>bool</em>) – Whether to allow None</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cast object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>T</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.types.DEFAULT">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.types.</span></span><span class="sig-name descname"><span class="pre">DEFAULT</span></span><a class="headerlink" href="#botorch.utils.types.DEFAULT" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.types.MISSING">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.types.</span></span><span class="sig-name descname"><span class="pre">MISSING</span></span><a class="headerlink" href="#botorch.utils.types.MISSING" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

</section>
<section id="module-botorch.utils.constants">
<span id="constants"></span><h2>Constants<a class="headerlink" href="#module-botorch.utils.constants" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constants.get_constants">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constants.</span></span><span class="sig-name descname"><span class="pre">get_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constants.html#get_constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constants.get_constants" title="Link to this definition"></a></dt>
<dd><p>Returns scalar-valued Tensors containing each of the given constants.
Used to expedite tensor operations involving scalar arithmetic. Note that
the returned Tensors should not be modified in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | tuple[<em>Tensor</em>, …]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.constants.get_constants_like">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.constants.</span></span><span class="sig-name descname"><span class="pre">get_constants_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/constants.html#get_constants_like"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.constants.get_constants_like" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>)</p></li>
<li><p><strong>ref</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | <em>Iterator</em>[<em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.safe_math">
<span id="safe-math"></span><h2>Safe Math<a class="headerlink" href="#module-botorch.utils.safe_math" title="Link to this heading"></a></h2>
<p>Special implementations of mathematical functions that
solve numerical issues of naive implementations.</p>
<div role="list" class="citation-list">
<div class="citation" id="maechler2012accurate" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Maechler2012accurate<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id7">2</a>)</span>
<ol class="upperalpha simple" start="13">
<li><dl class="simple">
<dt>Mächler. Accurately Computing log (1 - exp (-| a|))</dt><dd><p>Assessed by the Rmpfr package. Technical report, 2012.</p>
</dd>
</dl>
</li>
</ol>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.exp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#exp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.exp" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.add">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.add" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.sub">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.sub" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.div">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#div"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.div" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.mul">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#mul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.mul" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log1mexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log1mexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log1mexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log1mexp" title="Link to this definition"></a></dt>
<dd><p>Numerically accurate evaluation of log(1 - exp(x)) for x &lt; 0.
See <a class="reference internal" href="#maechler2012accurate" id="id6"><span>[Maechler2012accurate]</span></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log1pexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log1pexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log1pexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log1pexp" title="Link to this definition"></a></dt>
<dd><p>Numerically accurate evaluation of log(1 + exp(x)).
See <a class="reference internal" href="#maechler2012accurate" id="id7"><span>[Maechler2012accurate]</span></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logexpit">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logexpit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logexpit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logexpit" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the expit (a.k.a. sigmoid) function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logplusexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logplusexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logplusexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logplusexp" title="Link to this definition"></a></dt>
<dd><p>Computes log(exp(a) + exp(b)) similar to logsumexp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logdiffexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logdiffexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">log_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logdiffexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logdiffexp" title="Link to this definition"></a></dt>
<dd><p>Computes log(b - a) accurately given log(a) and log(b).
Assumes, log_b &gt; log_a, i.e. b &gt; a &gt; 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>log_a</strong> (<em>Tensor</em>) – The logarithm of a, assumed to be less than log_b.</p></li>
<li><p><strong>log_b</strong> (<em>Tensor</em>) – The logarithm of b, assumed to be larger than log_a.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of values corresponding to log(b - a).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logsumexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logsumexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logsumexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logsumexp" title="Link to this definition"></a></dt>
<dd><p>Version of logsumexp that has a well-behaved backward pass when
x contains infinities.</p>
<p>In particular, the gradient of the standard torch version becomes NaN
1) for any element that is positive infinity, and 2) for any slice that
only contains negative infinities.</p>
<p>This version returns a gradient of 1 for any positive infinities in case 1, and
for all elements of the slice in case 2, in agreement with the asymptotic behavior
of the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>) – The Tensor to which to apply <cite>logsumexp</cite>.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>) – An integer or a tuple of integers, representing the dimensions to reduce.</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>) – Whether to keep the reduced dimensions. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor representing the log of the summed exponentials of <cite>x</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.logmeanexp">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">logmeanexp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#logmeanexp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.logmeanexp" title="Link to this definition"></a></dt>
<dd><p>Computes <cite>log(mean(exp(X), dim=dim, keepdim=keepdim))</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – Values of which to compute the logmeanexp.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>) – The dimension(s) over which to compute the mean.</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>) – If True, keeps the reduced dimensions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of values corresponding to <cite>log(mean(exp(X), dim=dim))</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log_softplus">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log_softplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log_softplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log_softplus" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the softplus function with high numerical accuracy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>) – Input tensor, should have single or double precision floats.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Decreasing tau increases the tightness of the
approximation to ReLU. Non-negative and defaults to 1.0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor corresponding to <cite>log(softplus(x))</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.smooth_amax">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">smooth_amax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#smooth_amax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.smooth_amax" title="Link to this definition"></a></dt>
<dd><p>Computes a smooth approximation to <cite>max(X, dim=dim)</cite>, i.e the maximum value of
<cite>X</cite> over dimension <cite>dim</cite>, using the logarithm of the <cite>l_(1/tau)</cite> norm of <cite>exp(X)</cite>.
Note that when <cite>X = log(U)</cite> is the <em>logarithm</em> of an acquisition utility <cite>U</cite>,</p>
<p><cite>logsumexp(log(U) / tau) * tau = log(sum(U^(1/tau))^tau) = log(norm(U, ord=(1/tau))</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A Tensor from which to compute the smoothed amax.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>) – The dimensions to reduce over.</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>) – If True, keeps the reduced dimensions.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smooth approximation
to max operator, becomes tighter as tau goes to 0. Needs to be positive.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of smooth approximations to <cite>max(X, dim=dim)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.smooth_amin">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">smooth_amin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#smooth_amin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.smooth_amin" title="Link to this definition"></a></dt>
<dd><p>A smooth approximation to <cite>min(X, dim=dim)</cite>, similar to <cite>smooth_amax</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>)</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>)</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.check_dtype_float32_or_float64">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">check_dtype_float32_or_float64</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#check_dtype_float32_or_float64"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.check_dtype_float32_or_float64" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log_fatplus">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log_fatplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log_fatplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log_fatplus" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the fat-tailed softplus.</p>
<p>NOTE: Separated out in case the complexity of the <cite>log</cite> implementation increases
in the future.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatplus">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatplus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatplus"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatplus" title="Link to this definition"></a></dt>
<dd><p>Computes a fat-tailed approximation to <cite>ReLU(x) = max(x, 0)</cite> by linearly
combining a regular softplus function and the density function of a Cauchy
distribution. The coefficient <cite>alpha</cite> of the Cauchy density is chosen to guarantee
monotonicity and convexity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>Tensor</em>) – A Tensor on whose values to compute the smoothed function.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smoothness of the approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of values of the fat-tailed softplus.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatmax">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatmax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatmax"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatmax" title="Link to this definition"></a></dt>
<dd><p>Computes a smooth approximation to amax(X, dim=dim) with a fat tail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – A Tensor from which to compute the smoothed maximum.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>) – The dimensions to reduce over.</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>) – If True, keeps the reduced dimensions.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smooth approximation
to max operator, becomes tighter as tau goes to 0. Needs to be positive.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The exponent of the asymptotic power decay of the approximation. The
default value is 2. Higher alpha parameters make the function behave more
similarly to the standard logsumexp approximation to the max, so it is
recommended to keep this value low or moderate, e.g. &lt; 10.</p></li>
<li><p><strong>x</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of smooth approximations to <cite>amax(X, dim=dim)</cite> with a fat tail.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatmin">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatmin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keepdim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatmin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatmin" title="Link to this definition"></a></dt>
<dd><p>Computes a smooth approximation to amin(X, dim=dim) with a fat tail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> – A Tensor from which to compute the smoothed minimum.</p></li>
<li><p><strong>dim</strong> (<em>int</em><em> | </em><em>tuple</em><em>[</em><em>int</em><em>, </em><em>...</em><em>]</em>) – The dimensions to reduce over.</p></li>
<li><p><strong>keepdim</strong> (<em>bool</em>) – If True, keeps the reduced dimensions.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smooth approximation
to min operator, becomes tighter as tau goes to 0. Needs to be positive.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The exponent of the asymptotic power decay of the approximation. The
default value is 2. Higher alpha parameters make the function behave more
similarly to the standard logsumexp approximation to the max, so it is
recommended to keep this value low or moderate, e.g. &lt; 10.</p></li>
<li><p><strong>x</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of smooth approximations to <cite>amin(X, dim=dim)</cite> with a fat tail.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatmaximum">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatmaximum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatmaximum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatmaximum" title="Link to this definition"></a></dt>
<dd><p>Computes a smooth approximation to torch.maximum(a, b) with a fat tail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – The first Tensor from which to compute the smoothed component-wise maximum.</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – The second Tensor from which to compute the smoothed component-wise maximum.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smoothness of the approximation. A
smaller tau corresponds to a tighter approximation that leads to a sharper
objective landscape that might be more difficult to optimize.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A smooth approximation of torch.maximum(a, b).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatminimum">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatminimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatminimum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatminimum" title="Link to this definition"></a></dt>
<dd><p>Computes a smooth approximation to torch.minimum(a, b) with a fat tail.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – The first Tensor from which to compute the smoothed component-wise minimum.</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – The second Tensor from which to compute the smoothed component-wise minimum.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smoothness of the approximation. A
smaller tau corresponds to a tighter approximation that leads to a sharper
objective landscape that might be more difficult to optimize.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A smooth approximation of torch.minimum(a, b).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.log_fatmoid">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">log_fatmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#log_fatmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.log_fatmoid" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the fatmoid. Separated out in case the implementation
of the logarithm becomes more complex in the future to ensure numerical stability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.fatmoid">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">fatmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#fatmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.fatmoid" title="Link to this definition"></a></dt>
<dd><p>Computes a twice continuously differentiable approximation to the Heaviside
step function with a fat tail, i.e. <cite>O(1 / x^2)</cite> as <cite>x</cite> goes to -inf.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – A Tensor from which to compute the smoothed step function.</p></li>
<li><p><strong>tau</strong> (<em>float</em><em> | </em><em>Tensor</em>) – Temperature parameter controlling the smoothness of the approximation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of fat-tailed approximations to the Heaviside step function.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.cauchy">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">cauchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#cauchy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.cauchy" title="Link to this definition"></a></dt>
<dd><p>Computes a Lorentzian, i.e. an un-normalized Cauchy density function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.safe_math.sigmoid">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.safe_math.</span></span><span class="sig-name descname"><span class="pre">sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fat</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/safe_math.html#sigmoid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.safe_math.sigmoid" title="Link to this definition"></a></dt>
<dd><p>A sigmoid function with an optional fat tail and evaluation in log space for
better numerical behavior. Notably, the fat-tailed sigmoid can be used to remedy
numerical underflow problems in the value and gradient of the canonical sigmoid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>Tensor</em>) – The Tensor on which to evaluate the sigmoid.</p></li>
<li><p><strong>log</strong> (<em>bool</em>) – Toggles the evaluation of the log sigmoid.</p></li>
<li><p><strong>fat</strong> (<em>bool</em>) – Toggles the evaluation of the fat-tailed sigmoid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of (log-)sigmoid values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<section id="multi-objective-utilities">
<h3>Multi-Objective Utilities<a class="headerlink" href="#multi-objective-utilities" title="Link to this heading"></a></h3>
</section>
</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.box_decomposition">
<span id="abstract-box-decompositions"></span><h2>Abstract Box Decompositions<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition" title="Link to this heading"></a></h2>
<p>Box decomposition algorithms.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="lacour17" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Lacour17<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id8">1</a>,<a role="doc-backlink" href="#id9">2</a>,<a role="doc-backlink" href="#id10">3</a>,<a role="doc-backlink" href="#id11">4</a>,<a role="doc-backlink" href="#id18">5</a>,<a role="doc-backlink" href="#id19">6</a>)</span>
<p>R. Lacour, K. Klamroth, C. Fonseca. A box decomposition algorithm to
compute the hypervolume indicator. Computers &amp; Operations Research,
Volume 79, 2017.</p>
</div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.</span></span><span class="sig-name descname"><span class="pre">BoxDecomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>An abstract class for box decompositions.</p>
<p>Note: Internally, we store the negative reference point (minimization).</p>
<p>Initialize BoxDecomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>sort</strong> (<em>bool</em>) – A boolean indicating whether to sort the Pareto frontier.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of outcomes.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.pareto_Y">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pareto_Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.pareto_Y" title="Link to this definition"></a></dt>
<dd><p>This returns the non-dominated set.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>n_pareto x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.ref_point">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.ref_point" title="Link to this definition"></a></dt>
<dd><p>Get the reference point.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.Y">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.Y" title="Link to this definition"></a></dt>
<dd><p>Get the raw outcomes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>n x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.partition_space">
<span class="sig-name descname"><span class="pre">partition_space</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.partition_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.partition_space" title="Link to this definition"></a></dt>
<dd><p>Compute box decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.get_hypercell_bounds">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.get_hypercell_bounds" title="Link to this definition"></a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x num_cells x num_outcomes</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.update" title="Link to this definition"></a></dt>
<dd><p>Update non-dominated front and decomposition.</p>
<p>By default, the partitioning is recomputed. Subclasses can override
this functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of new, incremental outcomes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.reset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.reset" title="Link to this definition"></a></dt>
<dd><p>Reset non-dominated front and decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#BoxDecomposition.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition.compute_hypervolume" title="Link to this definition"></a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Froniter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition.</span></span><span class="sig-name descname"><span class="pre">FastPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxDecomposition</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>A class for partitioning the (non-)dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies outcomes by -1
and performs the decomposition under minimization.</p>
<p>This class is abstract to support to two applications of Alg 1 from
<a class="reference internal" href="#lacour17" id="id8"><span>[Lacour17]</span></a>: 1) partitioning the space that is dominated by the Pareto
frontier and 2) partitioning the space that is not dominated by the
Pareto frontier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.update" title="Link to this definition"></a></dt>
<dd><p>Update non-dominated front and decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of new, incremental outcomes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.partition_space">
<span class="sig-name descname"><span class="pre">partition_space</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning.partition_space"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.partition_space" title="Link to this definition"></a></dt>
<dd><p>Compute box decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition.html#FastPartitioning.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning.get_hypercell_bounds" title="Link to this definition"></a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x (batch_shape) x num_cells x m</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list">
<span id="box-decomposition-list"></span><h2>Box Decomposition List<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.box_decomposition_list" title="Link to this heading"></a></h2>
<p>Box decomposition container.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.box_decomposition_list.</span></span><span class="sig-name descname"><span class="pre">BoxDecompositionList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">box_decompositions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code></p>
<p>A list of box decompositions.</p>
<p>Initialize the box decomposition list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>*box_decompositions</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><em>BoxDecomposition</em></a>) – An variable number of box decompositions</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd1</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bd2</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">BoxDecompositionList</span><span class="p">(</span><span class="n">bd1</span><span class="p">,</span> <span class="n">bd2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pareto_Y</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Tensor</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.pareto_Y" title="Link to this definition"></a></dt>
<dd><p>This returns the non-dominated set.</p>
<p>Note: Internally, we store the negative pareto set (minimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A list where the ith element is the <cite>n_pareto_i x m</cite>-dim tensor</dt><dd><p>of pareto optimal outcomes for each box_decomposition <cite>i</cite>.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.ref_point" title="Link to this definition"></a></dt>
<dd><p>Get the reference point.</p>
<p>Note: Internally, we store the negative reference point (minimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>n_box_decompositions x m</cite>-dim tensor of outcomes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.get_hypercell_bounds" title="Link to this definition"></a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>2 x n_box_decompositions x num_cells x num_outcomes</cite>-dim tensor</dt><dd><p>containing the lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.update" title="Link to this definition"></a></dt>
<dd><p>Update the partitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>list</em><em>[</em><em>Tensor</em><em>] </em><em>| </em><em>Tensor</em>) – A <cite>n_box_decompositions x n x num_outcomes</cite>-dim tensor or a list
where the ith  element contains the new points for
box_decomposition <cite>i</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume">
<span class="sig-name descname"><span class="pre">compute_hypervolume</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/box_decomposition_list.html#BoxDecompositionList.compute_hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition_list.BoxDecompositionList.compute_hypervolume" title="Link to this definition"></a></dt>
<dd><p>Compute hypervolume that is dominated by the Pareto Froniter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>A <cite>(batch_shape)</cite>-dim tensor containing the hypervolume dominated by</dt><dd><p>each Pareto frontier.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.utils">
<span id="box-decomposition-utilities"></span><h2>Box Decomposition Utilities<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.utils" title="Link to this heading"></a></h2>
<p>Utilities for box decomposition algorithms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_local_upper_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_local_upper_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_local_upper_bounds" title="Link to this definition"></a></dt>
<dd><p>Compute local upper bounds.</p>
<p>Note: this assumes minimization.</p>
<p>This uses the incremental algorithm (Alg. 1) from <a class="reference internal" href="#lacour17" id="id9"><span>[Lacour17]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>Z</strong> (<em>Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points.</p></li>
<li><p><strong>z</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the new point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A new <cite>n’ x m</cite>-dim tensor local upper bounds.</p></li>
<li><p>A <cite>n’ x m x m</cite>-dim tensor containing the defining points.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">get_partition_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#get_partition_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.get_partition_bounds" title="Link to this definition"></a></dt>
<dd><p>Get the cell bounds given the local upper bounds and the defining points.</p>
<p>This implements Equation 2 in <a class="reference internal" href="#lacour17" id="id10"><span>[Lacour17]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Z</strong> (<em>Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points. The first
dimension corresponds to u_idx, the second dimension corresponds to j,
and Z[u_idx, j] is the set of definining points Z^j(u) where
u = U[u_idx].</p></li>
<li><p><strong>U</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>2 x num_cells x m</cite>-dim tensor containing the lower and upper vertices</dt><dd><p>bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">update_local_upper_bounds_incremental</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_pareto_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#update_local_upper_bounds_incremental"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.update_local_upper_bounds_incremental" title="Link to this definition"></a></dt>
<dd><p>Update the current local upper with the new pareto points.</p>
<p>This assumes minimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new_pareto_Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor containing the new
Pareto points.</p></li>
<li><p><strong>U</strong> (<em>Tensor</em>) – A <cite>n’ x m</cite>-dim tensor containing the local upper bounds.</p></li>
<li><p><strong>Z</strong> (<em>Tensor</em>) – A <cite>n x m x m</cite>-dim tensor containing the defining points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p>A new <cite>n’ x m</cite>-dim tensor local upper bounds.</p></li>
<li><p>A <cite>n’ x m x m</cite>-dim tensor containing the defining points</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2-element tuple containing</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_non_dominated_hypercell_bounds_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_non_dominated_hypercell_bounds_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_non_dominated_hypercell_bounds_2d" title="Link to this definition"></a></dt>
<dd><p>Compute an axis-aligned partitioning of the non-dominated space for 2
objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y_sorted</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n_pareto x 2</cite>-dim tensor of pareto outcomes
that are sorted by the 0th dimension in increasing order. All points must be
better than the reference point.</p></li>
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x 2</cite>-dim reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>2 x (batch_shape) x n_pareto + 1 x m</cite>-dim tensor of cell bounds.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.utils.</span></span><span class="sig-name descname"><span class="pre">compute_dominated_hypercell_bounds_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/utils.html#compute_dominated_hypercell_bounds_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.utils.compute_dominated_hypercell_bounds_2d" title="Link to this definition"></a></dt>
<dd><p>Compute an axis-aligned partitioning of the dominated space for 2-objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y_sorted</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n_pareto x 2</cite>-dim tensor of pareto outcomes
that are sorted by the 0th dimension in increasing order.</p></li>
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>2</cite>-dim reference point.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>2 x (batch_shape) x n_pareto x m</cite>-dim tensor of cell bounds.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.dominated">
<span id="dominated-partitionings"></span><h2>Dominated Partitionings<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.dominated" title="Link to this heading"></a></h2>
<p>Algorithms for partitioning the dominated space into hyperrectangles.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.dominated.</span></span><span class="sig-name descname"><span class="pre">DominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/dominated.html#DominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.dominated.DominatedPartitioning" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning"><code class="xref py py-class docutils literal notranslate"><span class="pre">FastPartitioning</span></code></a></p>
<p>Partition dominated space into axis-aligned hyperrectangles.</p>
<p>This uses the Algorithm 1 from <a class="reference internal" href="#lacour17" id="id11"><span>[Lacour17]</span></a>.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">DominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.hypervolume">
<span id="hypervolume"></span><h2>Hypervolume<a class="headerlink" href="#module-botorch.utils.multi_objective.hypervolume" title="Link to this heading"></a></h2>
<p>Hypervolume Utilities.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="fonseca2006" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Fonseca2006<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id14">2</a>)</span>
<p>C. M. Fonseca, L. Paquete, and M. Lopez-Ibanez. An improved dimension-sweep
algorithm for the hypervolume indicator. In IEEE Congress on Evolutionary
Computation, pages 1157-1163, Vancouver, Canada, July 2006.</p>
</div>
<div class="citation" id="ishibuchi2011" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id12">Ishibuchi2011</a><span class="fn-bracket">]</span></span>
<p>H. Ishibuchi, N. Akedo, and Y. Nojima. A many-objective test problem
for visually examining diversity maintenance behavior in a decision
space. Proc. 13th Annual Conf. Genetic Evol. Comput., 2011.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.infer_reference_point">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">infer_reference_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_max_ref_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#infer_reference_point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.infer_reference_point" title="Link to this definition"></a></dt>
<dd><p>Get reference point for hypervolume computations.</p>
<p>This sets the reference point to be <cite>ref_point = nadir - scale * range</cite>
when there is no <cite>pareto_Y</cite> that is better than <cite>max_ref_point</cite>.
If there’s <cite>pareto_Y</cite> better than <cite>max_ref_point</cite>, the reference point
will be set to <cite>max_ref_point - scale * range</cite> if <cite>scale_max_ref_point</cite>
is true and to <cite>max_ref_point</cite> otherwise.</p>
<p><a class="reference internal" href="#ishibuchi2011" id="id12"><span>[Ishibuchi2011]</span></a> find 0.1 to be a robust multiplier for scaling the
nadir point.</p>
<p>Note: this assumes maximization of all objectives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pareto_Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor of Pareto-optimal points.</p></li>
<li><p><strong>max_ref_point</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>m</cite> dim tensor indicating the maximum reference point.
Some elements can be NaN, except when <cite>pareto_Y</cite> is empty,
in which case these dimensions will be treated as if no
<cite>max_ref_point</cite> was provided and set to <cite>nadir - scale * range</cite>.</p></li>
<li><p><strong>scale</strong> (<em>float</em>) – A multiplier used to scale back the reference point based on the
range of each objective.</p></li>
<li><p><strong>scale_max_ref_point</strong> (<em>bool</em>) – A boolean indicating whether to apply scaling to
the max_ref_point based on the range of each objective.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>m</cite>-dim tensor containing the reference point.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">Hypervolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Hypervolume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Hypervolume computation dimension sweep algorithm from <a class="reference internal" href="#fonseca2006" id="id13"><span>[Fonseca2006]</span></a>.</p>
<p>Adapted from Simon Wessing’s implementation of the algorithm
(Variant 3, Version 1.2) in <a class="reference internal" href="#fonseca2006" id="id14"><span>[Fonseca2006]</span></a> in PyMOO:
<a class="reference external" href="https://github.com/msu-coinlab/pymoo/blob/master/pymoo/vendor/hv.py">https://github.com/msu-coinlab/pymoo/blob/master/pymoo/vendor/hv.py</a></p>
<p>Maximization is assumed.</p>
<p>TODO: write this in C++ for faster looping.</p>
<p>Initialize hypervolume object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ref_point</strong> (<em>Tensor</em>) – <cite>m</cite>-dim Tensor containing the reference point.</p>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ref_point</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.ref_point" title="Link to this definition"></a></dt>
<dd><p>Get reference point (for maximization).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>m</cite>-dim tensor containing the reference point.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Hypervolume.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pareto_Y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Hypervolume.compute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Hypervolume.compute" title="Link to this definition"></a></dt>
<dd><p>Compute hypervolume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pareto_Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor of pareto optimal outcomes</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The hypervolume.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.sort_by_dimension">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">sort_by_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#sort_by_dimension"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.sort_by_dimension" title="Link to this definition"></a></dt>
<dd><p>Sorts the list of nodes in-place by the specified objective.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>list</em><em>[</em><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a><em>]</em>) – A list of Nodes</p></li>
<li><p><strong>i</strong> (<em>int</em>) – The index of the objective to sort by</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.Node">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">Node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#Node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.Node" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Node in the MultiList data structure.</p>
<p>Initialize MultiList.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – The number of objectives</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em>) – The dtype</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – The device</p></li>
<li><p><strong>data</strong> (<em>Tensor</em><em> | </em><em>None</em>) – The tensor data to be stored in this Node.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">MultiList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A special data structure used in hypervolume computation.</p>
<p>It consists of several doubly linked lists that share common nodes.
Every node has multiple predecessors and successors, one in every list.</p>
<p>Initialize <cite>m</cite> doubly linked lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m</strong> (<em>int</em>) – number of doubly linked lists</p></li>
<li><p><strong>dtype</strong> (<em>torch.dtype</em>) – the dtype</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>) – the device</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.append" title="Link to this definition"></a></dt>
<dd><p>Appends a node to the end of the list at the given index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a>) – the new node</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index where the node should be appended.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.extend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.extend" title="Link to this definition"></a></dt>
<dd><p>Extends the list at the given index with the nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nodes</strong> (<em>list</em><em>[</em><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a><em>]</em>) – list of nodes to append at the given index.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index where the nodes should be appended.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.remove"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.remove" title="Link to this definition"></a></dt>
<dd><p>Removes and returns ‘node’ from all lists in [0, ‘index’].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a>) – The node to remove</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The upper bound on the range of indices</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x m</cite>-dim tensor bounds on the objectives</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.MultiList.reinsert">
<span class="sig-name descname"><span class="pre">reinsert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#MultiList.reinsert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.MultiList.reinsert" title="Link to this definition"></a></dt>
<dd><p>Re-inserts the node at its original position.</p>
<p>Re-inserts the node at its original position in all lists in [0, ‘index’]
before it was removed. This method assumes that the next and previous
nodes of the node that is reinserted are in the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>node</strong> (<a class="reference internal" href="#botorch.utils.multi_objective.hypervolume.Node" title="botorch.utils.multi_objective.hypervolume.Node"><em>Node</em></a>) – The node</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The upper bound on the range of indices</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>2 x m</cite>-dim tensor bounds on the objectives</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.SubsetIndexCachingMixin">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">SubsetIndexCachingMixin</span></span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#SubsetIndexCachingMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.SubsetIndexCachingMixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Mixin class that adds q-subset index computations and caching.</p>
<p>Initializes the class with q_out = -1 and an empty q_subset_indices dict.</p>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.SubsetIndexCachingMixin.compute_q_subset_indices">
<span class="sig-name descname"><span class="pre">compute_q_subset_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#SubsetIndexCachingMixin.compute_q_subset_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.SubsetIndexCachingMixin.compute_q_subset_indices" title="Link to this definition"></a></dt>
<dd><p>Returns and caches a dict of indices equal to subsets of <cite>{1, …, q_out}</cite>.</p>
<p>This means that consecutive calls to <cite>self.compute_q_subset_indices</cite> with
the same <cite>q_out</cite> do not recompute the indices for all (2^q_out - 1) subsets.</p>
<p>NOTE: This will use more memory than regenerating the indices
for each i and then deleting them, but it will be faster for
repeated evaluations (e.g. during optimization).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q_out</strong> (<em>int</em>) – The batch size of the objectives. This is typically equal
to the q-batch size of <cite>X</cite>. However, if using a set valued
objective (e.g., MVaR) that produces <cite>s</cite> objective values for
each point on the q-batch of <cite>X</cite>, we need to properly account
for each objective while calculating the hypervolume contributions
by using <cite>q_out = q * s</cite>.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dict that maps “q choose i” to all size-i subsets of <cite>{1, …, q_out}</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.torch.BufferDict" title="botorch.utils.torch.BufferDict">BufferDict</a>[str, Tensor]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.compute_subset_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">compute_subset_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#compute_subset_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.compute_subset_indices" title="Link to this definition"></a></dt>
<dd><p>Compute all (2^q - 1) distinct subsets of {1, …, <cite>q</cite>}.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>q</strong> (<em>int</em>) – An integer defininig the set {1, …, <cite>q</cite>} whose subsets to compute.</p></li>
<li><p><strong>device</strong> (<em>torch.device</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dict that maps “q choose i” to all size-i subsets of {1, …, <cite>q_out</cite>}.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.torch.BufferDict" title="botorch.utils.torch.BufferDict">BufferDict</a>[str, Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.hypervolume.</span></span><span class="sig-name descname"><span class="pre">NoisyExpectedHypervolumeMixin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_baseline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">objective</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_pending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prune_baseline</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_pending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incremental_nehvi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marginalize_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#NoisyExpectedHypervolumeMixin"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="acquisition.html#botorch.acquisition.cached_cholesky.CachedCholeskyMCSamplerMixin" title="botorch.acquisition.cached_cholesky.CachedCholeskyMCSamplerMixin"><code class="xref py py-class docutils literal notranslate"><span class="pre">CachedCholeskyMCSamplerMixin</span></code></a></p>
<p>Initialize a mixin that contains functions for the batched Pareto-frontier
partitioning used by the noisy hypervolume-improvement-based acquisition
functions, i.e. qNEHVI and qLogNEHVI.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="models.html#botorch.models.model.Model" title="botorch.models.model.Model"><em>Model</em></a>) – A fitted model.</p></li>
<li><p><strong>ref_point</strong> (<em>list</em><em>[</em><em>float</em><em>] </em><em>| </em><em>Tensor</em>) – A list or tensor with <cite>m</cite> elements representing the reference
point (in the outcome space) w.r.t. to which compute the hypervolume.
This is a reference point for the objective values (i.e. after
applying <cite>objective</cite> to the samples).</p></li>
<li><p><strong>X_baseline</strong> (<em>Tensor</em>) – A <cite>r x d</cite>-dim Tensor of <cite>r</cite> design points that have already
been observed. These points are considered as potential approximate
pareto-optimal design points.</p></li>
<li><p><strong>sampler</strong> (<a class="reference internal" href="sampling.html#botorch.sampling.base.MCSampler" title="botorch.sampling.base.MCSampler"><em>MCSampler</em></a><em> | </em><em>None</em>) – The sampler used to draw base samples. If not given,
a sampler is generated using <cite>get_sampler</cite>. NOTE: A box decomposition is
of the Pareto front is created for each MC sample, an operation that
scales as <cite>O(n^m)</cite> and thus becomes particularly costly for <cite>m</cite> &gt; 2.</p></li>
<li><p><strong>objective</strong> (<a class="reference internal" href="acquisition.html#botorch.acquisition.multi_objective.objective.MCMultiOutputObjective" title="botorch.acquisition.multi_objective.objective.MCMultiOutputObjective"><em>MCMultiOutputObjective</em></a><em> | </em><em>None</em>) – The MCMultiOutputObjective under which the samples are
evaluated. Defaults to <cite>IdentityMCMultiOutputObjective()</cite>.</p></li>
<li><p><strong>constraints</strong> (<em>list</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>Tensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>] </em><em>| </em><em>None</em>) – A list of callables, each mapping a Tensor of dimension
<cite>sample_shape x batch-shape x q x m</cite> to a Tensor of dimension
<cite>sample_shape x batch-shape x q</cite>, where negative values imply
feasibility. The acqusition function will compute expected feasible
hypervolume.</p></li>
<li><p><strong>X_pending</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>batch_shape x m x d</cite>-dim Tensor of <cite>m</cite> design points that
have points that have been submitted for function evaluation, but
have not yet been evaluated.</p></li>
<li><p><strong>prune_baseline</strong> (<em>bool</em>) – If True, remove points in <cite>X_baseline</cite> that are
highly unlikely to be the pareto optimal and better than the
reference point. This can significantly improve computation time and
is generally recommended. In order to customize pruning parameters,
instead manually call <cite>prune_inferior_points_multi_objective</cite> on
<cite>X_baseline</cite> before instantiating the acquisition function.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – The hyperparameter controlling the approximate non-dominated
partitioning. The default value of 0.0 means an exact partitioning
is used. As the number of objectives <cite>m</cite> increases, consider increasing
this parameter in order to limit computational complexity.</p></li>
<li><p><strong>cache_pending</strong> (<em>bool</em>) – A boolean indicating whether to use cached box
decompositions (CBD) for handling pending points. This is
generally recommended.</p></li>
<li><p><strong>max_iep</strong> (<em>int</em>) – The maximum number of pending points before the box
decompositions will be recomputed.</p></li>
<li><p><strong>incremental_nehvi</strong> (<em>bool</em>) – A boolean indicating whether to compute the
incremental NEHVI from the <cite>i`th point where `i=1, …, q</cite>
under sequential greedy optimization, or the full qNEHVI over
<cite>q</cite> points.</p></li>
<li><p><strong>cache_root</strong> (<em>bool</em>) – A boolean indicating whether to cache the root
decomposition over <cite>X_baseline</cite> and use low-rank updates.</p></li>
<li><p><strong>marginalize_dim</strong> (<em>int</em><em> | </em><em>None</em>) – A batch dimension that should be marginalized. For example,
this is useful when using a batched fully Bayesian model.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin.X_baseline">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">X_baseline</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin.X_baseline" title="Link to this definition"></a></dt>
<dd><p>Return X_baseline augmented with pending points cached using CBD.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin.set_X_pending">
<span class="sig-name descname"><span class="pre">set_X_pending</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_pending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/hypervolume.html#NoisyExpectedHypervolumeMixin.set_X_pending"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.hypervolume.NoisyExpectedHypervolumeMixin.set_X_pending" title="Link to this definition"></a></dt>
<dd><p>Informs the acquisition function about pending design points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X_pending</strong> (<em>Tensor</em><em> | </em><em>None</em>) – <cite>n x d</cite> Tensor with <cite>n</cite> <cite>d</cite>-dim design points that have
been submitted for evaluation but have not yet been evaluated.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.box_decompositions.non_dominated">
<span id="non-dominated-partitionings"></span><h2>Non-dominated Partitionings<a class="headerlink" href="#module-botorch.utils.multi_objective.box_decompositions.non_dominated" title="Link to this heading"></a></h2>
<p>Algorithms for partitioning the non-dominated space into rectangles.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="couckuyt2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Couckuyt2012<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id15">1</a>,<a role="doc-backlink" href="#id16">2</a>)</span>
<p>I. Couckuyt, D. Deschrijver and T. Dhaene, “Towards Efficient
Multiobjective Optimization: Multiobjective statistical criterions,”
2012 IEEE Congress on Evolutionary Computation, Brisbane, QLD, 2012,
pp. 1-8.</p>
</div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.non_dominated.</span></span><span class="sig-name descname"><span class="pre">NondominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.BoxDecomposition"><code class="xref py py-class docutils literal notranslate"><span class="pre">BoxDecomposition</span></code></a></p>
<p>A class for partitioning the non-dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies outcomes by -1 and
performs the decomposition under minimization. TODO: use maximization
internally as well.</p>
<p>Note: it is only feasible to use this algorithm to compute an exact
decomposition of the non-dominated space for <cite>m&lt;5</cite> objectives (alpha=0.0).</p>
<p>The alpha parameter can be increased to obtain an approximate partitioning
faster. The <cite>alpha</cite> is a fraction of the total hypervolume encapsuling the
entire Pareto set. When a hypercell’s volume divided by the total hypervolume
is less than <cite>alpha</cite>, we discard the hypercell. See Figure 2 in
<a class="reference internal" href="#couckuyt2012" id="id15"><span>[Couckuyt2012]</span></a> for a visual representation.</p>
<p>This PyTorch implementation of the binary partitioning algorithm (<a class="reference internal" href="#couckuyt2012" id="id16"><span>[Couckuyt2012]</span></a>)
is adapted from numpy/tensorflow implementation at:
<a class="reference external" href="https://github.com/GPflow/GPflowOpt/blob/master/gpflowopt/pareto.py">https://github.com/GPflow/GPflowOpt/blob/master/gpflowopt/pareto.py</a>.</p>
<p>TODO: replace this with a more efficient decomposition. E.g.
<a class="reference external" href="https://link.springer.com/content/pdf/10.1007/s10898-019-00798-7.pdf">https://link.springer.com/content/pdf/10.1007/s10898-019-00798-7.pdf</a></p>
<p>Initialize NondominatedPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – A thresold fraction of total volume used in an approximate
decomposition.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">NondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds">
<span class="sig-name descname"><span class="pre">get_hypercell_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#NondominatedPartitioning.get_hypercell_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.NondominatedPartitioning.get_hypercell_bounds" title="Link to this definition"></a></dt>
<dd><p>Get the bounds of each hypercell in the decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ref_point</strong> – A <cite>(batch_shape) x m</cite>-dim tensor containing the reference point.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A <cite>2 x num_cells x m</cite>-dim tensor containing the</dt><dd><p>lower and upper vertices bounding each hypercell.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.box_decompositions.non_dominated.</span></span><span class="sig-name descname"><span class="pre">FastNondominatedPartitioning</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ref_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/box_decompositions/non_dominated.html#FastNondominatedPartitioning"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.box_decompositions.non_dominated.FastNondominatedPartitioning" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning" title="botorch.utils.multi_objective.box_decompositions.box_decomposition.FastPartitioning"><code class="xref py py-class docutils literal notranslate"><span class="pre">FastPartitioning</span></code></a></p>
<p>A class for partitioning the non-dominated space into hyper-cells.</p>
<p>Note: this assumes maximization. Internally, it multiplies by -1 and performs
the decomposition under minimization.</p>
<p>This class is far more efficient than NondominatedPartitioning for exact box
partitionings</p>
<dl class="simple">
<dt>This class uses the two-step approach similar to that in <a class="reference internal" href="acquisition.html#yang2019" id="id17"><span>[Yang2019]</span></a>, where:</dt><dd><ol class="loweralpha simple">
<li><dl class="simple">
<dt>first, Alg 1 from <a class="reference internal" href="#lacour17" id="id18"><span>[Lacour17]</span></a> is used to find the local lower bounds</dt><dd><p>for the maximization problem</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>second, the local lower bounds are used as the Pareto frontier for the</dt><dd><p>minimization problem, and <a class="reference internal" href="#lacour17" id="id19"><span>[Lacour17]</span></a> is applied again to partition
the space dominated by that Pareto frontier.</p>
</dd>
</dl>
</li>
</ol>
</dd>
</dl>
<p>Initialize FastNondominatedPartitioning.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ref_point</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor containing the reference point.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bd</span> <span class="o">=</span> <span class="n">FastNondominatedPartitioning</span><span class="p">(</span><span class="n">ref_point</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="n">Y1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.pareto">
<span id="pareto"></span><h2>Pareto<a class="headerlink" href="#module-botorch.utils.multi_objective.pareto" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.pareto.is_non_dominated">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.pareto.</span></span><span class="sig-name descname"><span class="pre">is_non_dominated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deduplicate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/pareto.html#is_non_dominated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.pareto.is_non_dominated" title="Link to this definition"></a></dt>
<dd><p>Computes the non-dominated front.</p>
<p>Note: this assumes maximization.</p>
<p>For small <cite>n</cite>, this method uses a highly parallel methodology
that compares all pairs of points in Y. However, this is memory
intensive and slow for large <cite>n</cite>. For large <cite>n</cite> (or if Y is larger
than 5MB), this method will dispatch to a loop-based approach
that is faster and has a lower memory footprint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>(batch_shape) x n x m</cite>-dim tensor of outcomes.
If any element of <cite>Y</cite> is NaN, the corresponding point
will be treated as a dominated point (returning False).</p></li>
<li><p><strong>maximize</strong> (<em>bool</em>) – If True, assume maximization (default).</p></li>
<li><p><strong>deduplicate</strong> (<em>bool</em>) – A boolean indicating whether to only return
unique points on the pareto frontier.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>(batch_shape) x n</cite>-dim boolean tensor indicating whether
each point is non-dominated.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.multi_objective.scalarization">
<span id="scalarization"></span><h2>Scalarization<a class="headerlink" href="#module-botorch.utils.multi_objective.scalarization" title="Link to this heading"></a></h2>
<p>Helper utilities for constructing scalarizations.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="knowles2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Knowles2005<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id20">1</a>,<a role="doc-backlink" href="#id22">2</a>)</span>
<p>J. Knowles, “ParEGO: a hybrid algorithm with on-line landscape approximation
for expensive multiobjective optimization problems,” in IEEE Transactions
on Evolutionary Computation, vol. 10, no. 1, pp. 50-66, Feb. 2006.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.multi_objective.scalarization.</span></span><span class="sig-name descname"><span class="pre">get_chebyshev_scalarization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/multi_objective/scalarization.html#get_chebyshev_scalarization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.multi_objective.scalarization.get_chebyshev_scalarization" title="Link to this definition"></a></dt>
<dd><p>Construct an augmented Chebyshev scalarization.</p>
<dl class="simple">
<dt>The augmented Chebyshev scalarization is given by</dt><dd><p>g(y) = max_i(w_i * y_i) + alpha * sum_i(w_i * y_i)</p>
</dd>
</dl>
<p>where the goal is to minimize g(y) in the setting where all objectives y_i are
to be minimized. Since the default in BoTorch is to maximize all objectives,
this method constructs a Chebyshev scalarization where the inputs are first
multiplied by -1, so that all objectives are to be minimized. Then, it computes
g(y) (which should be minimized), and returns -g(y), which should be maximized.</p>
<p>Minimizing an objective is supported by passing a negative
weight for that objective. To make all w * y’s have the same sign
such that they are comparable when computing max(w * y), outcomes of minimization
objectives are shifted from [0,1] to [-1,0].</p>
<p>See <a class="reference internal" href="#knowles2005" id="id20"><span>[Knowles2005]</span></a> for details.</p>
<p>This scalarization can be used with qExpectedImprovement to implement q-ParEGO
as proposed in <a class="reference internal" href="acquisition.html#daulton2020qehvi" id="id21"><span>[Daulton2020qehvi]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<em>Tensor</em>) – A <cite>m</cite>-dim tensor of weights.
Positive for maximization and negative for minimization.</p></li>
<li><p><strong>Y</strong> (<em>Tensor</em>) – A <cite>n x m</cite>-dim tensor of observed outcomes, which are used for
scaling the outcomes to [0,1] or [-1,0]. If <cite>n=0</cite>, then outcomes
are left unnormalized.</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – Parameter governing the influence of the weighted sum term. The
default value comes from <a class="reference internal" href="#knowles2005" id="id22"><span>[Knowles2005]</span></a>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transform function using the objective weights.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Callable</em>[[<em>Tensor</em>, <em>Tensor</em> | None], <em>Tensor</em>]</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.75</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span> <span class="o">=</span> <span class="n">get_aug_chebyshev_scalarization</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<section id="probability-utilities">
<h3>Probability Utilities<a class="headerlink" href="#probability-utilities" title="Link to this heading"></a></h3>
</section>
</section>
<section id="module-botorch.utils.probability.mvnxpb">
<span id="multivariate-gaussian-probabilities-via-bivariate-conditioning"></span><h2>Multivariate Gaussian Probabilities via Bivariate Conditioning<a class="headerlink" href="#module-botorch.utils.probability.mvnxpb" title="Link to this heading"></a></h2>
<p>Bivariate conditioning algorithm for approximating Gaussian probabilities,
see <a class="reference internal" href="#genz2016numerical" id="id23"><span>[Genz2016numerical]</span></a> and <a class="reference internal" href="#trinh2015bivariate" id="id24"><span>[Trinh2015bivariate]</span></a>.</p>
<div role="list" class="citation-list">
<div class="citation" id="trinh2015bivariate" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Trinh2015bivariate<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id24">1</a>,<a role="doc-backlink" href="#id25">2</a>)</span>
<p>G. Trinh and A. Genz. Bivariate conditioning approximations for
multivariate normal probabilities. Statistics and Computing, 2015.</p>
</div>
<div class="citation" id="genz2016numerical" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id23">Genz2016numerical</a><span class="fn-bracket">]</span></span>
<p>A. Genz and G. Tring. Numerical Computation of Multivariate Normal Probabilities
using Bivariate Conditioning. Monte Carlo and Quasi-Monte Carlo Methods, 2016.</p>
</div>
<div class="citation" id="gibson1994monte" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id26">Gibson1994monte</a><span class="fn-bracket">]</span></span>
<p>GJ. Gibson, CA Galsbey, and DA Elston. Monte Carlo evaluation of multivariate normal
integrals and sensitivity to variate ordering. Advances in Numerical Methods and
Applications. 1994.</p>
</div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.mvnxpb.</span></span><span class="sig-name descname"><span class="pre">mvnxpbState</span></span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#mvnxpbState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">TypedDict</span></code></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.step">
<span class="sig-name descname"><span class="pre">step</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.step" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.perm">
<span class="sig-name descname"><span class="pre">perm</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">LongTensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.perm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.bounds">
<span class="sig-name descname"><span class="pre">bounds</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.bounds" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.piv_chol">
<span class="sig-name descname"><span class="pre">piv_chol</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><span class="pre">PivotedCholesky</span></a></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.piv_chol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.plug_ins">
<span class="sig-name descname"><span class="pre">plug_ins</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.plug_ins" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.log_prob" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.mvnxpbState.log_prob_extra">
<span class="sig-name descname"><span class="pre">log_prob_extra</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.probability.mvnxpb.mvnxpbState.log_prob_extra" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.mvnxpb.</span></span><span class="sig-name descname"><span class="pre">MVNXPB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An algorithm for approximating Gaussian probabilities <cite>P(X in bounds)</cite>, where
<cite>X ~ N(0, covariance_matrix)</cite>.</p>
<p>Initializes an MVNXPB instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em>) – Covariance matrices of shape <cite>batch_shape x [n, n]</cite>.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – Tensor of lower and upper bounds, <cite>batch_shape x [n, 2]</cite>. These
bounds are standardized internally and clipped to STANDARDIZED_RANGE.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.build">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piv_chol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plug_ins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_prob</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_prob_extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.build"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.build" title="Link to this definition"></a></dt>
<dd><p>Creates an MVNXPB instance from raw arguments. Unlike MVNXPB.__init__,
this methods does not preprocess or copy terms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step</strong> (<em>int</em>) – Integer used to track the solver’s progress.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – Tensor of lower and upper bounds, <cite>batch_shape x [n, 2]</cite>.</p></li>
<li><p><strong>piv_chol</strong> (<a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a>) – A PivotedCholesky instance for the system.</p></li>
<li><p><strong>plug_ins</strong> (<em>Tensor</em>) – Tensor of plug-in estimators used to update lower and upper bounds
on random variables that have yet to be integrated out.</p></li>
<li><p><strong>log_prob</strong> (<em>Tensor</em>) – Tensor of log probabilities.</p></li>
<li><p><strong>log_prob_extra</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Tensor of conditional log probabilities for the next random
variable. Used when integrating over an odd number of random variables.</p></li>
<li><p><strong>perm</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.solve" title="Link to this definition"></a></dt>
<dd><p>Runs the MVNXPB solver instance for a fixed number of steps.</p>
<p>Calculates a bivariate conditional approximation to P(X in bounds), where
X ~ N(0, Σ). For details, see [Genz2016numerical] or <a class="reference internal" href="#trinh2015bivariate" id="id25"><span>[Trinh2015bivariate]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_steps</strong> (<em>int</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>eps</strong> (<em>float</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.select_pivot">
<span class="sig-name descname"><span class="pre">select_pivot</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.select_pivot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.select_pivot" title="Link to this definition"></a></dt>
<dd><p>GGE variable prioritization strategy from <a class="reference internal" href="#gibson1994monte" id="id26"><span>[Gibson1994monte]</span></a>.</p>
<p>Returns the index of the random variable least likely to satisfy its bounds
when conditioning on the previously integrated random variables <cite>X[:t - 1]</cite>
attaining the values of plug-in estimators <cite>y[:t - 1]</cite>. Equivalently,
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">argmin_{i</span> <span class="pre">=</span> <span class="pre">t,</span> <span class="pre">...,</span> <span class="pre">n}</span> <span class="pre">P(X[i]</span> <span class="pre">\in</span> <span class="pre">bounds[i]</span> <span class="pre">|</span> <span class="pre">X[:t-1]</span> <span class="pre">=</span> <span class="pre">y[:t</span> <span class="pre">-1]),</span>
<span class="pre">`</span></code>
where <cite>t</cite> denotes the current step.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>LongTensor</em> | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.pivot_">
<span class="sig-name descname"><span class="pre">pivot_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pivot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.pivot_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.pivot_" title="Link to this definition"></a></dt>
<dd><p>Swap random variables at <cite>pivot</cite> and <cite>step</cite> positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pivot</strong> (<em>LongTensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.concat" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a>)</p></li>
<li><p><strong>dim</strong> (<em>int</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">sizes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.expand" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sizes</strong> (<em>int</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.augment">
<span class="sig-name descname"><span class="pre">augment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disable_pivoting</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_tries</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.augment"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.augment" title="Link to this definition"></a></dt>
<dd><p>Augment an <cite>n</cite>-dimensional MVNXPB instance to include <cite>m</cite> additional random
variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>cross_covariance_matrix</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>disable_pivoting</strong> (<em>bool</em>)</p></li>
<li><p><strong>jitter</strong> (<em>float</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>max_tries</strong> (<em>int</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.detach">
<span class="sig-name descname"><span class="pre">detach</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.detach"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.detach" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.mvnxpb.MVNXPB.asdict">
<span class="sig-name descname"><span class="pre">asdict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/mvnxpb.html#MVNXPB.asdict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.mvnxpb.MVNXPB.asdict" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.mvnxpb.mvnxpbState" title="botorch.utils.probability.mvnxpb.mvnxpbState"><em>mvnxpbState</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.probability.truncated_multivariate_normal">
<span id="truncated-multivariate-normal-distribution"></span><h2>Truncated Multivariate Normal Distribution<a class="headerlink" href="#module-botorch.utils.probability.truncated_multivariate_normal" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.truncated_multivariate_normal.</span></span><span class="sig-name descname"><span class="pre">TruncatedMultivariateNormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_tril</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultivariateNormal</span></code></p>
<p>Initializes an instance of a TruncatedMultivariateNormal distribution.</p>
<p>Let <cite>x ~ N(0, K)</cite> be an <cite>n</cite>-dimensional Gaussian random vector. This class
represents the distribution of the truncated Multivariate normal random vector
<cite>x | a &lt;= x &lt;= b</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>Tensor</em>) – A mean vector for the distribution, <cite>batch_shape x event_shape</cite>.</p></li>
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Covariance matrix distribution parameter.</p></li>
<li><p><strong>precision_matrix</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Inverse covariance matrix distribution parameter.</p></li>
<li><p><strong>scale_tril</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Lower triangular, square-root covariance matrix distribution
parameter.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em>) – A <cite>batch_shape x event_shape x 2</cite> tensor of strictly increasing
bounds for <cite>x</cite> so that <cite>bounds[…, 0] &lt; bounds[…, 1]</cite> everywhere.</p></li>
<li><p><strong>solver</strong> (<a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><em>MVNXPB</em></a><em> | </em><em>None</em>) – A pre-solved MVNXPB instance used to approximate the log partition.</p></li>
<li><p><strong>sampler</strong> (<a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler" title="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler"><em>LinearEllipticalSliceSampler</em></a><em> | </em><em>None</em>) – A LinearEllipticalSliceSampler instance used for sample generation.</p></li>
<li><p><strong>validate_args</strong> (<em>bool</em><em> | </em><em>None</em>) – Optional argument to super().__init__.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal.log_prob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_prob" title="Link to this definition"></a></dt>
<dd><p>Approximates the true log probability.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.rsample" title="Link to this definition"></a></dt>
<dd><p>Draw samples from the Truncated Multivariate Normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sample_shape</strong> (<em>Size</em>) – The shape of the samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The (sample_shape x batch_shape x event_shape) tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_partition">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">log_partition</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.log_partition" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.solver">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solver</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.probability.mvnxpb.MVNXPB" title="botorch.utils.probability.mvnxpb.MVNXPB"><span class="pre">MVNXPB</span></a></em><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.solver" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.sampler">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sampler</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler" title="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler"><span class="pre">LinearEllipticalSliceSampler</span></a></em><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.sampler" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/truncated_multivariate_normal.html#TruncatedMultivariateNormal.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal.expand" title="Link to this definition"></a></dt>
<dd><p>Returns a new distribution instance (or populates an existing instance
provided by a derived class) with batch dimensions expanded to
<cite>batch_shape</cite>. This method calls <code class="xref py py-class docutils literal notranslate"><span class="pre">expand</span></code> on
the distribution’s parameters. As such, this does not allocate new
memory for the expanded distribution instance. Additionally,
this does not repeat any args checking or parameter broadcasting in
<cite>__init__.py</cite>, when an instance is first created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>torch.Size</em>) – the desired expanded size.</p></li>
<li><p><strong>_instance</strong> (<a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><em>TruncatedMultivariateNormal</em></a>) – new instance provided by subclasses that
need to override <cite>.expand</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New distribution instance with batch dimensions expanded to
<cite>batch_size</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><em>TruncatedMultivariateNormal</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.probability.unified_skew_normal">
<span id="unified-skew-normal-distribution"></span><h2>Unified Skew Normal Distribution<a class="headerlink" href="#module-botorch.utils.probability.unified_skew_normal" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.unified_skew_normal.</span></span><span class="sig-name descname"><span class="pre">UnifiedSkewNormal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cross_covariance_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Distribution</span></code></p>
<p>Unified Skew Normal distribution of <cite>Y | a &lt; X &lt; b</cite> for jointly Gaussian
random vectors <cite>X ∈ R^m</cite> and <cite>Y ∈ R^n</cite>.</p>
<p>Batch shapes <cite>trunc.batch_shape</cite> and <cite>gauss.batch_shape</cite> must be broadcastable.
Care should be taken when choosing <cite>trunc.batch_shape</cite>. When <cite>trunc</cite> is of lower
batch dimensionality than <cite>gauss</cite>, the user should consider expanding <cite>trunc</cite> to
hasten <cite>UnifiedSkewNormal.log_prob</cite>. In these cases, it is suggested that the
user invoke <cite>trunc.solver</cite> before calling <cite>trunc.expand</cite> to avoid paying for
multiple, identical solves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trunc</strong> (<a class="reference internal" href="#botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal" title="botorch.utils.probability.truncated_multivariate_normal.TruncatedMultivariateNormal"><em>TruncatedMultivariateNormal</em></a>) – Distribution of <cite>Z = (X | a &lt; X &lt; b) ∈ R^m</cite>.</p></li>
<li><p><strong>gauss</strong> (<em>MultivariateNormal</em>) – Distribution of <cite>Y ∈ R^n</cite>.</p></li>
<li><p><strong>cross_covariance_matrix</strong> (<em>Tensor</em><em> | </em><em>LinearOperator</em>) – Cross-covariance <cite>Cov(X, Y) ∈ R^{m x n}</cite>.</p></li>
<li><p><strong>validate_args</strong> (<em>bool</em><em> | </em><em>None</em>) – Optional argument to super().__init__.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.arg_constraints">
<span class="sig-name descname"><span class="pre">arg_constraints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.arg_constraints" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.log_prob">
<span class="sig-name descname"><span class="pre">log_prob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal.log_prob"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.log_prob" title="Link to this definition"></a></dt>
<dd><p>Computes the log probability <cite>ln p(Y = value | a &lt; X &lt; b)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.rsample">
<span class="sig-name descname"><span class="pre">rsample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal.rsample"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.rsample" title="Link to this definition"></a></dt>
<dd><p>Draw samples from the Unified Skew Normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sample_shape</strong> (<em>Size</em>) – The shape of the samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The (sample_shape x batch_shape x event_shape) tensor of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_instance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/unified_skew_normal.html#UnifiedSkewNormal.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.expand" title="Link to this definition"></a></dt>
<dd><p>Returns a new distribution instance (or populates an existing instance
provided by a derived class) with batch dimensions expanded to
<cite>batch_shape</cite>. This method calls <code class="xref py py-class docutils literal notranslate"><span class="pre">expand</span></code> on
the distribution’s parameters. As such, this does not allocate new
memory for the expanded distribution instance. Additionally,
this does not repeat any args checking or parameter broadcasting in
<cite>__init__.py</cite>, when an instance is first created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch_shape</strong> (<em>torch.Size</em>) – the desired expanded size.</p></li>
<li><p><strong>_instance</strong> (<a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal" title="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal"><em>UnifiedSkewNormal</em></a>) – new instance provided by subclasses that
need to override <cite>.expand</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>New distribution instance with batch dimensions expanded to
<cite>batch_size</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal" title="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal"><em>UnifiedSkewNormal</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.covariance_matrix">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">covariance_matrix</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.covariance_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.scale_tril">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">scale_tril</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.unified_skew_normal.UnifiedSkewNormal.scale_tril" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.probability.bvn">
<span id="bivariate-normal-probabilities-and-statistics"></span><h2>Bivariate Normal Probabilities and Statistics<a class="headerlink" href="#module-botorch.utils.probability.bvn" title="Link to this heading"></a></h2>
<p>Methods for computing bivariate normal probabilities and statistics.</p>
<div role="list" class="citation-list">
<div class="citation" id="genz2004bvnt" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Genz2004bvnt<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id27">1</a>,<a role="doc-backlink" href="#id28">2</a>,<a role="doc-backlink" href="#id29">3</a>)</span>
<p>A. Genz. Numerical computation of rectangular bivariate and trivariate normal and
t probabilities. Statistics and Computing, 2004.</p>
</div>
<div class="citation" id="muthen1990moments" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id30">Muthen1990moments</a><span class="fn-bracket">]</span></span>
<p>B. Muthen. Moments of the censored and truncated bivariate normal distribution.
British Journal of Mathematical and Statistical Psychology, 1990.</p>
</div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.bvn.bvn">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.bvn.</span></span><span class="sig-name descname"><span class="pre">bvn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yu</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/bvn.html#bvn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.bvn.bvn" title="Link to this definition"></a></dt>
<dd><p>A function for computing bivariate normal probabilities.</p>
<p>Calculates <cite>P(xl &lt; x &lt; xu, yl &lt; y &lt; yu)</cite> where <cite>x</cite> and <cite>y</cite> are bivariate normal with
unit variance and correlation coefficient <cite>r</cite>. See Section 2.4 of <a class="reference internal" href="#genz2004bvnt" id="id27"><span>[Genz2004bvnt]</span></a>.</p>
<p>This method uses a sign flip trick to improve numerical performance. Many of <cite>bvnu`s
internal branches rely on evaluations `Phi(-bound)</cite>. For <cite>a &lt; b &lt; 0</cite>, the term
<cite>Phi(-a) - Phi(-b)</cite> goes to zero faster than <cite>Phi(b) - Phi(a)</cite> because
<cite>finfo(dtype).epsneg</cite> is typically much larger than <cite>finfo(dtype).tiny</cite>. In these
cases, flipping the sign can prevent situations where <cite>bvnu(…) - bvnu(…)</cite> would
otherwise be zero due to round-off error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>Tensor</em>) – Tensor of correlation coefficients.</p></li>
<li><p><strong>xl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>xu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor of probabilities <cite>P(xl &lt; x &lt; xu, yl &lt; y &lt; yu)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.bvn.bvnu">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.bvn.</span></span><span class="sig-name descname"><span class="pre">bvnu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/bvn.html#bvnu"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.bvn.bvnu" title="Link to this definition"></a></dt>
<dd><p>Solves for <cite>P(x &gt; h, y &gt; k)</cite> where <cite>x</cite> and <cite>y</cite> are standard bivariate normal
random variables with correlation coefficient <cite>r</cite>. In <a class="reference internal" href="#genz2004bvnt" id="id28"><span>[Genz2004bvnt]</span></a>, this is (1)</p>
<blockquote>
<div><p><cite>L(h, k, r) = P(x &lt; -h, y &lt; -k) = 1/(a 2pi) int_{h}^{infty} int_{k}^{infty} f(x, y, r) dy dx,</cite></p>
</div></blockquote>
<p>where <cite>f(x, y, r) = e^{-1/(2a^2) (x^2 - 2rxy + y^2)}</cite> and <cite>a = (1 - r^2)^{1/2}</cite>.</p>
<p><a class="reference internal" href="#genz2004bvnt" id="id29"><span>[Genz2004bvnt]</span></a> report the following integation scheme incurs a maximum of 5e-16
error when run in double precision: if <cite>|r| &gt;= 0.925</cite>, use a 20-point quadrature
rule on a 5th order Taylor expansion; else, numerically integrate in polar
coordinates using no more than 20 quadrature points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>Tensor</em>) – Tensor of correlation coefficients.</p></li>
<li><p><strong>h</strong> (<em>Tensor</em>) – Tensor of negative upper bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>k</strong> (<em>Tensor</em>) – Tensor of negative upper bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of probabilities <cite>P(x &gt; h, y &gt; k)</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.bvn.bvnmom">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.bvn.</span></span><span class="sig-name descname"><span class="pre">bvnmom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/bvn.html#bvnmom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.bvn.bvnmom" title="Link to this definition"></a></dt>
<dd><p>Computes the expected values of truncated, bivariate normal random variables.</p>
<p>Let <cite>x</cite> and <cite>y</cite> be a pair of standard bivariate normal random variables having
correlation <cite>r</cite>. This function computes <cite>E([x,y] | [xl,yl] &lt; [x,y] &lt; [xu,yu])</cite>.</p>
<p>Following <a class="reference internal" href="#muthen1990moments" id="id30"><span>[Muthen1990moments]</span></a> equations (4) and (5), we have</p>
<blockquote>
<div><p><cite>E(x | [xl, yl] &lt; [x, y] &lt; [xu, yu]) = Z^{-1} phi(xl) P(yl &lt; y &lt; yu | x=xl) - phi(xu) P(yl &lt; y &lt; yu | x=xu),</cite></p>
</div></blockquote>
<p>where <cite>Z = P([xl, yl] &lt; [x, y] &lt; [xu, yu])</cite> and <cite>phi</cite> is the standard normal PDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<em>Tensor</em>) – Tensor of correlation coefficients.</p></li>
<li><p><strong>xl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>xu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>x</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yl</strong> (<em>Tensor</em>) – Tensor of lower bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>yu</strong> (<em>Tensor</em>) – Tensor of upper bounds for <cite>y</cite>, same shape as <cite>r</cite>.</p></li>
<li><p><strong>p</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Tensor of probabilities <cite>P(xl &lt; x &lt; xu, yl &lt; y &lt; yu)</cite>, same shape as <cite>r</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><cite>E(x | [xl, yl] &lt; [x, y] &lt; [xu, yu])</cite> and
<cite>E(y | [xl, yl] &lt; [x, y] &lt; [xu, yu])</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.probability.lin_ess">
<span id="elliptic-slice-sampler-with-linear-constraints"></span><h2>Elliptic Slice Sampler with Linear Constraints<a class="headerlink" href="#module-botorch.utils.probability.lin_ess" title="Link to this heading"></a></h2>
<p>Linear Elliptical Slice Sampler.</p>
<p>References</p>
<div role="list" class="citation-list">
<div class="citation" id="gessner2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id31">Gessner2020</a><span class="fn-bracket">]</span></span>
<p>A. Gessner, O. Kanjilal, and P. Hennig. Integrals over gaussians under
linear domain constraints. AISTATS 2020.</p>
</div>
<div class="citation" id="wu2024" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id32">Wu2024</a><span class="fn-bracket">]</span></span>
<p>K. Wu, and J. Gardner. A Fast, Robust Elliptical Slice Sampling Implementation for
Linearly Truncated Multivariate Normal Distributions. arXiv:2407.10449. 2024.</p>
</div>
</div>
<p>This implementation is based (with multiple changes / optimiations) on
the following implementations based on the algorithm in <a class="reference internal" href="#gessner2020" id="id31"><span>[Gessner2020]</span></a>:
- <a class="reference external" href="https://github.com/alpiges/LinConGauss">https://github.com/alpiges/LinConGauss</a>
- <a class="reference external" href="https://github.com/wjmaddox/pytorch_ess">https://github.com/wjmaddox/pytorch_ess</a></p>
<p>In addition, the active intervals (from which the angle is sampled) are computed using
the improved algorithm described in <a class="reference internal" href="#wu2024" id="id32"><span>[Wu2024]</span></a>:
<a class="reference external" href="https://github.com/kayween/linear-ess">https://github.com/kayween/linear-ess</a></p>
<p>The implementation here differentiates itself from the original implementations with:
1) Support for fixed feature equality constraints.
2) Support for non-standard Normal distributions.
3) Numerical stability improvements, especially relevant for high-dimensional cases.
4) Support multiple Markov chains running in parallel.</p>
<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.lin_ess.</span></span><span class="sig-name descname"><span class="pre">LinearEllipticalSliceSampler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inequality_constraints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interior_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covariance_root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check_feasibility</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">burnin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thinning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_chains</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#LinearEllipticalSliceSampler"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#botorch.utils.sampling.PolytopeSampler" title="botorch.utils.sampling.PolytopeSampler"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolytopeSampler</span></code></a></p>
<p>Linear Elliptical Slice Sampler.</p>
<p>Ideas:
- Optimize computations if possible, potentially with torch.compile.
- Extend fixed features constraint to general linear equality constraints.</p>
<p>Initialize LinearEllipticalSliceSampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inequality_constraints</strong> (<em>tuple</em><em>[</em><em>Tensor</em><em>, </em><em>Tensor</em><em>] </em><em>| </em><em>None</em>) – Tensors <cite>(A, b)</cite> describing inequality constraints
<cite>A &#64; x &lt;= b</cite>, where <cite>A</cite> is an <cite>n_ineq_con x d</cite>-dim Tensor and <cite>b</cite> is
an <cite>n_ineq_con x 1</cite>-dim Tensor, with <cite>n_ineq_con</cite> the number of
inequalities and <cite>d</cite> the dimension of the sample space. If omitted,
must provide <cite>bounds</cite> instead.</p></li>
<li><p><strong>bounds</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>2 x d</cite>-dim tensor of box bounds. If omitted, must provide
<cite>inequality_constraints</cite> instead.</p></li>
<li><p><strong>interior_point</strong> (<em>Tensor</em><em> | </em><em>None</em>) – A <cite>d x 1</cite>-dim Tensor presenting a point in the (relative)
interior of the polytope. If omitted, an interior point is determined
automatically by solving a Linear Program. Note: It is crucial that
the point lie in the interior of the feasible set (rather than on the
boundary), otherwise the sampler will produce invalid samples.</p></li>
<li><p><strong>fixed_indices</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>Tensor</em><em> | </em><em>None</em>) – Integer list or <cite>d</cite>-dim Tensor representing the indices of
dimensions that are constrained to be fixed to the values specified in
the <cite>interior_point</cite>, which is required to be passed in conjunction with
<cite>fixed_indices</cite>.</p></li>
<li><p><strong>mean</strong> (<em>Tensor</em><em> | </em><em>None</em>) – The <cite>d x 1</cite>-dim mean of the MVN distribution (if omitted, use zero).</p></li>
<li><p><strong>covariance_matrix</strong> (<em>Tensor</em><em> | </em><em>LinearOperator</em><em> | </em><em>None</em>) – The <cite>d x d</cite>-dim covariance matrix of the MVN
distribution (if omitted, use the identity).</p></li>
<li><p><strong>covariance_root</strong> (<em>Tensor</em><em> | </em><em>LinearOperator</em><em> | </em><em>None</em>) – A <cite>d x d</cite>-dim root of the covariance matrix such that
covariance_root &#64; covariance_root.T = covariance_matrix. NOTE: This
matrix is assumed to be lower triangular. covariance_root can only be
passed in conjunction with fixed_indices if covariance_root is a
DiagLinearOperator. Otherwise the factorization would need to be re-
computed, as we need to solve in <cite>standardize</cite>.</p></li>
<li><p><strong>check_feasibility</strong> (<em>bool</em>) – If True, raise an error if the sampling results in an
infeasible sample. This creates some overhead and so is switched off
by default.</p></li>
<li><p><strong>burnin</strong> (<em>int</em>) – Number of samples to generate upon initialization to warm up the
sampler.</p></li>
<li><p><strong>thinning</strong> (<em>int</em>) – Number of samples to skip before returning a sample in <cite>draw</cite>.</p></li>
<li><p><strong>num_chains</strong> (<em>int</em>) – Number of Markov chains to run in parallel.</p></li>
</ul>
</dd>
</dl>
<p>This sampler samples from a multivariante Normal <cite>N(mean, covariance_matrix)</cite>
subject to linear domain constraints <cite>A x &lt;= b</cite> (intersected with box bounds,
if provided).</p>
<dl class="py property">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.lifetime_samples">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lifetime_samples</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.lifetime_samples" title="Link to this definition"></a></dt>
<dd><p>The total number of samples generated by the sampler during its lifetime.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.draw">
<span class="sig-name descname"><span class="pre">draw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#LinearEllipticalSliceSampler.draw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.draw" title="Link to this definition"></a></dt>
<dd><p>Draw samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of samples.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>(n * num_chains) x d</cite>-dim tensor of <cite>n * num_chains</cite> samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#LinearEllipticalSliceSampler.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.LinearEllipticalSliceSampler.step" title="Link to this definition"></a></dt>
<dd><p>Take a step, return the new sample, update the internal state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A <cite>d x num_chains</cite>-dim tensor, where each column is a sample from a Markov
chain.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.lin_ess.get_index_tensors">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.lin_ess.</span></span><span class="sig-name descname"><span class="pre">get_index_tensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fixed_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/lin_ess.html#get_index_tensors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.lin_ess.get_index_tensors" title="Link to this definition"></a></dt>
<dd><p>Converts <cite>fixed_indices</cite> to a <cite>d</cite>-dim integral Tensor that is True at indices
that are contained in <cite>fixed_indices</cite> and False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fixed_indices</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>Tensor</em>) – A list or Tensoro of integer indices to fix.</p></li>
<li><p><strong>d</strong> (<em>int</em>) – The dimensionality of the Tensors to be indexed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tuple of integral Tensors partitioning [1, d] into indices that are fixed
(first tensor) and non-fixed (second tensor).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-botorch.utils.probability.linalg">
<span id="linear-algebra-helpers"></span><h2>Linear Algebra Helpers<a class="headerlink" href="#module-botorch.utils.probability.linalg" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.block_matrix_concat">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.linalg.</span></span><span class="sig-name descname"><span class="pre">block_matrix_concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#block_matrix_concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.block_matrix_concat" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>blocks</strong> (<em>Sequence</em><em>[</em><em>Sequence</em><em>[</em><em>Tensor</em><em>]</em><em>]</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.augment_cholesky">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.linalg.</span></span><span class="sig-name descname"><span class="pre">augment_cholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Laa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kbb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Kba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jitter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#augment_cholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.augment_cholesky" title="Link to this definition"></a></dt>
<dd><p>Computes the Cholesky factor of a block matrix <cite>K = [[Kaa, Kab], [Kba, Kbb]]</cite>
based on a precomputed Cholesky factor <cite>Kaa = Laa Laa^T</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Laa</strong> (<em>Tensor</em>) – Cholesky factor of K’s upper left block.</p></li>
<li><p><strong>Kbb</strong> (<em>Tensor</em>) – Lower-right block of K.</p></li>
<li><p><strong>Kba</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Lower-left block of K.</p></li>
<li><p><strong>Lba</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Precomputed solve <cite>Kba Laa^{-T}</cite>.</p></li>
<li><p><strong>jitter</strong> (<em>float</em><em> | </em><em>None</em>) – Optional nugget to be added to the diagonal of Kbb.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.linalg.</span></span><span class="sig-name descname"><span class="pre">PivotedCholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'int'</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tril</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'Tensor'</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">perm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'LongTensor'</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'Tensor</span> <span class="pre">|</span> <span class="pre">None'</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">validate_init</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="s"><span class="pre">'InitVar[bool]'</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>step</strong> (<em>int</em>)</p></li>
<li><p><strong>tril</strong> (<em>Tensor</em>)</p></li>
<li><p><strong>perm</strong> (<em>LongTensor</em>)</p></li>
<li><p><strong>diag</strong> (<em>Tensor</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>validate_init</strong> (<em>dataclasses.InitVar</em><em>[</em><em>bool</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.step">
<span class="sig-name descname"><span class="pre">step</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.step" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.tril">
<span class="sig-name descname"><span class="pre">tril</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.tril" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.perm">
<span class="sig-name descname"><span class="pre">perm</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">LongTensor</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.perm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.diag">
<span class="sig-name descname"><span class="pre">diag</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Tensor</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.diag" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.validate_init">
<span class="sig-name descname"><span class="pre">validate_init</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dataclasses.InitVar</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></em><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.validate_init" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.update_">
<span class="sig-name descname"><span class="pre">update_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.update_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.update_" title="Link to this definition"></a></dt>
<dd><p>Performs a single matrix decomposition step.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eps</strong> (<em>float</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.pivot_">
<span class="sig-name descname"><span class="pre">pivot_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pivot</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.pivot_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.pivot_" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pivot</strong> (<em>LongTensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.expand">
<span class="sig-name descname"><span class="pre">expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">sizes</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.expand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.expand" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sizes</strong> (<em>int</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.concat">
<span class="sig-name descname"><span class="pre">concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.concat" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a>)</p></li>
<li><p><strong>dim</strong> (<em>int</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.detach">
<span class="sig-name descname"><span class="pre">detach</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.detach"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.detach" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="botorch.utils.probability.linalg.PivotedCholesky.clone">
<span class="sig-name descname"><span class="pre">clone</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/linalg.html#PivotedCholesky.clone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.linalg.PivotedCholesky.clone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#botorch.utils.probability.linalg.PivotedCholesky" title="botorch.utils.probability.linalg.PivotedCholesky"><em>PivotedCholesky</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-botorch.utils.probability.utils">
<span id="probability-helpers"></span><h2>Probability Helpers<a class="headerlink" href="#module-botorch.utils.probability.utils" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.case_dispatcher">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">case_dispatcher</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cases</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#case_dispatcher"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.case_dispatcher" title="Link to this definition"></a></dt>
<dd><p>Basic implementation of a tensorized switching case statement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out</strong> (<em>Tensor</em>) – Tensor to which case outcomes are written.</p></li>
<li><p><strong>cases</strong> (<em>Iterable</em><em>[</em><em>tuple</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>]</em><em>, </em><em>BoolTensor</em><em>]</em><em>, </em><em>Callable</em><em>[</em><em>[</em><em>BoolTensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em><em>]</em><em>]</em>) – Iterable of function pairs (pred, func), where <cite>mask=pred()</cite> specifies
whether <cite>func</cite> is applicable for each entry in <cite>out</cite>. Note that cases are
resolved first-come, first-serve.</p></li>
<li><p><strong>default</strong> (<em>Callable</em><em>[</em><em>[</em><em>BoolTensor</em><em>]</em><em>, </em><em>Tensor</em><em>]</em>) – Optional <cite>func</cite> to which all unclaimed entries of <cite>out</cite> are dispatched.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.get_constants">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">get_constants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#get_constants"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.get_constants" title="Link to this definition"></a></dt>
<dd><p>Returns scalar-valued Tensors containing each of the given constants.
Used to expedite tensor operations involving scalar arithmetic. Note that
the returned Tensors should not be modified in-place.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>)</p></li>
<li><p><strong>dtype</strong> (<em>dtype</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | tuple[<em>Tensor</em>, …]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.get_constants_like">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">get_constants_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#get_constants_like"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.get_constants_like" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Number</em><em> | </em><em>Iterator</em><em>[</em><em>Number</em><em>]</em>)</p></li>
<li><p><strong>ref</strong> (<em>Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em> | <em>Iterator</em>[<em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.gen_positional_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">gen_positional_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#gen_positional_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.gen_positional_indices" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>Size</em>)</p></li>
<li><p><strong>dim</strong> (<em>int</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Iterator</em>[<em>LongTensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.build_positional_indices">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">build_positional_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">device</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#build_positional_indices"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.build_positional_indices" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shape</strong> (<em>Size</em>)</p></li>
<li><p><strong>dim</strong> (<em>int</em>)</p></li>
<li><p><strong>device</strong> (<em>device</em><em> | </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>LongTensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.leggauss">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">leggauss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">tkwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#leggauss"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.leggauss" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>deg</strong> (<em>int</em>)</p></li>
<li><p><strong>tkwargs</strong> (<em>Any</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<em>Tensor</em>, <em>Tensor</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.ndtr">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">ndtr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#ndtr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.ndtr" title="Link to this definition"></a></dt>
<dd><p>Standard normal CDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.phi">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#phi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.phi" title="Link to this definition"></a></dt>
<dd><p>Standard normal PDF.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_phi">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_phi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_phi"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_phi" title="Link to this definition"></a></dt>
<dd><p>Logarithm of standard normal pdf</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_ndtr">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_ndtr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_ndtr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_ndtr" title="Link to this definition"></a></dt>
<dd><p>Implementation of log_ndtr that remedies problems of torch.special’s version
for large negative x, where the torch implementation yields Inf or NaN gradients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – An input tensor with dtype torch.float32 or torch.float64.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of values of the same type and shape as x containing log(ndtr(x)).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_erfc">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_erfc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_erfc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_erfc" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the complementary error function in a numerically
stable manner. The GitHub issue <a class="reference external" href="https://github.com/pytorch/pytorch/issues/31945">https://github.com/pytorch/pytorch/issues/31945</a>
tracks progress toward moving this feature into PyTorch in C++.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – An input tensor with dtype torch.float32 or torch.float64.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of values of the same type and shape as x containing log(erfc(x)).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_erfcx">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_erfcx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_erfcx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_erfcx" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the complementary scaled error function in a
numerically stable manner. The GitHub issue tracks progress toward moving this
feature into PyTorch in C++: <a class="reference external" href="https://github.com/pytorch/pytorch/issues/31945">https://github.com/pytorch/pytorch/issues/31945</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – An input tensor with dtype torch.float32 or torch.float64.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tensor of values of the same type and shape as x containing log(erfcx(x)).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.standard_normal_log_hazard">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">standard_normal_log_hazard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#standard_normal_log_hazard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.standard_normal_log_hazard" title="Link to this definition"></a></dt>
<dd><p>Computes the logarithm of the hazard function of the standard normal
distribution, i.e. <cite>log(phi(x) / Phi(-x))</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>Tensor</em>) – A tensor of any shape, with either float32 or float64 dtypes.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A Tensor of the same shape <cite>x</cite>, containing the values of the logarithm of the
hazard function evaluated at <cite>x</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.log_prob_normal_in">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">log_prob_normal_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#log_prob_normal_in"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.log_prob_normal_in" title="Link to this definition"></a></dt>
<dd><p>Computes the probability that a standard normal random variable takes a value
in [a, b], i.e. log(Phi(b) - Phi(a)), where Phi is the standard normal CDF.
Returns accurate values and permits numerically stable backward passes for inputs
in [-1e100, 1e100] for double precision and [-1e20, 1e20] for single precision.
In contrast, a naive approach is not numerically accurate beyond [-10, 10].</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>Tensor</em>) – Tensor of lower integration bounds of the Gaussian probability measure.</p></li>
<li><p><strong>b</strong> (<em>Tensor</em>) – Tensor of upper integration bounds of the Gaussian probability measure.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tensor of the log probabilities.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.swap_along_dim_">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">swap_along_dim_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#swap_along_dim_"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.swap_along_dim_" title="Link to this definition"></a></dt>
<dd><p>Swaps Tensor slices in-place along dimension <cite>dim</cite>.</p>
<p>When passed as Tensors, <cite>i</cite> (and <cite>j</cite>) should be <cite>dim</cite>-dimensional tensors
with the same shape as <cite>values.shape[:dim]</cite>. The xception to this rule occurs
when <cite>dim=0</cite>, in which case <cite>i</cite> (and <cite>j</cite>) should be (at most) one-dimensional
when passed as a Tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values</strong> (<em>Tensor</em>) – Tensor whose values are to be swapped.</p></li>
<li><p><strong>i</strong> (<em>int</em><em> | </em><em>LongTensor</em>) – Indices for slices along dimension <cite>dim</cite>.</p></li>
<li><p><strong>j</strong> (<em>int</em><em> | </em><em>LongTensor</em>) – Indices for slices along dimension <cite>dim</cite>.</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of <cite>values</cite> along which to swap slices.</p></li>
<li><p><strong>buffer</strong> (<em>Tensor</em><em> | </em><em>None</em>) – Optional buffer used internally to store copied values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The original <cite>values</cite> tensor.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.compute_log_prob_feas_from_bounds">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">compute_log_prob_feas_from_bounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">con_lower_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">con_upper_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">con_both_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">con_lower</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">con_upper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">con_both</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">means</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#compute_log_prob_feas_from_bounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.compute_log_prob_feas_from_bounds" title="Link to this definition"></a></dt>
<dd><p>Compute logarithm of the feasibility probability for each batch of mean/sigma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>means</strong> (<em>Tensor</em>) – A <cite>(b) x m</cite>-dim Tensor of means.</p></li>
<li><p><strong>sigmas</strong> (<em>Tensor</em>) – A <cite>(b) x m</cite>-dim Tensor of standard deviations.</p></li>
<li><p><strong>con_lower_inds</strong> (<em>Tensor</em>) – 1d Tensor of indices con_lower applies to
in the second dimension of means and sigmas.</p></li>
<li><p><strong>con_upper_inds</strong> (<em>Tensor</em>) – 1d Tensor of indices con_upper applies to
in the second dimension of means and sigmas.</p></li>
<li><p><strong>con_both_inds</strong> (<em>Tensor</em>) – 1d Tensor of indices con_both applies to
in the second dimension of means and sigmas.</p></li>
<li><p><strong>con_lower</strong> (<em>Tensor</em>) – 1d Tensor of lower bounds on the constraints
equal in dimension to con_lower_inds.</p></li>
<li><p><strong>con_upper</strong> (<em>Tensor</em>) – 1d Tensor of upper bounds on the constraints
equal in dimension to con_upper_inds.</p></li>
<li><p><strong>con_both</strong> (<em>Tensor</em>) – 2d Tensor of “both” bounds on the constraints
equal in length to con_both_inds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>b</cite>-dim tensor of log feasibility probabilities</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="botorch.utils.probability.utils.percentile_of_score">
<span class="sig-prename descclassname"><span class="pre">botorch.utils.probability.utils.</span></span><span class="sig-name descname"><span class="pre">percentile_of_score</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/botorch/utils/probability/utils.html#percentile_of_score"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#botorch.utils.probability.utils.percentile_of_score" title="Link to this definition"></a></dt>
<dd><p>Compute the percentile rank of <cite>score</cite> relative to <cite>data</cite>.
For example, if this function returns 70 then 70% of the
values in <cite>data</cite> are below <cite>score</cite>.</p>
<p>This implementation is based on <cite>scipy.stats.percentileofscore</cite>,
with <cite>kind=’rank’</cite> and <cite>nan_policy=’propagate’</cite>, which is the default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>Tensor</em>) – A <cite>… x n x output_shape</cite>-dim Tensor of data.</p></li>
<li><p><strong>score</strong> (<em>Tensor</em>) – A <cite>… x 1 x output_shape</cite>-dim Tensor of scores.</p></li>
<li><p><strong>dim</strong> (<em>int</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <cite>… x output_shape</cite>-dim Tensor of percentile ranks.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Tensor</em></p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="exceptions.html" class="btn btn-neutral float-left" title="botorch.exceptions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>