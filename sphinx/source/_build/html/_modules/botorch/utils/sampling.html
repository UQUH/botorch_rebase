

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>botorch.utils.sampling &mdash; BoTorch  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=ca3e82f4" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BoTorch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generation.html">botorch.generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_utils.html">botorch.test_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">botorch.utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BoTorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">botorch.utils.sampling</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for botorch.utils.sampling</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utilities for MC and qMC sampling.</span>

<span class="sd">References</span>

<span class="sd">.. [Trikalinos2014polytope]</span>
<span class="sd">    T. A. Trikalinos and G. van Valkenhoef. Efficient sampling from uniform</span>
<span class="sd">    density n-polytopes. Technical report, Brown University, 2014.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">contextlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">contextmanager</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">ceil</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.exceptions.errors</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">BotorchError</span><span class="p">,</span>
    <span class="n">BotorchTensorDimensionError</span><span class="p">,</span>
    <span class="n">InfeasibilityError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.exceptions.warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserInputWarning</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.sampling.qmc</span><span class="w"> </span><span class="kn">import</span> <span class="n">NormalQMCEngine</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.utils.transforms</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">standardize</span><span class="p">,</span> <span class="n">unnormalize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span><span class="p">,</span> <span class="n">HalfspaceIntersection</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">LongTensor</span><span class="p">,</span> <span class="n">Tensor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.distributions</span><span class="w"> </span><span class="kn">import</span> <span class="n">Normal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.quasirandom</span><span class="w"> </span><span class="kn">import</span> <span class="n">SobolEngine</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">botorch.models.deterministic</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>  <span class="c1"># pragma: no cover</span>
        <span class="n">GenericDeterministicModel</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="manual_seed">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.manual_seed">[docs]</a>
<span class="nd">@contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Contextmanager for manual setting the torch.random seed.</span>

<span class="sd">    Args:</span>
<span class="sd">        seed: The seed to set the random number generator to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Generator</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; with manual_seed(1234):</span>
<span class="sd">        &gt;&gt;&gt;     X = torch.rand(3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">old_state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_rng_state</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_rng_state</span><span class="p">(</span><span class="n">old_state</span><span class="p">)</span></div>



<div class="viewcode-block" id="draw_sobol_samples">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.draw_sobol_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">draw_sobol_samples</span><span class="p">(</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">q</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">batch_shape</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Draw qMC samples from the box defined by bounds.</span>

<span class="sd">    Args:</span>
<span class="sd">        bounds: A `2 x d` dimensional tensor specifying box constraints on a</span>
<span class="sd">            `d`-dimensional space, where bounds[0, :] and bounds[1, :] correspond</span>
<span class="sd">            to lower and upper bounds, respectively.</span>
<span class="sd">        n: The number of (q-batch) samples. As a best practice, use powers of 2.</span>
<span class="sd">        q: The size of each q-batch.</span>
<span class="sd">        batch_shape: The batch shape of the samples. If given, returns samples</span>
<span class="sd">            of shape `n x batch_shape x q x d`, where each batch is an</span>
<span class="sd">            `n x q x d`-dim tensor of qMC samples.</span>
<span class="sd">        seed: The seed used for initializing Owen scrambling. If None (default),</span>
<span class="sd">            use a random seed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `n x batch_shape x q x d`-dim tensor of qMC samples from the box</span>
<span class="sd">        defined by bounds.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; bounds = torch.stack([torch.zeros(3), torch.ones(3)])</span>
<span class="sd">        &gt;&gt;&gt; samples = draw_sobol_samples(bounds, 16, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">batch_shape</span> <span class="o">=</span> <span class="n">batch_shape</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">()</span>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">batch_shape</span><span class="p">)))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sobol_engine</span> <span class="o">=</span> <span class="n">SobolEngine</span><span class="p">(</span><span class="n">q</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">samples_raw</span> <span class="o">=</span> <span class="n">sobol_engine</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">samples_raw</span> <span class="o">=</span> <span class="n">samples_raw</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">batch_shape</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">batch_shape</span> <span class="o">!=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">():</span>
        <span class="n">samples_raw</span> <span class="o">=</span> <span class="n">samples_raw</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batch_shape</span><span class="p">)),</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unnormalize</span><span class="p">(</span><span class="n">samples_raw</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">update_constant_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="draw_sobol_normal_samples">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.draw_sobol_normal_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">draw_sobol_normal_samples</span><span class="p">(</span>
    <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Draw qMC samples from a multi-variate standard normal N(0, I_d).</span>

<span class="sd">    A primary use-case for this functionality is to compute an QMC average</span>
<span class="sd">    of f(X) over X where each element of X is drawn N(0, 1).</span>

<span class="sd">    Args:</span>
<span class="sd">        d: The dimension of the normal distribution.</span>
<span class="sd">        n: The number of samples to return. As a best practice, use powers of 2.</span>
<span class="sd">        device: The torch device.</span>
<span class="sd">        dtype:  The torch dtype.</span>
<span class="sd">        seed: The seed used for initializing Owen scrambling. If None (default),</span>
<span class="sd">            use a random seed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tensor of qMC standard normal samples with dimension `n x d` with device</span>
<span class="sd">        and dtype specified by the input.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; samples = draw_sobol_normal_samples(2, 16)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal_qmc_engine</span> <span class="o">=</span> <span class="n">NormalQMCEngine</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">inv_transform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">normal_qmc_engine</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span></div>



<div class="viewcode-block" id="sample_hypersphere">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.sample_hypersphere">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_hypersphere</span><span class="p">(</span>
    <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">qmc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sample uniformly from a unit d-sphere.</span>

<span class="sd">    Args:</span>
<span class="sd">        d: The dimension of the hypersphere.</span>
<span class="sd">        n: The number of samples to return.</span>
<span class="sd">        qmc: If True, use QMC Sobol sampling (instead of i.i.d. uniform).</span>
<span class="sd">        seed: If provided, use as a seed for the RNG.</span>
<span class="sd">        device: The torch device.</span>
<span class="sd">        dtype:  The torch dtype.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An  `n x d` tensor of uniform samples from from the d-hypersphere.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; sample_hypersphere(d=5, n=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">):</span>
            <span class="n">rnd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rnd</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">qmc</span><span class="p">:</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">draw_sobol_normal_samples</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">):</span>
            <span class="n">rnd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">rnd</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rnd</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">samples</span></div>



<div class="viewcode-block" id="sample_simplex">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.sample_simplex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_simplex</span><span class="p">(</span>
    <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">qmc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sample uniformly from a d-simplex.</span>

<span class="sd">    Args:</span>
<span class="sd">        d: The dimension of the simplex.</span>
<span class="sd">        n: The number of samples to return.</span>
<span class="sd">        qmc: If True, use QMC Sobol sampling (instead of i.i.d. uniform).</span>
<span class="sd">        seed: If provided, use as a seed for the RNG.</span>
<span class="sd">        device: The torch device.</span>
<span class="sd">        dtype: The torch dtype.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An `n x d` tensor of uniform samples from from the d-simplex.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; sample_simplex(d=3, n=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">qmc</span><span class="p">:</span>
        <span class="n">sobol_engine</span> <span class="o">=</span> <span class="n">SobolEngine</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">rnd</span> <span class="o">=</span> <span class="n">sobol_engine</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">):</span>
            <span class="n">rnd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">srnd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">rnd</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">zeros</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">srnd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">zeros</span><span class="p">,</span> <span class="n">srnd</span><span class="p">,</span> <span class="n">ones</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">srnd</span> <span class="o">=</span> <span class="n">srnd</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">srnd</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">srnd</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="sample_polytope">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.sample_polytope">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_polytope</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">x0</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">n0</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">n_thinning</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hit and run sampler from uniform sampling points from a polytope,</span>
<span class="sd">    described via inequality constraints A*x&lt;=b.</span>

<span class="sd">    Args:</span>
<span class="sd">        A: A `m x d`-dim Tensor describing inequality constraints</span>
<span class="sd">            so that all samples satisfy `Ax &lt;= b`.</span>
<span class="sd">        b: A `m`-dim Tensor describing the inequality constraints</span>
<span class="sd">            so that all samples satisfy `Ax &lt;= b`.</span>
<span class="sd">        x0: A `d`-dim Tensor representing a starting point of the chain</span>
<span class="sd">            satisfying the constraints.</span>
<span class="sd">        n: The number of resulting samples kept in the output.</span>
<span class="sd">        n0: The number of burn-in samples. The chain will produce</span>
<span class="sd">            n+n0 samples but the first n0 samples are not saved.</span>
<span class="sd">        n_thinning: The amount of thinnning. This function will return every</span>
<span class="sd">            `n_thinning`-th sample from the chain (after burn-in).</span>
<span class="sd">        seed: The seed for the sampler. If omitted, use a random seed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (n, d) dim Tensor containing the resulting samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check that starting point satisfies the constraints.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">slack</span> <span class="o">:=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">InfeasibilityError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Starting point does not satisfy the constraints. Inputs: </span><span class="si">{</span><span class="n">A</span><span class="si">=}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">x0</span><span class="si">=}</span><span class="s2">, A@x0-b=</span><span class="si">{</span><span class="n">slack</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    <span class="c1"># Remove rows where all elements of A are 0. This avoids nan and infs later.</span>
    <span class="c1"># A may have zero rows in it when this is called from PolytopeSampler</span>
    <span class="c1"># with equality constraints (which are absorbed into A &amp; b).</span>
    <span class="n">non_zero_rows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">non_zero_rows</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">non_zero_rows</span><span class="p">]</span>

    <span class="n">n_tot</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n_thinning</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span> <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">):</span>
        <span class="n">rands</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_tot</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># Sample uniformly from unit hypersphere in d dims.</span>
    <span class="c1"># Increment seed by +1 to avoid correlation with step size, see #2156 for details.</span>
    <span class="n">Rs</span> <span class="o">=</span> <span class="n">sample_hypersphere</span><span class="p">(</span>
        <span class="n">d</span><span class="o">=</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">n_tot</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Use batch operations for matrix multiplication.</span>
    <span class="n">ARs</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">Rs</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">large_constant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">finfo</span><span class="p">()</span><span class="o">.</span><span class="n">max</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ARs</span><span class="p">,</span> <span class="n">Rs</span><span class="p">,</span> <span class="n">rands</span><span class="p">)):</span>
        <span class="c1"># Given x, the next point in the chain is x+alpha*r.</span>
        <span class="c1"># It must satisfy A(x+alpha*r)&lt;=b, which implies A*alpha*r&lt;=b-Ax,</span>
        <span class="c1"># so alpha&lt;=(b-Ax)/ar for ar&gt;0, and alpha&gt;=(b-Ax)/ar for ar&lt;0.</span>
        <span class="c1"># If x is at the boundary, b - Ax = 0. If ar &gt; 0, then we must</span>
        <span class="c1"># have alpha &lt;= 0. If ar &lt; 0, we must have alpha &gt;= 0.</span>
        <span class="c1"># ar == 0 is an unlikely event that provides no signal.</span>
        <span class="c1"># b - A @ x is always &gt;= 0, clamping for numerical tolerances.</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">ar</span>
        <span class="c1"># Find upper bound for alpha. If there are no constraints on</span>
        <span class="c1"># the upper bound of alpha, set it to a large value.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">alpha_max</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">pos</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="n">large_constant</span>
        <span class="c1"># Find lower bound for alpha.</span>
        <span class="n">neg</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">alpha_min</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">neg</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">if</span> <span class="n">neg</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="o">-</span><span class="n">large_constant</span>
        <span class="c1"># Handle the boundary case.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">w_eq_0</span> <span class="o">:=</span> <span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># If ar &gt; 0 at the boundary, alpha &lt;= 0.</span>
            <span class="k">if</span> <span class="n">w_eq_0</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ar</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">alpha_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">alpha_max</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="c1"># If ar &lt; 0 at the boundary, alpha &gt;= 0.</span>
            <span class="k">if</span> <span class="n">w_eq_0</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ar</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">alpha_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">alpha_min</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># alpha ~ Uniform[alpha_min, alpha_max]</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha_min</span> <span class="o">+</span> <span class="n">rnd</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha_max</span> <span class="o">-</span> <span class="n">alpha_min</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">r</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">:=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">n0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># save samples after burn-in period</span>
            <span class="n">idx</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n_thinning</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="batched_multinomial">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.batched_multinomial">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">batched_multinomial</span><span class="p">(</span>
    <span class="n">weights</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">replacement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">generator</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LongTensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sample from multinomial with an arbitrary number of batch dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        weights: A `batch_shape x num_categories` tensor of weights. For each batch</span>
<span class="sd">            index `i, j, ...`, this functions samples from a multinomial with `input`</span>
<span class="sd">            `weights[i, j, ..., :]`. Note that the weights need not sum to one, but must</span>
<span class="sd">            be non-negative, finite and have a non-zero sum.</span>
<span class="sd">        num_samples: The number of samples to draw for each batch index. Must be smaller</span>
<span class="sd">            than `num_categories` if `replacement=False`.</span>
<span class="sd">        replacement: If True, samples are drawn with replacement.</span>
<span class="sd">        generator: A a pseudorandom number generator for sampling.</span>
<span class="sd">        out: The output tensor (optional). If provided, must be of size</span>
<span class="sd">            `batch_shape x num_samples`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `batch_shape x num_samples` tensor of samples.</span>

<span class="sd">    This is a thin wrapper around `torch.multinomial` that allows weight (`input`)</span>
<span class="sd">    tensors with an arbitrary number of batch dimensions (`torch.multinomial` only</span>
<span class="sd">    allows a single batch dimension). The calling signature is the same as for</span>
<span class="sd">    `torch.multinomial`.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; weights = torch.rand(2, 3, 10)</span>
<span class="sd">        &gt;&gt;&gt; samples = batched_multinomial(weights, 4)  # shape is 2 x 3 x 4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">batch_shape</span><span class="p">,</span> <span class="n">n_categories</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">weights</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">flat_samples</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span>
        <span class="nb">input</span><span class="o">=</span><span class="n">weights</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_categories</span><span class="p">),</span>
        <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
        <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span><span class="p">,</span>
        <span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">flat_samples</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">batch_shape</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_convert_bounds_to_inequality_constraints</span><span class="p">(</span><span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert bounds into inequality constraints of the form Ax &lt;= b.</span>

<span class="sd">    Args:</span>
<span class="sd">        bounds: A `2 x d`-dim tensor of bounds</span>

<span class="sd">    Returns:</span>
<span class="sd">        A two-element tuple containing</span>
<span class="sd">            - A: A `2d x d`-dim tensor of coefficients</span>
<span class="sd">            - b: A `2d x 1`-dim tensor containing the right hand side</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="n">lower_finite</span><span class="p">,</span> <span class="n">upper_finite</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">isfinite</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="o">-</span><span class="n">eye</span><span class="p">[</span><span class="n">lower_finite</span><span class="p">],</span> <span class="n">eye</span><span class="p">[</span><span class="n">upper_finite</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="o">-</span><span class="n">lower</span><span class="p">[</span><span class="n">lower_finite</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="n">upper_finite</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span>


<div class="viewcode-block" id="find_interior_point">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.find_interior_point">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_interior_point</span><span class="p">(</span>
    <span class="n">A</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
    <span class="n">A_eq</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">b_eq</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find an interior point of a polytope via linear programming.</span>

<span class="sd">    Args:</span>
<span class="sd">        A: A `n_ineq x d`-dim numpy array containing the coefficients of the</span>
<span class="sd">            constraint inequalities.</span>
<span class="sd">        b: A `n_ineq x 1`-dim numpy array containing the right hand sides of</span>
<span class="sd">            the constraint inequalities.</span>
<span class="sd">        A_eq: A `n_eq x d`-dim numpy array containing the coefficients of the</span>
<span class="sd">            constraint equalities.</span>
<span class="sd">        b_eq: A `n_eq x 1`-dim numpy array containing the right hand sides of</span>
<span class="sd">            the constraint equalities.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `d`-dim numpy array containing an interior point of the polytope.</span>
<span class="sd">        This function will raise a ValueError if there is no such point.</span>

<span class="sd">    This method solves the following Linear Program:</span>

<span class="sd">        min -s subject to A @ x &lt;= b - 2 * s, s &gt;= 0, A_eq @ x = b_eq</span>

<span class="sd">    In case the polytope is unbounded, then it will also constrain the slack</span>
<span class="sd">    variable `s` to `s&lt;=1`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># augment inequality constraints: A @ (x, s) &lt;= b</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ncon</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">b_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncon</span><span class="p">)</span>
    <span class="n">b_ub</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncon</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">A_ub</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
    <span class="n">A_ub</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="n">A_ub</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">linprog</span><span class="p">(</span>
        <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
        <span class="n">A_ub</span><span class="o">=</span><span class="n">A_ub</span><span class="p">,</span>
        <span class="n">b_ub</span><span class="o">=</span><span class="n">b_ub</span><span class="p">,</span>
        <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span>
        <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;highs&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># problem is unbounded - to find a bounded solution we constrain the</span>
        <span class="c1"># slack variable `s` to `s &lt;= 1.0`.</span>
        <span class="n">A_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">A_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">A_ub</span><span class="p">,</span> <span class="n">A_s</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">b_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">b_ub</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">linprog</span><span class="p">(</span>
            <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
            <span class="n">A_ub</span><span class="o">=</span><span class="n">A_ub</span><span class="p">,</span>
            <span class="n">b_ub</span><span class="o">=</span><span class="n">b_ub</span><span class="p">,</span>
            <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span>
            <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;highs&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">InfeasibilityError</span><span class="p">(</span>
            <span class="s2">&quot;No feasible point found. Constraint polytope appears empty. &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;Check your constraints.&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">result</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Problem checking constraint specification. &quot;</span>
            <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;linprog status: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="c1"># the x in the result is really (x, s)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="PolytopeSampler">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.PolytopeSampler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PolytopeSampler</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for samplers that sample points from a polytope.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inequality_constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">equality_constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interior_point</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            inequality_constraints: Tensors `(A, b)` describing inequality</span>
<span class="sd">                constraints `A @ x &lt;= b`, where `A` is a `n_ineq_con x d`-dim</span>
<span class="sd">                Tensor and `b` is a `n_ineq_con x 1`-dim Tensor, with `n_ineq_con`</span>
<span class="sd">                the number of inequalities and `d` the dimension of the sample space.</span>
<span class="sd">            equality_constraints: Tensors `(C, d)` describing the equality constraints</span>
<span class="sd">                `C @ x = d`, where `C` is a `n_eq_con x d`-dim Tensor and `d` is a</span>
<span class="sd">                `n_eq_con x 1`-dim Tensor with `n_eq_con` the number of equalities.</span>
<span class="sd">            bounds: A `2 x d`-dim tensor of box bounds, where `inf` (`-inf`) means</span>
<span class="sd">                that the respective dimension is unbounded above (below).</span>
<span class="sd">            interior_point: A `d x 1`-dim Tensor presenting a point in the</span>
<span class="sd">                (relative) interior of the polytope. If omitted, determined</span>
<span class="sd">                automatically by solving a Linear Program.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inequality_constraints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">BotorchError</span><span class="p">(</span>
                    <span class="s2">&quot;PolytopeSampler requires either inequality constraints or bounds.&quot;</span>
                <span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">inequality_constraints</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># add inequality constraints for bounds</span>
            <span class="c1"># TODO: make sure there are not deduplicate constraints</span>
            <span class="n">A2</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_convert_bounds_to_inequality_constraints</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">A2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">b2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equality_constraints</span> <span class="o">=</span> <span class="n">equality_constraints</span>

        <span class="k">if</span> <span class="n">equality_constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">equality_constraints</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># rank of matrix C</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nullC</span> <span class="o">=</span> <span class="n">Vh</span><span class="p">[</span><span class="n">r</span><span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># orthonormal null space of C,</span>
            <span class="c1"># satisfying # C @ nullC = 0 and nullC.T @ nullC = I</span>
            <span class="c1"># using the change of variables x=x0+nullC*y,</span>
            <span class="c1"># sample y satisfies A*nullC*y&lt;=b-A*x0.</span>
            <span class="c1"># the linear constraint is automatically satisfied as x0 satisfies it.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nullC</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">device</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">new_A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">nullC</span>  <span class="c1"># doesn&#39;t depend on the initial point</span>

        <span class="c1"># initial point for the original, not transformed, problem</span>
        <span class="k">if</span> <span class="n">interior_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">feasible</span><span class="p">(</span><span class="n">interior_point</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">interior_point</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InfeasibilityError</span><span class="p">(</span><span class="s2">&quot;The given input point is not feasible.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_interior_point</span><span class="p">()</span>

<div class="viewcode-block" id="PolytopeSampler.feasible">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.PolytopeSampler.feasible">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Check whether a point is contained in the polytope.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: A `d x 1`-dim Tensor.</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if `x` is contained inside the polytope (incl. its boundary),</span>
<span class="sd">            False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ineq</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equality_constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span> <span class="o">@</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">ineq</span> <span class="o">&amp;</span> <span class="n">eq</span>
        <span class="k">return</span> <span class="n">ineq</span></div>


<div class="viewcode-block" id="PolytopeSampler.find_interior_point">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.PolytopeSampler.find_interior_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_interior_point</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find an interior point of the polytope.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `d x 1`-dim Tensor representing a point contained in the polytope.</span>
<span class="sd">            This function will raise a ValueError if there is no such point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equality_constraints</span><span class="p">:</span>
            <span class="c1"># equality constraints: A_eq * (x, s) = b_eq</span>
            <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">A_eq</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">b_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A_eq</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">b_eq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">find_interior_point</span><span class="p">(</span>
            <span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>


    <span class="c1"># -------- Abstract methods to be implemented by subclasses -------- #</span>

<div class="viewcode-block" id="PolytopeSampler.draw">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.PolytopeSampler.draw">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Draw samples from the polytope.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: The number of samples.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `n x d` Tensor of samples from the polytope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>  <span class="c1"># pragma: no cover</span></div>
</div>



<div class="viewcode-block" id="HitAndRunPolytopeSampler">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.HitAndRunPolytopeSampler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HitAndRunPolytopeSampler</span><span class="p">(</span><span class="n">PolytopeSampler</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A sampler for sampling from a polyope using a hit-and-run algorithm.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inequality_constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">equality_constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interior_point</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_burnin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">n_thinning</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A sampler for sampling from a polyope using a hit-and-run algorithm.</span>

<span class="sd">        Args:</span>
<span class="sd">            inequality_constraints: Tensors `(A, b)` describing inequality</span>
<span class="sd">                constraints `A @ x &lt;= b`, where `A` is a `n_ineq_con x d`-dim</span>
<span class="sd">                Tensor and `b` is a `n_ineq_con x 1`-dim Tensor, with `n_ineq_con`</span>
<span class="sd">                the number of inequalities and `d` the dimension of the sample space.</span>
<span class="sd">            equality_constraints: Tensors `(C, d)` describing the equality constraints</span>
<span class="sd">                `C @ x = d`, where `C` is a `n_eq_con x d`-dim Tensor and `d` is a</span>
<span class="sd">                `n_eq_con x 1`-dim Tensor with `n_eq_con` the number of equalities.</span>
<span class="sd">            bounds: A `2 x d`-dim tensor of box bounds, where `inf` (`-inf`) means</span>
<span class="sd">                that the respective dimension is unbounded from above (below). If</span>
<span class="sd">                omitted, no bounds (in addition to the above constraints) are applied.</span>
<span class="sd">            interior_point: A `d x 1`-dim Tensor representing a point in the</span>
<span class="sd">                (relative) interior of the polytope. If omitted, determined</span>
<span class="sd">                automatically by solving a Linear Program.</span>
<span class="sd">            n_burnin: The number of burn in samples. The sampler will discard</span>
<span class="sd">                `n_burnin` samples before returning the first sample.</span>
<span class="sd">            n_thinning: The amount of thinning. The sampler will return every</span>
<span class="sd">                `n_thinning` sample (after burn-in). This may need to be increased</span>
<span class="sd">                for sets of constraints that are difficult to satisfy (i.e. in which</span>
<span class="sd">                case the volume of the constraint polytope is small relative to that</span>
<span class="sd">                of its bounding box).</span>
<span class="sd">            seed: The random seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inequality_constraints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BotorchError</span><span class="p">(</span>
                <span class="s2">&quot;HitAndRunPolytopeSampler requires either inequality constraints &quot;</span>
                <span class="s2">&quot;or bounds.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Normalize constraints to avoid the following issue:</span>
        <span class="c1"># https://github.com/pytorch/botorch/issues/1225</span>
        <span class="n">offset</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">inequality_constraints</span> <span class="ow">or</span> <span class="n">equality_constraints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;HitAndRunPolytopeSampler did not receive `bounds`, which can &quot;</span>
                    <span class="s2">&quot;lead to non-uniform sampling if the parameter ranges are very &quot;</span>
                    <span class="s2">&quot;different (see https://github.com/pytorch/botorch/issues/1225).&quot;</span><span class="p">,</span>
                    <span class="n">UserInputWarning</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">inequality_constraints</span><span class="p">:</span>
                    <span class="n">inequality_constraints</span> <span class="o">=</span> <span class="n">normalize_dense_linear_constraints</span><span class="p">(</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">inequality_constraints</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">equality_constraints</span><span class="p">:</span>
                    <span class="n">equality_constraints</span> <span class="o">=</span> <span class="n">normalize_dense_linear_constraints</span><span class="p">(</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">equality_constraints</span>
                    <span class="p">)</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">bounds</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">lower</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span>
                <span class="k">if</span> <span class="n">interior_point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># If provided, we also need to normalize the interior point</span>
                    <span class="n">interior_point</span> <span class="o">=</span> <span class="p">(</span><span class="n">interior_point</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">/</span> <span class="n">scale</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
                <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inequality_constraints</span><span class="o">=</span><span class="n">inequality_constraints</span><span class="p">,</span>
            <span class="n">equality_constraints</span><span class="o">=</span><span class="n">equality_constraints</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">interior_point</span><span class="o">=</span><span class="n">interior_point</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_burnin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">n_burnin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_thinning</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">n_thinning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_generated</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">scale</span>

<div class="viewcode-block" id="HitAndRunPolytopeSampler.draw">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.HitAndRunPolytopeSampler.draw">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Draw samples from the polytope.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: The number of samples.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `n x d` Tensor of samples from the polytope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># There are two layers of normalization. In the outer layer, the space</span>
        <span class="c1"># has been normalized to the unit cube. In the inner layer, we remove</span>
        <span class="c1"># any equality constraints and sample on the subspace defined by those</span>
        <span class="c1"># equality constraints, with an additional shift to normalize the interior</span>
        <span class="c1"># point to the origin. Below, after sampling in that inner layer, we have</span>
        <span class="c1"># to reverse both layers of normalization.</span>
        <span class="n">transformed_samples</span> <span class="o">=</span> <span class="n">sample_polytope</span><span class="p">(</span>
            <span class="c1"># Run this on the cpu since there is a lot of looping going on</span>
            <span class="n">A</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">new_A</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
            <span class="n">b</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nullC</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">n0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_burnin</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_generated</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">n_thinning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_thinning</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_seed</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Update the seed for the next call in a deterministic fashion</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seed</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="c1"># Unnormalize the inner layer</span>
        <span class="n">init_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">init_shift</span> <span class="o">+</span> <span class="n">transformed_samples</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">nullC</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Keep the last element as the beginning of the next chain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x0</span> <span class="o">=</span> <span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Unnormalize the outer layer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">*</span> <span class="n">samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples_generated</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">samples</span></div>
</div>



<div class="viewcode-block" id="DelaunayPolytopeSampler">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.DelaunayPolytopeSampler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelaunayPolytopeSampler</span><span class="p">(</span><span class="n">PolytopeSampler</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A polytope sampler using Delaunay triangulation.</span>

<span class="sd">    This sampler first enumerates the vertices of the constraint polytope and</span>
<span class="sd">    then uses a Delaunay triangulation to tesselate its convex hull.</span>

<span class="sd">    The sampling happens in two stages:</span>
<span class="sd">    1. First, we sample from the set of hypertriangles generated by the</span>
<span class="sd">    Delaunay triangulation (i.e. which hyper-triangle to draw the sample</span>
<span class="sd">    from) with probabilities proportional to the triangle volumes.</span>
<span class="sd">    2. Then, we sample uniformly from the chosen hypertriangle by sampling</span>
<span class="sd">    uniformly from the unit simplex of the appropriate dimension, and</span>
<span class="sd">    then computing the convex combination of the vertices of the</span>
<span class="sd">    hypertriangle according to that draw from the simplex.</span>

<span class="sd">    The best reference (not exactly the same, but functionally equivalent) is</span>
<span class="sd">    [Trikalinos2014polytope]_. A simple R implementation is available at</span>
<span class="sd">    https://github.com/gertvv/tesselample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inequality_constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">equality_constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">interior_point</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize DelaunayPolytopeSampler.</span>

<span class="sd">        Args:</span>
<span class="sd">            inequality_constraints: Tensors `(A, b)` describing inequality</span>
<span class="sd">                constraints `A @ x &lt;= b`, where `A` is a `n_ineq_con x d`-dim</span>
<span class="sd">                Tensor and `b` is a `n_ineq_con x 1`-dim Tensor, with `n_ineq_con`</span>
<span class="sd">                the number of inequalities and `d` the dimension of the sample space.</span>
<span class="sd">            equality_constraints: Tensors `(C, d)` describing the equality constraints</span>
<span class="sd">                `C @ x = d`, where `C` is a `n_eq_con x d`-dim Tensor and `d` is a</span>
<span class="sd">                `n_eq_con x 1`-dim Tensor with `n_eq_con` the number of equalities.</span>
<span class="sd">            bounds: A `2 x d`-dim tensor of box bounds, where `inf` (`-inf`) means</span>
<span class="sd">                that the respective dimension is unbounded from above (below).</span>
<span class="sd">            interior_point: A `d x 1`-dim Tensor representing a point in the</span>
<span class="sd">                (relative) interior of the polytope. If omitted, determined</span>
<span class="sd">                automatically by solving a Linear Program.</span>

<span class="sd">        Warning: The vertex enumeration performed in this algorithm can become</span>
<span class="sd">        extremely costly if there are a large number of inequalities. Similarly,</span>
<span class="sd">        the triangulation can get very expensive in high dimensions. Only use</span>
<span class="sd">        this algorithm for moderate dimensions / moderately complex constraint sets.</span>
<span class="sd">        An alternative is the `HitAndRunPolytopeSampler`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inequality_constraints</span><span class="o">=</span><span class="n">inequality_constraints</span><span class="p">,</span>
            <span class="n">equality_constraints</span><span class="o">=</span><span class="n">equality_constraints</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
            <span class="n">interior_point</span><span class="o">=</span><span class="n">interior_point</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># shift coordinate system to be anchored at x0</span>
        <span class="n">new_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># if the polytope is in dim 1 (i.e. a line segment) Qhull won&#39;t work</span>
            <span class="n">tshlds</span> <span class="o">=</span> <span class="n">new_b</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_A</span>
            <span class="n">neg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_A</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="n">tshlds</span><span class="p">[</span><span class="n">neg</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">tshlds</span><span class="p">[</span><span class="o">~</span><span class="n">neg</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Qhull expects inputs of the form A @ x + b &lt;= 0, so we need to negate here</span>
            <span class="n">halfspaces</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">new_A</span><span class="p">,</span> <span class="o">-</span><span class="n">new_b</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">HalfspaceIntersection</span><span class="p">(</span>
                <span class="n">halfspaces</span><span class="o">=</span><span class="n">halfspaces</span><span class="p">,</span> <span class="n">interior_point</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">new_A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span><span class="o">.</span><span class="n">intersections</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">delaunay</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;Points cannot contain NaN&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polytope is unbounded.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span>  <span class="c1"># pragma: no cover</span>
            <span class="n">polytopes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delaunay</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">delaunay</span><span class="o">.</span><span class="n">simplices</span><span class="p">]),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
            <span class="n">volumes</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polytopes</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_polytopes</span> <span class="o">=</span> <span class="n">polytopes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_p</span> <span class="o">=</span> <span class="n">volumes</span> <span class="o">/</span> <span class="n">volumes</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<div class="viewcode-block" id="DelaunayPolytopeSampler.draw">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.DelaunayPolytopeSampler.draw">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Draw samples from the polytope.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: The number of samples.</span>
<span class="sd">            seed: The random seed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `n x d` Tensor of samples from the polytope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">new_A</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">new_A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">transformed_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">)</span> <span class="o">*</span> <span class="n">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">generator</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">generator</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="n">generator</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">index_rvs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">multinomial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_p</span><span class="p">,</span>
                <span class="n">num_samples</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
                <span class="n">replacement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">generator</span><span class="o">=</span><span class="n">generator</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">simplex_rvs</span> <span class="o">=</span> <span class="n">sample_simplex</span><span class="p">(</span>
                <span class="n">d</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span>
            <span class="p">)</span>
            <span class="n">transformed_samples</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">rv</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polytopes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">rv</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">simplex_rvs</span><span class="p">,</span> <span class="n">index_rvs</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="n">init_shift</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x0</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">init_shift</span> <span class="o">+</span> <span class="n">transformed_samples</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">nullC</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span></div>
</div>



<div class="viewcode-block" id="normalize_sparse_linear_constraints">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.normalize_sparse_linear_constraints">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_sparse_linear_constraints</span><span class="p">(</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalize sparse linear constraints to the unit cube.</span>

<span class="sd">    Args:</span>
<span class="sd">        bounds: A `2 x d`-dim tensor containing the box bounds.</span>
<span class="sd">        constraints: A list of tuples (`indices`, `coefficients`, `rhs`), with</span>
<span class="sd">            `indices` and `coefficients` one-dimensional tensors and `rhs` a</span>
<span class="sd">            scalar, where each tuple encodes an inequality constraint of the form</span>
<span class="sd">            `\sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs` or</span>
<span class="sd">            `\sum_i (X[indices[i]] * coefficients[i]) = rhs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_constraints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`indices` must be a one-dimensional tensor. This method does not &quot;</span>
                <span class="s2">&quot;support the kind of &#39;inter-point constraints&#39; that are supported by &quot;</span>
                <span class="s2">&quot;`optimize_acqf()`. To achieve this behavior, you need define the &quot;</span>
                <span class="s2">&quot;problem on the joint space over `q` points and impose use constraints,&quot;</span>
                <span class="s2">&quot;see https://github.com/pytorch/botorch/issues/2468#issuecomment-2287706461&quot;</span>  <span class="c1"># noqa: E501</span>
            <span class="p">)</span>
        <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span>
        <span class="n">new_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="n">coefficient</span><span class="p">,</span> <span class="p">(</span><span class="n">rhs</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coefficient</span><span class="p">,</span> <span class="n">lower</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">new_constraints</span></div>



<div class="viewcode-block" id="normalize_dense_linear_constraints">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.normalize_dense_linear_constraints">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize_dense_linear_constraints</span><span class="p">(</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">constraints</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalize dense linear constraints to the unit cube.</span>

<span class="sd">    Args:</span>
<span class="sd">        bounds: A `2 x d`-dim tensor containing the box bounds.</span>
<span class="sd">        constraints: A tensor tuple `(A, b)` describing constraints</span>
<span class="sd">            `A @ x (&lt;)= b`, where `A` is a `n_con x d`-dim Tensor and</span>
<span class="sd">            `b` is a `n_con x 1`-dim Tensor, with `n_con` the number of</span>
<span class="sd">            constraints and `d` the dimension of the sample space.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A tensor tuple `(A_nlz, b_nlz)` of normalized constraints.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">bounds</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">constraints</span>
    <span class="n">A_nlz</span> <span class="o">=</span> <span class="p">(</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="p">)</span> <span class="o">*</span> <span class="n">A</span>
    <span class="n">b_nlz</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="p">(</span><span class="n">A</span> <span class="o">@</span> <span class="n">lower</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A_nlz</span><span class="p">,</span> <span class="n">b_nlz</span></div>



<div class="viewcode-block" id="get_polytope_samples">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.get_polytope_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_polytope_samples</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">inequality_constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">equality_constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_burnin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10_000</span><span class="p">,</span>
    <span class="n">n_thinning</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sample from polytope defined by box bounds and (in)equality constraints.</span>

<span class="sd">    This uses a hit-and-run Markov chain sampler.</span>

<span class="sd">    NOTE: Much of the functionality of this method has been moved into</span>
<span class="sd">    `HitAndRunPolytopeSampler`. If you want to repeatedly draw samples, you should</span>
<span class="sd">    use `HitAndRunPolytopeSampler` directly in order to avoid repeatedly running</span>
<span class="sd">    a burn-in of the chain. To do so, you need to convert the sparse constraint</span>
<span class="sd">    format that `get_polytope_samples` expects to the dense constraint format that</span>
<span class="sd">    `HitAndRunPolytopeSampler` expects. This can be done via the</span>
<span class="sd">    `sparse_to_dense_constraints` method (but remember to adjust the constraint</span>
<span class="sd">    from the `Ax &gt;= b` format expecxted here to the `Ax &lt;= b` format expected by</span>
<span class="sd">    `PolytopeSampler` by multiplying both `A` and `b` by -1.)</span>

<span class="sd">    NOTE: This method does not support the kind of &quot;inter-point constraints&quot; that</span>
<span class="sd">    are supported by `optimize_acqf()`. To achieve this behavior, you need define the</span>
<span class="sd">    problem on the joint space over `q` points and impose use constraints, see:</span>
<span class="sd">    https://github.com/pytorch/botorch/issues/2468#issuecomment-2287706461</span>

<span class="sd">    Args:</span>
<span class="sd">        n: The number of samples.</span>
<span class="sd">        bounds: A `2 x d`-dim tensor containing the box bounds.</span>
<span class="sd">        inequality_constraints: A list of tuples (`indices`, `coefficients`, `rhs`),</span>
<span class="sd">            with `indices` and `coefficients` one-dimensional tensors and `rhs` a</span>
<span class="sd">            scalar, where each tuple encodes an inequality constraint of the form</span>
<span class="sd">            `\sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs`.</span>
<span class="sd">        equality_constraints: A list of tuples (`indices`, `coefficients`, `rhs`),</span>
<span class="sd">            with `indices` and `coefficients` one-dimensional tensors and `rhs` a</span>
<span class="sd">            scalar, where each tuple encodes an equality constraint of the form</span>
<span class="sd">            `\sum_i (X[indices[i]] * coefficients[i]) = rhs`.</span>
<span class="sd">        seed: The random seed.</span>
<span class="sd">        n_burnin: The number of burn-in samples for the Markov chain sampler.</span>
<span class="sd">        n_thinning: The amount of thinnning. This function will return every</span>
<span class="sd">            `n_thinning`-th sample from the chain (after burn-in).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `n x d`-dim tensor of samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">inequality_constraints</span><span class="p">:</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">sparse_to_dense_constraints</span><span class="p">(</span>
            <span class="n">d</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">constraints</span><span class="o">=</span><span class="n">inequality_constraints</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Note that the inequality constraints are of the form Ax &gt;= b,</span>
        <span class="c1"># but PolytopeSampler expects inequality constraints of the</span>
        <span class="c1"># form Ax &lt;= b, so we multiply by -1 below.</span>
        <span class="n">dense_inequality_constraints</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">A</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dense_inequality_constraints</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">equality_constraints</span><span class="p">:</span>
        <span class="n">dense_equality_constraints</span> <span class="o">=</span> <span class="n">sparse_to_dense_constraints</span><span class="p">(</span>
            <span class="n">d</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">constraints</span><span class="o">=</span><span class="n">equality_constraints</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dense_equality_constraints</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">polytope_sampler</span> <span class="o">=</span> <span class="n">HitAndRunPolytopeSampler</span><span class="p">(</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">inequality_constraints</span><span class="o">=</span><span class="n">dense_inequality_constraints</span><span class="p">,</span>
        <span class="n">equality_constraints</span><span class="o">=</span><span class="n">dense_equality_constraints</span><span class="p">,</span>
        <span class="n">n_burnin</span><span class="o">=</span><span class="n">n_burnin</span><span class="p">,</span>
        <span class="n">n_thinning</span><span class="o">=</span><span class="n">n_thinning</span><span class="p">,</span>
        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">polytope_sampler</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span></div>



<div class="viewcode-block" id="sparse_to_dense_constraints">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.sparse_to_dense_constraints">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sparse_to_dense_constraints</span><span class="p">(</span>
    <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">constraints</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert parameter constraints from a sparse format into a dense format.</span>

<span class="sd">    This method converts sparse triples of the form (indices, coefficients, rhs)</span>
<span class="sd">    to constraints of the form Ax &gt;= b or Ax = b.</span>

<span class="sd">    Args:</span>
<span class="sd">        d: The input dimension.</span>
<span class="sd">        constraints: A list of tuples (`indices`, `coefficients`, `rhs`),</span>
<span class="sd">            with `indices` and `coefficients` one-dimensional tensors and `rhs` a</span>
<span class="sd">            scalar, where each tuple encodes an (in)equality constraint of the form</span>
<span class="sd">            `\sum_i (X[indices[i]] * coefficients[i]) &gt;= rhs` or</span>
<span class="sd">            `\sum_i (X[indices[i]] * coefficients[i]) = rhs`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A two-element tuple containing:</span>
<span class="sd">            - A: A `n_constraints x d`-dim tensor of coefficients.</span>
<span class="sd">            - b: A `n_constraints x 1`-dim tensor of right hand sides.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_t</span> <span class="o">=</span> <span class="n">constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">),</span> <span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_t</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">_t</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_t</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">_t</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">constraints</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">long</span><span class="p">()]</span> <span class="o">=</span> <span class="n">coefficients</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhs</span>
    <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span></div>



<div class="viewcode-block" id="optimize_posterior_samples">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.optimize_posterior_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">optimize_posterior_samples</span><span class="p">(</span>
    <span class="n">paths</span><span class="p">:</span> <span class="n">GenericDeterministicModel</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">raw_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
    <span class="n">num_restarts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">sample_transform</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_transformed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Cheaply maximizes posterior samples by random querying followed by</span>
<span class="sd">    gradient-based optimization using SciPy&#39;s L-BFGS-B routine.</span>

<span class="sd">    Args:</span>
<span class="sd">        paths: Random Fourier Feature-based sample paths from the GP</span>
<span class="sd">        bounds: The bounds on the search space.</span>
<span class="sd">        raw_samples: The number of samples with which to query the samples initially.</span>
<span class="sd">        num_restarts: The number of points selected for gradient-based optimization.</span>
<span class="sd">        sample_transform: A callable transform of the sample outputs (e.g.</span>
<span class="sd">            MCAcquisitionObjective or ScalarizedPosteriorTransform.evaluate) used to</span>
<span class="sd">            negate the objective or otherwise transform the output.</span>
<span class="sd">        return_transformed: A boolean indicating whether to return the transformed</span>
<span class="sd">            or non-transformed samples.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A two-element tuple containing:</span>
<span class="sd">            - X_opt: A `num_optima x [batch_size] x d`-dim tensor of optimal inputs x*.</span>
<span class="sd">            - f_opt: A `num_optima x [batch_size] x m`-dim, optionally</span>
<span class="sd">                `num_optima x [batch_size] x 1`-dim,  tensor of optimal outputs f*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">path_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">paths</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_transform</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">sample_transform</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">candidate_set</span> <span class="o">=</span> <span class="n">unnormalize</span><span class="p">(</span>
        <span class="n">SobolEngine</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scramble</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">raw_samples</span><span class="p">),</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># queries all samples on all candidates - output shape</span>
    <span class="c1"># raw_samples * num_optima * num_models</span>
    <span class="n">candidate_queries</span> <span class="o">=</span> <span class="n">path_func</span><span class="p">(</span><span class="n">candidate_set</span><span class="p">)</span>
    <span class="n">argtop_k</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="n">candidate_queries</span><span class="p">,</span> <span class="n">num_restarts</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span>
    <span class="n">X_top_k</span> <span class="o">=</span> <span class="n">candidate_set</span><span class="p">[</span><span class="n">argtop_k</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># to avoid circular import, the import occurs here</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">botorch.generation.gen</span><span class="w"> </span><span class="kn">import</span> <span class="n">gen_candidates_scipy</span>

    <span class="n">X_top_k</span><span class="p">,</span> <span class="n">f_top_k</span> <span class="o">=</span> <span class="n">gen_candidates_scipy</span><span class="p">(</span>
        <span class="n">X_top_k</span><span class="p">,</span>
        <span class="n">path_func</span><span class="p">,</span>
        <span class="n">lower_bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">upper_bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">f_opt</span><span class="p">,</span> <span class="n">arg_opt</span> <span class="o">=</span> <span class="n">f_top_k</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># For each sample (and possibly for every model in the batch of models), this</span>
    <span class="c1"># retrieves the argmax. We flatten, pick out the indices and then reshape to</span>
    <span class="c1"># the original batch shapes (so instead of pickig out the argmax of a</span>
    <span class="c1"># (3, 7, num_restarts, D)) along the num_restarts dim, we pick it out of a</span>
    <span class="c1"># (21, num_restarts, D)</span>
    <span class="n">final_shape</span> <span class="o">=</span> <span class="n">candidate_queries</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">X_opt</span> <span class="o">=</span> <span class="n">X_top_k</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">final_shape</span><span class="o">.</span><span class="n">numel</span><span class="p">(),</span> <span class="n">num_restarts</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">final_shape</span><span class="o">.</span><span class="n">numel</span><span class="p">()),</span> <span class="n">arg_opt</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">final_shape</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># if we return transformed, we do not need to pass the samples through paths</span>
    <span class="c1"># paths a second time but rather just return the transformed optimal values</span>
    <span class="k">if</span> <span class="n">return_transformed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X_opt</span><span class="p">,</span> <span class="n">f_opt</span>

    <span class="n">f_opt</span> <span class="o">=</span> <span class="n">paths</span><span class="p">(</span><span class="n">X_opt</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X_opt</span><span class="p">,</span> <span class="n">f_opt</span></div>



<div class="viewcode-block" id="boltzmann_sample">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.boltzmann_sample">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">boltzmann_sample</span><span class="p">(</span>
    <span class="n">function_values</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">replacement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">temp_decrease</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Boltzmann sampling from a set of function values, weighted by the</span>
<span class="sd">    exponentiated difference between function values and their standardized mean.</span>

<span class="sd">    Args:</span>
<span class="sd">        function_values: A [batch_shape] x N  tensor of function values.</span>
<span class="sd">        num_samples: The number of samples (restarts) to draw.</span>
<span class="sd">        eta: The Boltzmann temperature, controls the sharpness of the weighting. If the</span>
<span class="sd">            temperature is too high, causing NaN values, the eta parameter is</span>
<span class="sd">            succesively decreased by &#39;temp_decrease&#39;.</span>
<span class="sd">        replacement: If True, samples are drawn with replacement, allowing duplicates.</span>
<span class="sd">        temp_decrease: The rate at which temperature decreases in case of inf weights.</span>

<span class="sd">        Returns:</span>
<span class="sd">        A [batch_shape] x num_samples tensor of indices of sampled positions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm_weights</span> <span class="o">=</span> <span class="n">standardize</span><span class="p">(</span><span class="n">function_values</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span> <span class="o">*</span> <span class="n">norm_weights</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">torch</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">eta</span> <span class="o">*=</span> <span class="n">temp_decrease</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">eta</span> <span class="o">*</span> <span class="n">norm_weights</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">batched_multinomial</span><span class="p">(</span>
        <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="sample_truncated_normal_perturbations">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.sample_truncated_normal_perturbations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_truncated_normal_perturbations</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_discrete_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">qmc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sample points around `X`.</span>

<span class="sd">    Sample perturbed points around `X` such that the added perturbations</span>
<span class="sd">    are sampled from N(0, sigma^2 I) and truncated to be within [0,1]^d.</span>

<span class="sd">    Args:</span>
<span class="sd">        X: A `n x d`-dim tensor starting points.</span>
<span class="sd">        n_discrete_points: The number of points to sample.</span>
<span class="sd">        sigma: The standard deviation of the additive gaussian noise for</span>
<span class="sd">            perturbing the points.</span>
<span class="sd">        bounds: A `2 x d`-dim tensor containing the bounds.</span>
<span class="sd">        qmc: A boolean indicating whether to use qmc.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `n_discrete_points x d`-dim tensor containing the sampled points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># sample points from N(X_center, sigma^2 I), truncated to be within</span>
    <span class="c1"># [0, 1]^d.</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">rand_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">n_discrete_points</span><span class="p">,),</span> <span class="n">device</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">rand_indices</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">qmc</span><span class="p">:</span>
        <span class="n">std_bounds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">std_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">draw_sobol_samples</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="n">std_bounds</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n_discrete_points</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="n">n_discrete_points</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="c1"># compute bounds to sample from</span>
    <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">X</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">X</span>
    <span class="c1"># compute z-score of bounds</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">sigma</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">b</span> <span class="o">/</span> <span class="n">sigma</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cdf_alpha</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
    <span class="c1"># use inverse transform</span>
    <span class="n">perturbation</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">icdf</span><span class="p">(</span><span class="n">cdf_alpha</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="p">(</span><span class="n">normal</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="n">cdf_alpha</span><span class="p">))</span> <span class="o">*</span> <span class="n">sigma</span>
    <span class="c1"># add perturbation and clip points that are still outside</span>
    <span class="n">perturbed_X</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">perturbation</span><span class="p">)</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unnormalize</span><span class="p">(</span><span class="n">perturbed_X</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span></div>



<div class="viewcode-block" id="sample_perturbed_subset_dims">
<a class="viewcode-back" href="../../../utils.html#botorch.utils.sampling.sample_perturbed_subset_dims">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_perturbed_subset_dims</span><span class="p">(</span>
    <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">n_discrete_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-1</span><span class="p">,</span>
    <span class="n">qmc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prob_perturb</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sample around `X` by perturbing a subset of the dimensions.</span>

<span class="sd">    By default, dimensions are perturbed with probability equal to</span>
<span class="sd">    `min(20 / d, 1)`. As shown in [Regis]_, perturbing a small number</span>
<span class="sd">    of dimensions can be beneificial. The perturbations are sampled</span>
<span class="sd">    from N(0, sigma^2 I) and truncated to be within [0,1]^d.</span>

<span class="sd">    Args:</span>
<span class="sd">        X: A `n x d`-dim tensor starting points. `X`</span>
<span class="sd">            must be normalized to be within `[0, 1]^d`.</span>
<span class="sd">        bounds: The bounds to sample perturbed values from</span>
<span class="sd">        n_discrete_points: The number of points to sample.</span>
<span class="sd">        sigma: The standard deviation of the additive gaussian noise for</span>
<span class="sd">            perturbing the points.</span>
<span class="sd">        qmc: A boolean indicating whether to use qmc.</span>
<span class="sd">        prob_perturb: The probability of perturbing each dimension. If omitted,</span>
<span class="sd">            defaults to `min(20 / d, 1)`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `n_discrete_points x d`-dim tensor containing the sampled points.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bounds</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BotorchTensorDimensionError</span><span class="p">(</span><span class="s2">&quot;bounds must be a `2 x d`-dim tensor.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BotorchTensorDimensionError</span><span class="p">(</span><span class="s2">&quot;X must be a `n x d`-dim tensor.&quot;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">prob_perturb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Only perturb a subset of the features</span>
        <span class="n">prob_perturb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">20.0</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">X_cand</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n_discrete_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rand_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">n_discrete_points</span><span class="p">,),</span> <span class="n">device</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="n">X_cand</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">rand_indices</span><span class="p">]</span>
    <span class="n">pert</span> <span class="o">=</span> <span class="n">sample_truncated_normal_perturbations</span><span class="p">(</span>
        <span class="n">X</span><span class="o">=</span><span class="n">X_cand</span><span class="p">,</span>
        <span class="n">n_discrete_points</span><span class="o">=</span><span class="n">n_discrete_points</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">qmc</span><span class="o">=</span><span class="n">qmc</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># find cases where we are not perturbing any dimensions</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span>
            <span class="n">n_discrete_points</span><span class="p">,</span>
            <span class="n">d</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="o">&lt;=</span> <span class="n">prob_perturb</span>
    <span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="c1"># perturb `n_perturb` of the dimensions</span>
    <span class="n">n_perturb</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="n">prob_perturb</span><span class="p">)</span>
    <span class="n">perturb_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">mask</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">perturb_mask</span><span class="p">[:</span><span class="n">n_perturb</span><span class="p">]</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># TODO: use batched `torch.randperm` when available:</span>
    <span class="c1"># https://github.com/pytorch/pytorch/issues/42502</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">perturb_mask</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">randperm</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">bounds</span><span class="o">.</span><span class="n">device</span><span class="p">)]</span>
    <span class="c1"># Create candidate points</span>
    <span class="n">X_cand</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">pert</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X_cand</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>