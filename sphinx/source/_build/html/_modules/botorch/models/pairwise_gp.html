

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>botorch.models.pairwise_gp &mdash; BoTorch  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=ca3e82f4" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            BoTorch
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../acquisition.html">botorch.acquisition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">botorch.models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generation.html">botorch.generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../posteriors.html">botorch.posteriors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../optim.html">botorch.optim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fit.html">botorch.fit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sampling.html">botorch.sampling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cross_validation.html">botorch.cross_validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../settings.html">botorch.settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../logging.html">botorch.logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_functions.html">botorch.test_functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../test_utils.html">botorch.test_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../exceptions.html">botorch.exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">botorch.utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">BoTorch</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">botorch.models.pairwise_gp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for botorch.models.pairwise_gp</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span class="c1">#</span>
<span class="c1"># This source code is licensed under the MIT license found in the</span>
<span class="c1"># LICENSE file in the root directory of this source tree.</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Preference Learning with Gaussian Process</span>

<span class="sd">.. [Chu2005preference]</span>
<span class="sd">    Wei Chu, and Zoubin Ghahramani. Preference learning with Gaussian processes.</span>
<span class="sd">    Proceedings of the 22nd international conference on Machine learning. 2005.</span>

<span class="sd">.. [Brochu2010tutorial]</span>
<span class="sd">    Eric Brochu, Vlad M. Cora, and Nando De Freitas.</span>
<span class="sd">    A tutorial on Bayesian optimization of expensive cost functions,</span>
<span class="sd">    with application to active user modeling and hierarchical reinforcement learning.</span>
<span class="sd">    arXiv preprint arXiv:1012.2599 (2010).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.acquisition.objective</span><span class="w"> </span><span class="kn">import</span> <span class="n">PosteriorTransform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnsupportedError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.exceptions.warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">_get_single_precision_warning</span><span class="p">,</span> <span class="n">InputDataWarning</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.models.likelihoods.pairwise</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">PairwiseLikelihood</span><span class="p">,</span>
    <span class="n">PairwiseProbitLikelihood</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.models.model</span><span class="w"> </span><span class="kn">import</span> <span class="n">FantasizeMixin</span><span class="p">,</span> <span class="n">Model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.models.transforms.input</span><span class="w"> </span><span class="kn">import</span> <span class="n">InputTransform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.models.utils.assorted</span><span class="w"> </span><span class="kn">import</span> <span class="n">consolidate_duplicates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.posteriors.gpytorch</span><span class="w"> </span><span class="kn">import</span> <span class="n">GPyTorchPosterior</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.posteriors.posterior</span><span class="w"> </span><span class="kn">import</span> <span class="n">Posterior</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">botorch.utils.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">RankingDataset</span><span class="p">,</span> <span class="n">SupervisedDataset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch</span><span class="w"> </span><span class="kn">import</span> <span class="n">settings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.constraints</span><span class="w"> </span><span class="kn">import</span> <span class="n">GreaterThan</span><span class="p">,</span> <span class="n">Interval</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.distributions.multivariate_normal</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultivariateNormal</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.kernels.rbf_kernel</span><span class="w"> </span><span class="kn">import</span> <span class="n">RBFKernel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.kernels.scale_kernel</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScaleKernel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.means.constant_mean</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConstantMean</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.mlls</span><span class="w"> </span><span class="kn">import</span> <span class="n">MarginalLogLikelihood</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.models.gp</span><span class="w"> </span><span class="kn">import</span> <span class="n">GP</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.priors.smoothed_box_prior</span><span class="w"> </span><span class="kn">import</span> <span class="n">SmoothedBoxPrior</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gpytorch.priors.torch_priors</span><span class="w"> </span><span class="kn">import</span> <span class="n">GammaPrior</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">linear_operator.operators</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinearOperator</span><span class="p">,</span> <span class="n">RootLinearOperator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">linear_operator.utils.cholesky</span><span class="w"> </span><span class="kn">import</span> <span class="n">psd_safe_cholesky</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">linear_operator.utils.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">NotPSDError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">Tensor</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.nn.modules.module</span><span class="w"> </span><span class="kn">import</span> <span class="n">_IncompatibleKeys</span>


<span class="c1"># Helper functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_check_strict_input</span><span class="p">(</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">t_inputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">target_or_inputs</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">):</span>
    <span class="k">for</span> <span class="n">input_</span><span class="p">,</span> <span class="n">t_input</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">t_inputs</span> <span class="ow">or</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)):</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;shape&quot;</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="s2">&quot;device&quot;</span><span class="p">}:</span>
            <span class="n">expected_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t_input</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">found_attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expected_attr</span> <span class="o">!=</span> <span class="n">found_attr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot modify </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">target_or_inputs</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(expected </span><span class="si">{</span><span class="n">expected_attr</span><span class="si">}</span><span class="s2">, found </span><span class="si">{</span><span class="n">found_attr</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_scaled_psd_safe_cholesky</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">jitter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;scale matrix by 1/outputscale before cholesky for better numerical stability&quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">/</span> <span class="n">scale</span>
    <span class="n">chol</span> <span class="o">=</span> <span class="n">psd_safe_cholesky</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="n">jitter</span><span class="p">)</span>
    <span class="n">chol</span> <span class="o">=</span> <span class="n">chol</span> <span class="o">*</span> <span class="n">scale</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">chol</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_psd_with_jitter</span><span class="p">(</span>
    <span class="n">matrix</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
    <span class="n">scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">Tensor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">jitter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">,</span>
    <span class="n">max_tries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="n">scaled_matrix</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">/</span> <span class="n">scale</span>
    <span class="n">new_jitter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_tries</span><span class="p">):</span>
        <span class="n">scaled_matrix</span> <span class="o">=</span> <span class="n">scaled_matrix</span> <span class="o">+</span> <span class="n">new_jitter</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                <span class="n">scaled_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">device</span><span class="o">=</span><span class="n">scaled_matrix</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">scaled_matrix</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky_ex</span><span class="p">(</span><span class="n">scaled_matrix</span><span class="p">)</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="p">(</span><span class="n">info</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">psd</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_jitter</span> <span class="o">=</span> <span class="n">jitter</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">new_jitter</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">psd</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NotPSDError</span><span class="p">(</span>
            <span class="s2">&quot;Matrix not positive definite after repeatedly adding jitter &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;up to </span><span class="si">{</span><span class="n">jitter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="si">:</span><span class="s2">.1e</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">scaled_matrix</span> <span class="o">*</span> <span class="n">scale</span>


<span class="c1"># Why we subclass GP even though it provides no functionality:</span>
<span class="c1"># if this subclassing is removed, we get the following GPyTorch error:</span>
<span class="c1"># &quot;RuntimeError: All MarginalLogLikelihood objects must be given a GP object as</span>
<span class="c1"># a model. If you are using a more complicated model involving a GP, pass the</span>
<span class="c1"># underlying GP object as the model, not a full PyTorch module.&quot;</span>
<div class="viewcode-block" id="PairwiseGP">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PairwiseGP</span><span class="p">(</span><span class="n">Model</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">FantasizeMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Probit GP for preference learning with Laplace approximation</span>

<span class="sd">    A probit-likelihood GP that learns via pairwise comparison data, using a</span>
<span class="sd">    Laplace approximation of the posterior of the estimated utility values. By</span>
<span class="sd">    default it uses a scaled RBF kernel.</span>

<span class="sd">    Implementation is based on [Chu2005preference]_.</span>
<span class="sd">    Also see [Brochu2010tutorial]_ for additional reference.</span>

<span class="sd">    Note that in [Chu2005preference]_ the likelihood of a pairwise comparison</span>
<span class="sd">    is :math:`\left(\frac{f(x_1) - f(x_2)}{\sqrt{2}\sigma}\right)`, i.e. a scale is</span>
<span class="sd">    used in the denominator. To maintain consistency with usage of kernels</span>
<span class="sd">    elsewhere in BoTorch, we instead do not include :math:`\sigma` in the code</span>
<span class="sd">    (implicitly setting it to 1) and use ScaleKernel to scale the function.</span>

<span class="sd">    In the example below, the user/decision maker has stated that they prefer</span>
<span class="sd">    the first item over the second item and the third item over the second item,</span>
<span class="sd">    generating comparisons [0, 1] and [2, 1].</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from botorch.models import PairwiseGP</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>
<span class="sd">        &gt;&gt;&gt; datapoints = torch.Tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">        &gt;&gt;&gt; comparisons = torch.Tensor([[0, 1], [2, 1]])</span>
<span class="sd">        &gt;&gt;&gt; model = PairwiseGP(datapoints, comparisons)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_buffer_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;consolidated_datapoints&quot;</span><span class="p">,</span>
        <span class="s2">&quot;consolidated_comparisons&quot;</span><span class="p">,</span>
        <span class="s2">&quot;D&quot;</span><span class="p">,</span>
        <span class="s2">&quot;DT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;utility&quot;</span><span class="p">,</span>
        <span class="s2">&quot;covar_chol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;likelihood_hess&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hlcov_eye&quot;</span><span class="p">,</span>
        <span class="s2">&quot;covar&quot;</span><span class="p">,</span>
        <span class="s2">&quot;covar_inv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;unconsolidated_datapoints&quot;</span><span class="p">,</span>
        <span class="s2">&quot;unconsolidated_comparisons&quot;</span><span class="p">,</span>
        <span class="s2">&quot;consolidated_indices&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">comparisons</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">likelihood</span><span class="p">:</span> <span class="n">PairwiseLikelihood</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">covar_module</span><span class="p">:</span> <span class="n">ScaleKernel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">input_transform</span><span class="p">:</span> <span class="n">InputTransform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">jitter</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">xtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">consolidate_rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">consolidate_atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>
        <span class="n">maxfev</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            datapoints: Either `None` or a `batch_shape x n x d` tensor of</span>
<span class="sd">                training features. If either `datapoints` or `comparisons` is</span>
<span class="sd">                `None`, construct a prior-only model.</span>
<span class="sd">            comparisons: Either `None` or a `batch_shape x m x 2` tensor of</span>
<span class="sd">                training comparisons; comparisons[i] is a noisy indicator</span>
<span class="sd">                suggesting the utility value of comparisons[i, 0]-th is greater</span>
<span class="sd">                than comparisons[i, 1]-th. If either `comparisons` or</span>
<span class="sd">                `datapoints` is `None`, construct a prior-only model.</span>
<span class="sd">            likelihood: A PairwiseLikelihood.</span>
<span class="sd">            covar_module: Covariance module.</span>
<span class="sd">            input_transform: An input transform that is applied in the model&#39;s</span>
<span class="sd">                forward pass.</span>
<span class="sd">            jitter: Value added to diagonal for numerical stability in</span>
<span class="sd">                `psd_safe_cholesky`.</span>
<span class="sd">            xtol: Stopping creteria in scipy.optimize.fsolve used to find f_map</span>
<span class="sd">                in `PairwiseGP._update`. If None, default behavior is handled by</span>
<span class="sd">                `PairwiseGP._update`.</span>
<span class="sd">            consolidate_rtol: `rtol` passed to `consolidate_duplicates`.</span>
<span class="sd">            consolidate_atol: `atol` passed to `consolidate_duplicates`.</span>
<span class="sd">            maxfev: The maximum number of calls to the function in</span>
<span class="sd">                scipy.optimize.fsolve. If None, default behavior is handled by</span>
<span class="sd">                `PairwiseGP._update`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Input data validation</span>
        <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">_get_single_precision_warning</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span>
                <span class="n">category</span><span class="o">=</span><span class="n">InputDataWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Set optional parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span> <span class="o">=</span> <span class="n">jitter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xtol</span> <span class="o">=</span> <span class="n">xtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_rtol</span> <span class="o">=</span> <span class="n">consolidate_rtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_atol</span> <span class="o">=</span> <span class="n">consolidate_atol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_maxfev</span> <span class="o">=</span> <span class="n">maxfev</span>

        <span class="k">if</span> <span class="n">input_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_transform</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="c1"># input transformation is applied in set_train_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_transform</span> <span class="o">=</span> <span class="n">input_transform</span>

        <span class="c1"># Compatibility variables with fit_gpytorch_*: Dummy likelihood</span>
        <span class="c1"># Likelihood is tightly tied with this model and</span>
        <span class="c1"># it doesn&#39;t make much sense to keep it separate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">PairwiseProbitLikelihood</span><span class="p">()</span> <span class="k">if</span> <span class="n">likelihood</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">likelihood</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">train_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">train_targets</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_datapoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_comparisons</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_datapoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_comparisons</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_indices</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># See set_train_data for additional compatibility variables.</span>
        <span class="c1"># Not that the datapoints here are not transformed even if input_transform</span>
        <span class="c1"># is not None to avoid double transformation during model fitting.</span>
        <span class="c1"># self.transform_inputs is called in `forward`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">comparisons</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Set hyperparameters</span>
        <span class="c1"># Do not set the batch_shape explicitly so mean_module can operate in both mode</span>
        <span class="c1"># once fsolve used in _update can run in batch mode, we should explicitly set</span>
        <span class="c1"># the bacth shape here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_module</span> <span class="o">=</span> <span class="n">ConstantMean</span><span class="p">()</span>
        <span class="c1"># Do not optimize constant mean prior</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_module</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># set covariance module</span>
        <span class="c1"># the default outputscale here is only a rule of thumb, meant to keep</span>
        <span class="c1"># estimates away from scale value that would make Phi(f(x)) saturate</span>
        <span class="c1"># at 0 or 1</span>
        <span class="k">if</span> <span class="n">covar_module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">os_lb</span><span class="p">,</span> <span class="n">os_ub</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">,</span> <span class="mf">1e2</span>
            <span class="n">ls_prior</span> <span class="o">=</span> <span class="n">GammaPrior</span><span class="p">(</span><span class="n">concentration</span><span class="o">=</span><span class="mf">2.4</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">2.7</span><span class="p">)</span>
            <span class="n">ls_prior_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">ls_prior</span><span class="o">.</span><span class="n">concentration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">ls_prior</span><span class="o">.</span><span class="n">rate</span>
            <span class="n">covar_module</span> <span class="o">=</span> <span class="n">ScaleKernel</span><span class="p">(</span>
                <span class="n">RBFKernel</span><span class="p">(</span>
                    <span class="n">batch_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">,</span>
                    <span class="n">ard_num_dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span>
                    <span class="n">lengthscale_prior</span><span class="o">=</span><span class="n">ls_prior</span><span class="p">,</span>
                    <span class="n">lengthscale_constraint</span><span class="o">=</span><span class="n">GreaterThan</span><span class="p">(</span>
                        <span class="n">lower_bound</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_value</span><span class="o">=</span><span class="n">ls_prior_mode</span>
                    <span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">outputscale_prior</span><span class="o">=</span><span class="n">SmoothedBoxPrior</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">os_lb</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">os_ub</span><span class="p">),</span>
                <span class="c1"># make sure we won&#39;t get extreme values for the output scale</span>
                <span class="n">outputscale_constraint</span><span class="o">=</span><span class="n">Interval</span><span class="p">(</span>
                    <span class="n">lower_bound</span><span class="o">=</span><span class="n">os_lb</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
                    <span class="n">upper_bound</span><span class="o">=</span><span class="n">os_ub</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">,</span>
                    <span class="n">initial_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">covar_module</span><span class="p">,</span> <span class="n">ScaleKernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s2">&quot;PairwiseGP must be used with a ScaleKernel.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span> <span class="o">=</span> <span class="n">covar_module</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will store temporary results for warm-starting</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># Find f_map for initial parameters with transformed datapoints</span>
            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PairwiseGP</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;consolidated_datapoints&quot;</span><span class="p">,</span>
            <span class="s2">&quot;consolidated_comparisons&quot;</span><span class="p">,</span>
            <span class="s2">&quot;covar&quot;</span><span class="p">,</span>
            <span class="s2">&quot;covar_inv&quot;</span><span class="p">,</span>
            <span class="s2">&quot;covar_chol&quot;</span><span class="p">,</span>
            <span class="s2">&quot;likelihood_hess&quot;</span><span class="p">,</span>
            <span class="s2">&quot;utility&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hlcov_eye&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unconsolidated_datapoints&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unconsolidated_comparisons&quot;</span><span class="p">,</span>
            <span class="s2">&quot;consolidated_indices&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">):</span>
            <span class="c1"># Temporarily remove non-leaf tensors so that pytorch allows deepcopy</span>
            <span class="n">old_attr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="n">old_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
            <span class="c1"># now set things back</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">old_attr</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">new_model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dcp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span>
            <span class="c1"># make sure we don&#39;t fall into the infinite recursive loop</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">new_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__deepcopy__</span> <span class="o">=</span> <span class="n">dcp</span>
            <span class="k">return</span> <span class="n">new_model</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_has_no_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return true if the model does not have both datapoints and comparisons&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">size</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">X2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="n">LinearOperator</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the covariance matrix given two sets of datapoints&quot;&quot;&quot;</span>
        <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">)</span><span class="o">.</span><span class="n">to_dense</span><span class="p">()</span>
        <span class="c1"># making sure covar is PSD when it&#39;s a covariance matrix</span>
        <span class="k">if</span> <span class="n">X1</span> <span class="ow">is</span> <span class="n">X2</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">outputscale</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="n">_ensure_psd_with_jitter</span><span class="p">(</span>
                <span class="n">matrix</span><span class="o">=</span><span class="n">covar</span><span class="p">,</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
                <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">covar</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update values derived from the data and hyperparameters</span>

<span class="sd">        covar, covar_chol, and covar_inv will be of shape batch_shape x n x n</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: (Transformed) datapoints for finding f_max</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">outputscale</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span> <span class="o">=</span> <span class="n">_scaled_psd_safe_cholesky</span><span class="p">(</span>
            <span class="n">matrix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">,</span>
            <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
            <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prior_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="n">LinearOperator</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return point prediction using prior only</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_size x n&#39; x d`-dim Tensor at which to evaluate prior</span>

<span class="sd">        Returns:</span>
<span class="sd">            Prior mean prediction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_module</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prior_predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Predict utility based on prior info only</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_size x n&#39; x d`-dim Tensor at which to evaluate prior</span>

<span class="sd">        Returns:</span>
<span class="sd">            pred_mean: predictive mean</span>
<span class="sd">            pred_covar: predictive covariance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pred_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">pred_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pred_mean</span><span class="p">,</span> <span class="n">pred_covar</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_grad_posterior_f</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">utility</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">D</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_chol</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_inv</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ret_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the gradient of S loss wrt to f/utility in [Chu2005preference]_.</span>

<span class="sd">        For finding f_map, which is negative of the log posterior, i.e., -log(p(f|D))</span>
<span class="sd">        Derivative of (10) in [Chu2005preference]_.</span>
<span class="sd">        Also see [Brochu2010tutorial]_ page 26. This is needed for estimating f_map.</span>

<span class="sd">        Args:</span>
<span class="sd">            utility: A Tensor of shape `batch_size x n`</span>
<span class="sd">            datapoints: A Tensor of shape `batch_size x n x d` as in self.datapoints</span>
<span class="sd">            D: A Tensor of shape `batch_size x m x n` as in self.D</span>
<span class="sd">            covar_chol: A Tensor of shape `batch_size x n x n`, as in self.covar_chol</span>
<span class="sd">            covar_inv: `None` or a Tensor of shape `batch_size x n x n`, as in</span>
<span class="sd">                self.covar_inv. This is not used but is needed so that</span>
<span class="sd">                PairwiseGP._grad_posterior_f has the same signature as</span>
<span class="sd">                PairwiseGP._hess_posterior_f.</span>
<span class="sd">            ret_np: return a numpy array if True, otherwise a Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prior_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret_np</span><span class="p">:</span>
            <span class="n">utility</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">utility</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">prior_mean</span> <span class="o">=</span> <span class="n">prior_mean</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="c1"># NOTE: During the optimization, it can occur that b, p, and g_ are NaNs, though</span>
        <span class="c1"># in the cases that occured during testing, the optimization routine escaped and</span>
        <span class="c1"># terminated successfully without NaNs in the result.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_gradient_sum</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">utility</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
        <span class="c1"># g_ = covar_inv x (utility - pred_prior)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">utility</span> <span class="o">-</span> <span class="n">prior_mean</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">covar_chol</span><span class="p">)</span>
        <span class="n">g_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">covar_chol</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g_</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">ret_np</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_hess_posterior_f</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">utility</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">,</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">D</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_chol</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">covar_inv</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ret_np</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the hessian of S loss wrt utility for finding f_map.</span>

<span class="sd">        which is negative of the log posterior, i.e., -log(p(f|D))</span>
<span class="sd">        Following [Chu2005preference]_ section 2.2.1.</span>
<span class="sd">        This is needed for estimating f_map</span>

<span class="sd">        Args:</span>
<span class="sd">            utility: A Tensor of shape `batch_size x n`</span>
<span class="sd">            datapoints: A Tensor of shape `batch_size x n x d`, as in</span>
<span class="sd">                self.datapoints. This is not used but is needed so that</span>
<span class="sd">                `_hess_posterior_f` has the same signature as</span>
<span class="sd">                `_grad_posterior_f`.</span>
<span class="sd">            D: A Tensor of shape `batch_size x m x n` as in self.D</span>
<span class="sd">            covar_chol: A Tensor of shape `batch_size x n x n`, as in</span>
<span class="sd">                self.covar_chol. This is not used but is needed so that</span>
<span class="sd">                `_hess_posterior_f` has the same signature as</span>
<span class="sd">                `_grad_posterior_f`.</span>
<span class="sd">            covar_inv: A Tensor of shape `batch_size x n x n`, as in self.covar_inv</span>
<span class="sd">            ret_np: return a numpy array if true, otherwise a Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ret_np</span><span class="p">:</span>
            <span class="n">utility</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">utility</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_hessian_sum</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">utility</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">+</span> <span class="n">covar_inv</span>
        <span class="k">return</span> <span class="n">hess</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">if</span> <span class="n">ret_np</span> <span class="k">else</span> <span class="n">hess</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update_utility_derived_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set self.hlcov_eye to self.likelihood_hess @ self.covar + I.</span>

<span class="sd">        `self.hlcov_eye` is a utility-derived value not used during</span>
<span class="sd">        optimization. This quantity is used so that we will be able to compute</span>
<span class="sd">        the predictive covariance (in PairwiseGP.forward in posterior mode) with</span>
<span class="sd">        better numerical stability using the substitution method:</span>

<span class="sd">        Let `pred_cov_fac = (covar + hl^-1)`, which is needed for calculating</span>
<span class="sd">        the predictive covariance = `K - k.T @ pred_cov_fac^-1 @ k`.</span>
<span class="sd">        Instead of inverting `pred_cov_fac`, let `hlcov_eye = (hl @ covar + I)`</span>
<span class="sd">        Then we can obtain `pred_cov_fac^-1 @ k` by solving for p in</span>
<span class="sd">        `(hl @ k) p = hlcov_eye`</span>
<span class="sd">        `hlcov_eye p = hl @ k`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span>  <span class="c1"># &quot;C&quot; from page 27, [Brochu2010tutorial]_</span>
        <span class="n">hlcov</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
            <span class="n">hlcov</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">hlcov</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hlcov_eye</span> <span class="o">=</span> <span class="n">hlcov</span> <span class="o">+</span> <span class="n">eye</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update the model by updating the covar matrix and MAP utility values</span>

<span class="sd">        Update the model by</span>
<span class="sd">        1. Re-evaluating the covar matrix as the data or hyperparams may have changed</span>
<span class="sd">        2. Approximating maximum a posteriori of the utility function f using fsolve</span>

<span class="sd">        Should be called after data or hyperparameters are changed to update</span>
<span class="sd">        f_map and related values</span>

<span class="sd">        self._xtol and self._maxfev are passed to fsolve as xtol and maxfev</span>
<span class="sd">        to control stopping criteria</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: (transformed) datapoints for finding f_max</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xtol</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xtol</span>
        <span class="n">maxfev</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxfev</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_maxfev</span>

        <span class="c1"># Using the latest param for covariance before calculating f_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_covar</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>

        <span class="c1"># scipy newton raphson</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="c1"># warm start</span>
            <span class="n">init_x0_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="n">init_x0_size</span><span class="p">:</span>
                <span class="n">sqrt_scale</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">outputscale</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">detach</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="c1"># Heuristic intialization using winning count with perturbation</span>
                <span class="c1"># to avoid extreme or unprobable likelihood values</span>
                <span class="n">win_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="n">wc_mean</span><span class="p">,</span> <span class="n">wc_std</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">win_count</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="n">win_count</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="p">(</span><span class="n">win_count</span> <span class="o">-</span> <span class="n">wc_mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">wc_std</span>
                <span class="c1"># adding random perturbation to in case get stuck at strange init values</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">init_x0_size</span><span class="p">)</span>
                <span class="c1"># scale x0 to be on roughly the right scale</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">*</span> <span class="n">sqrt_scale</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># batch mode, do optimize.fsolve sequentially on CPU</span>
                <span class="c1"># TODO: enable vectorization/parallelization here</span>
                <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
                <span class="n">dp_v</span> <span class="o">=</span> <span class="n">datapoints</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">D_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">ch_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">ci_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">fsolve_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">dp_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">D_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ch_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ci_v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span>
                            <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grad_posterior_f</span><span class="p">,</span>
                            <span class="n">fprime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hess_posterior_f</span><span class="p">,</span>
                            <span class="n">xtol</span><span class="o">=</span><span class="n">xtol</span><span class="p">,</span>
                            <span class="n">maxfev</span><span class="o">=</span><span class="n">maxfev</span><span class="p">,</span>
                            <span class="n">args</span><span class="o">=</span><span class="n">fsolve_args</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">init_x0_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fsolve only works on CPU</span>
                <span class="n">fsolve_args</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">datapoints</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar_inv</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
                    <span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span>
                        <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                        <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grad_posterior_f</span><span class="p">,</span>
                        <span class="n">fprime</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hess_posterior_f</span><span class="p">,</span>
                        <span class="n">xtol</span><span class="o">=</span><span class="n">xtol</span><span class="p">,</span>
                        <span class="n">maxfev</span><span class="o">=</span><span class="n">maxfev</span><span class="p">,</span>
                        <span class="n">args</span><span class="o">=</span><span class="n">fsolve_args</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_x0</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># save for warm-starting</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># To perform hyperparameter optimization, this needs to be recalculated</span>
        <span class="c1"># when calling forward() in order to obtain correct gradients</span>
        <span class="c1"># self.likelihood_hess is updated here is for the rare case where we</span>
        <span class="c1"># do not want to call forward()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_hessian_sum</span><span class="p">(</span>
            <span class="n">utility</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span>
        <span class="p">)</span>

        <span class="c1"># Lazy update hlcov_eye, which is used in calculating posterior during training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># fill in dummy values for hlcov_eye so that load_state_dict can function</span>
        <span class="n">hlcov_eye_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">((</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hlcov_eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">hlcov_eye_size</span><span class="p">)</span>

        <span class="c1"># Take two newton step on the posterior MAP point to fill</span>
        <span class="c1"># in gradients for pytorch. Using 2 instead of 1 since empirically sometimes</span>
        <span class="c1"># the first step results in gradients in the order of 1e-7 while the 2nd step</span>
        <span class="c1"># allows it go down further to the order of 1e-12 and stay there.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_util_newton_updates</span><span class="p">(</span>
            <span class="n">dp</span><span class="o">=</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">requires_grad_</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">X_new</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transform X and X_new into the same shape</span>

<span class="sd">        Transform the batch shape of X to be compatible</span>
<span class="sd">        with `X_new` to calculate the posterior.</span>
<span class="sd">        If X has the same batch size as `X_new`, return it as is.</span>
<span class="sd">        If one is in batch mode and the other one is not, convert both</span>
<span class="sd">        into batch mode.</span>
<span class="sd">        If both are in batch mode, this will only work if X_batch_shape</span>
<span class="sd">        can propagate to X_new_batch_shape</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_shape x q x d`-dim or `(1 x) q x d`-dim Tensor</span>
<span class="sd">            X_new: A `batch_shape x q x d`-dim Tensor</span>

<span class="sd">        Returns:</span>
<span class="sd">            Transformed X and X_new pair</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">X_bs</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># X batch shape</span>
        <span class="n">X_new_bs</span> <span class="o">=</span> <span class="n">X_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># X_new batch shape</span>
        <span class="k">if</span> <span class="n">X_new_bs</span> <span class="o">==</span> <span class="n">X_bs</span><span class="p">:</span>
            <span class="c1"># if batch shapes match, there&#39;s no need to transform</span>
            <span class="c1"># X_new may or may not have batch_shape dimensions</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">X_new</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_new_bs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_bs</span><span class="p">):</span>
            <span class="c1"># if X_new has fewer dimension, try to expand it to X&#39;s shape</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">X_new</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">X_bs</span> <span class="o">+</span> <span class="n">X_new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if X has fewer dimension, try to expand it to X_new&#39;s shape</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">X_new_bs</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">X_new</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_util_newton_updates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dp</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make `max_iter` newton updates on utility.</span>

<span class="sd">        This is used in `forward` to calculate and fill in gradient into tensors.</span>
<span class="sd">        Instead of doing utility -= H^-1 @ g, use substition method.</span>
<span class="sd">        See more explanation in _update_utility_derived_values.</span>
<span class="sd">        By default only need to run one iteration just to fill the the gradients.</span>

<span class="sd">        Args:</span>
<span class="sd">            dp: (Transformed) datapoints. A Tensor of shape `batch_size x n x d`</span>
<span class="sd">                as in self.datapoints</span>
<span class="sd">            x0: A `batch_size x n` dimension tensor, initial values.</span>
<span class="sd">            max_iter: Max number of iterations.</span>
<span class="sd">            xtol: Stop creteria. If `None`, do not stop until</span>
<span class="sd">                finishing `max_iter` updates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xtol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-Inf&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">xtol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">xtol</span>
        <span class="n">D</span><span class="p">,</span> <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span>
        <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;Inf&quot;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_iter</span> <span class="ow">and</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">xtol</span><span class="p">:</span>
            <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span><span class="o">.</span><span class="n">negative_log_hessian_sum</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span> <span class="o">=</span> <span class="n">hl</span>
            <span class="n">cov_hl</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">@</span> <span class="n">hl</span>
            <span class="k">if</span> <span class="n">eye</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span>
                    <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                        <span class="n">cov_hl</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">cov_hl</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cov_hl</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">cov_hl</span> <span class="o">=</span> <span class="n">cov_hl</span> <span class="o">+</span> <span class="n">eye</span>  <span class="c1"># add 1 to cov_hl</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grad_posterior_f</span><span class="p">(</span>
                <span class="n">utility</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                <span class="n">datapoints</span><span class="o">=</span><span class="n">dp</span><span class="p">,</span>
                <span class="n">D</span><span class="o">=</span><span class="n">D</span><span class="p">,</span>
                <span class="n">covar_chol</span><span class="o">=</span><span class="n">ch</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">cov_g</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">@</span> <span class="n">g</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_update</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">cov_hl</span><span class="p">,</span> <span class="n">cov_g</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x_next</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x_update</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_next</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x_next</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_consolidate_duplicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">comparisons</span><span class="p">:</span> <span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Consolidate and cache datapoints and comparisons&quot;&quot;&quot;</span>
        <span class="c1"># check if consolidated datapoints/comparisons are cached</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_datapoints</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">comparisons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_comparisons</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">consolidated_datapoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">consolidated_comparisons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_datapoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_comparisons</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">datapoints</span><span class="p">,</span>
                <span class="n">comparisons</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">comparisons</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Do not perform consolidation in batch mode as block design</span>
                <span class="c1"># cannot be guaranteed</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_datapoints</span> <span class="o">=</span> <span class="n">datapoints</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_comparisons</span> <span class="o">=</span> <span class="n">comparisons</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_indices</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_datapoints</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_comparisons</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_indices</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">consolidate_duplicates</span><span class="p">(</span>
                    <span class="n">datapoints</span><span class="p">,</span>
                    <span class="n">comparisons</span><span class="p">,</span>
                    <span class="n">rtol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_rtol</span><span class="p">,</span>
                    <span class="n">atol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_atol</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_datapoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_comparisons</span>

    <span class="c1"># ============== public APIs ==============</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">datapoints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Alias for consolidated datapoints&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_datapoints</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">comparisons</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Alias for consolidated comparisons&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_comparisons</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unconsolidated_utility</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Utility of the unconsolidated datapoints&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consolidated_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># self.consolidated_indices is None in batch mode</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">consolidated_indices</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_outputs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The number of outputs of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_outputs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The batch shape of the model.</span>

<span class="sd">        This is a batch shape from an I/O perspective, independent of the internal</span>
<span class="sd">        representation of the model (as e.g. in BatchedMultiOutputGPyTorchModel).</span>
<span class="sd">        For a model with `m` outputs, a `test_batch_shape x q x d`-shaped input `X`</span>
<span class="sd">        to the `posterior` method returns a Posterior object over an output of</span>
<span class="sd">        shape `broadcast(test_batch_shape, model.batch_shape) x q x m`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># this could happen in prior mode</span>
            <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

<div class="viewcode-block" id="PairwiseGP.construct_inputs">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.construct_inputs">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">construct_inputs</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">training_data</span><span class="p">:</span> <span class="n">SupervisedDataset</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct `Model` keyword arguments from a `RankingDataset`.</span>

<span class="sd">        Args:</span>
<span class="sd">            training_data: A `RankingDataset`, with attributes `train_X`,</span>
<span class="sd">                `train_Y`, and, optionally, `train_Yvar`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dict of keyword arguments that can be used to initialize a</span>
<span class="sd">            `PairwiseGP`, including `datapoints` and `comparisons`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="n">RankingDataset</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">UnsupportedError</span><span class="p">(</span>
                <span class="s2">&quot;Only `RankingDataset` is supported for `PairwiseGP`. Received &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">datapoints</span> <span class="o">=</span> <span class="n">training_data</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">values</span>
        <span class="n">comparisons</span> <span class="o">=</span> <span class="n">training_data</span><span class="o">.</span><span class="n">_X</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">comp_order</span> <span class="o">=</span> <span class="n">training_data</span><span class="o">.</span><span class="n">Y</span>
        <span class="n">comparisons</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="n">comparisons</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">comp_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;datapoints&quot;</span><span class="p">:</span> <span class="n">datapoints</span><span class="p">,</span>
            <span class="s2">&quot;comparisons&quot;</span><span class="p">:</span> <span class="n">comparisons</span><span class="p">,</span>
        <span class="p">}</span></div>


<div class="viewcode-block" id="PairwiseGP.set_train_data">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.set_train_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_train_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">comparisons</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">update_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set datapoints and comparisons and update model properties if needed</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: Either `None` or a `batch_shape x n x d` dimension</span>
<span class="sd">                tensor X. If there are input transformations, assume the</span>
<span class="sd">                datapoints are not transformed. If either `datapoints` or</span>
<span class="sd">                `comparisons` is `None`, construct a prior-only model.</span>
<span class="sd">            comparisons: Either `None` or a tensor of size `batch_shape x m x</span>
<span class="sd">                2`. (i, j) means f_i is preferred over f_j. If either</span>
<span class="sd">                `comparisons` or `datapoints` is `None`, construct a prior-only</span>
<span class="sd">                model.</span>
<span class="sd">            strict: `strict` argument as in gpytorch.models.exact_gp for compatibility</span>
<span class="sd">                when using fit_gpytorch_mll with input_transform.</span>
<span class="sd">            update_model: True if we want to refit the model (see _update) after</span>
<span class="sd">                re-setting the data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When datapoints and/or comparisons are None, we are constructing</span>
        <span class="c1"># a prior-only model</span>
        <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">comparisons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># following gpytorch.models.exact_gp.set_train_data</span>
        <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">datapoints</span><span class="p">):</span>
                <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">datapoints</span><span class="p">]</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">input_</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">input_</span><span class="o">.</span><span class="n">ndimension</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">input_</span>
                <span class="k">for</span> <span class="n">input_</span> <span class="ow">in</span> <span class="n">inputs</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="n">_check_strict_input</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_inputs</span><span class="p">,</span> <span class="s2">&quot;inputs&quot;</span><span class="p">)</span>

            <span class="n">datapoints</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Compatibility variables with fit_gpytorch_*</span>
            <span class="c1"># alias for datapoints (&quot;train_inputs&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_inputs</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="k">if</span> <span class="n">comparisons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="n">_check_strict_input</span><span class="p">([</span><span class="n">comparisons</span><span class="p">],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">train_targets</span><span class="p">],</span> <span class="s2">&quot;targets&quot;</span><span class="p">)</span>

            <span class="c1"># convert to long so that it can be used as index and</span>
            <span class="c1"># compatible with Tensor.scatter_</span>
            <span class="n">comparisons</span> <span class="o">=</span> <span class="n">comparisons</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
            <span class="c1"># Compatibility variables with fit_gpytorch_*</span>
            <span class="c1"># alias for comparisons (&quot;train_targets&quot; here)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_targets</span> <span class="o">=</span> <span class="n">comparisons</span>

        <span class="c1"># self.datapoints and self.comparisons are being updated here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consolidate_duplicates</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span> <span class="n">comparisons</span><span class="p">)</span>

        <span class="c1"># Compatibility variables with optimize_acqf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_outputs</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 1 latent value output per observation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># feature dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># num datapoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># num pairwise comparisons</span>
        <span class="c1"># D is batch_size x m x n or num_comparison x num_datapoints.</span>
        <span class="c1"># D_k_i is the s_k(x_i) value as in equation (6) in [Chu2005preference]_</span>
        <span class="c1"># D will usually be very sparse as well</span>
        <span class="c1"># TODO swap out scatter_ so that comparisons could be int instead of long</span>
        <span class="c1"># TODO: make D a sparse matrix once pytorch has better support for</span>
        <span class="c1">#       sparse tensors</span>
        <span class="n">D_size</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">D_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span>
        <span class="p">)</span>
        <span class="n">comp_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sub_D</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)):</span>
            <span class="n">sub_D</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp_view</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">sub_D</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp_view</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update_model</span><span class="p">:</span>
            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span></div>


<div class="viewcode-block" id="PairwiseGP.load_state_dict">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.load_state_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_state_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IncompatibleKeys</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Removes data related buffers from the `state_dict` and calls</span>
<span class="sd">        `super().load_state_dict` with `strict=False`.</span>

<span class="sd">        Args:</span>
<span class="sd">            state_dict: The state dict.</span>
<span class="sd">            strict: Boolean specifying whether or not given and instance-bound</span>
<span class="sd">                state_dicts should have identical keys. Only implemented for</span>
<span class="sd">                `strict=False` since buffers will filters out when calling</span>
<span class="sd">                `_load_from_state_dict`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A named tuple `_IncompatibleKeys`, containing the `missing_keys`</span>
<span class="sd">            and `unexpected_keys`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnsupportedError</span><span class="p">(</span><span class="s2">&quot;Passing strict=True is not supported.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="o">=</span><span class="n">state_dict</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_from_state_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">local_metadata</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">missing_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">unexpected_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">error_msgs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_load_from_state_dict</span><span class="p">(</span>
            <span class="n">state_dict</span><span class="o">=</span><span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_names</span>
            <span class="p">},</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">local_metadata</span><span class="o">=</span><span class="n">local_metadata</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">missing_keys</span><span class="o">=</span><span class="n">missing_keys</span><span class="p">,</span>
            <span class="n">unexpected_keys</span><span class="o">=</span><span class="n">unexpected_keys</span><span class="p">,</span>
            <span class="n">error_msgs</span><span class="o">=</span><span class="n">error_msgs</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PairwiseGP.forward">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datapoints</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultivariateNormal</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate a posterior or prior prediction.</span>

<span class="sd">        During training mode, forward implemented solely for gradient-based</span>
<span class="sd">        hyperparam opt. Essentially what it does is to re-calculate the utility</span>
<span class="sd">        f using its analytical form at f_map so that we are able to obtain</span>
<span class="sd">        gradients of the hyperparameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            datapoints: A `batch_shape x n x d` Tensor,</span>
<span class="sd">                should be the same as self.datapoints during training</span>

<span class="sd">        Returns:</span>
<span class="sd">            A MultivariateNormal object, being one of the followings:</span>
<span class="sd">                1. Posterior centered at MAP points for training data (training mode)</span>
<span class="sd">                2. Prior predictions (prior mode)</span>
<span class="sd">                3. Predictive posterior (eval mode)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Training mode: optimizing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_no_data</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;datapoints and comparisons cannot be None in training mode. &quot;</span>
                    <span class="s2">&quot;Call .eval() for prior predictions, &quot;</span>
                    <span class="s2">&quot;or call .set_train_data() to add training data.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">datapoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_datapoints</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Must train on training data&quot;</span><span class="p">)</span>

            <span class="c1"># We pass in the untransformed datapoints into set_train_data</span>
            <span class="c1"># as we will be setting self.datapoints as the untransformed datapoints</span>
            <span class="c1"># self.transform_inputs will be called inside before calling _update()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span>
                <span class="n">datapoints</span><span class="o">=</span><span class="n">datapoints</span><span class="p">,</span>
                <span class="n">comparisons</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unconsolidated_comparisons</span><span class="p">,</span>
                <span class="n">update_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>

            <span class="n">hl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span>
            <span class="n">covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span>

            <span class="c1"># Apply matrix inversion lemma on eq. in page 27 of [Brochu2010tutorial]_</span>
            <span class="c1"># (A + B)^-1 = A^-1 - A^-1 @ (I + BA^-1)^-1 @ BA^-1</span>
            <span class="c1"># where A = covar_inv, B = hl</span>
            <span class="n">hl_cov</span> <span class="o">=</span> <span class="n">hl</span> <span class="o">@</span> <span class="n">covar</span>
            <span class="n">eye</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span>
                <span class="n">hl_cov</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">hl_cov</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">hl_cov_I</span> <span class="o">=</span> <span class="n">hl_cov</span> <span class="o">+</span> <span class="n">eye</span>  <span class="c1"># add I to hl_cov</span>
            <span class="n">output_covar</span> <span class="o">=</span> <span class="n">covar</span> <span class="o">-</span> <span class="n">covar</span> <span class="o">@</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hl_cov_I</span><span class="p">,</span> <span class="n">hl_cov</span><span class="p">)</span>
            <span class="n">output_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span>

        <span class="c1"># Prior mode</span>
        <span class="k">elif</span> <span class="n">settings</span><span class="o">.</span><span class="n">prior_mode</span><span class="o">.</span><span class="n">on</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_no_data</span><span class="p">():</span>
            <span class="n">transformed_new_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="c1"># if we don&#39;t have any data yet, use prior GP to make predictions</span>
            <span class="n">output_mean</span><span class="p">,</span> <span class="n">output_covar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_predict</span><span class="p">(</span><span class="n">transformed_new_dp</span><span class="p">)</span>

        <span class="c1"># Posterior mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transformed_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="p">)</span>
            <span class="n">transformed_new_dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_inputs</span><span class="p">(</span><span class="n">datapoints</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

            <span class="c1"># self.utility might be None if exception was raised and _update</span>
            <span class="c1"># was failed to be called during hyperparameter optimization</span>
            <span class="c1"># procedures (e.g., fit_gpytorch_mll_scipy)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pred_cov_fac_need_update</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_utility_derived_values</span><span class="p">()</span>

            <span class="n">X</span><span class="p">,</span> <span class="n">X_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="n">transformed_dp</span><span class="p">,</span> <span class="n">transformed_new_dp</span><span class="p">)</span>
            <span class="n">covar_chol</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
            <span class="n">hl</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">likelihood_hess</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
            <span class="n">hlcov_eye</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_batch_shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlcov_eye</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>

            <span class="c1"># otherwise compute predictive mean and covariance</span>
            <span class="n">covar_xnew_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">covar_x_xnew</span> <span class="o">=</span> <span class="n">covar_xnew_x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">covar_xnew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_covar</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">utility</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

            <span class="n">covar_inv_p</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">covar_chol</span><span class="p">)</span>
            <span class="n">pred_mean</span> <span class="o">=</span> <span class="p">(</span><span class="n">covar_xnew_x</span> <span class="o">@</span> <span class="n">covar_inv_p</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">pred_mean</span> <span class="o">=</span> <span class="n">pred_mean</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prior_mean</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

            <span class="c1"># Using the terminology from [Brochu2010tutorial]_ page 27:</span>
            <span class="c1"># hl = C; hlcov_eye = CK + I; k = covar_x_xnew</span>
            <span class="c1">#</span>
            <span class="c1"># To compute the predictive covariance, one term we need is</span>
            <span class="c1"># k^T (K + C^{-1})^{-1} k.</span>
            <span class="c1"># Rather than performing two matrix inversions, we can compute this</span>
            <span class="c1"># in a more efficient and numerically stable way by using</span>
            <span class="c1"># fac = hlcov_eye^-1 @ hl @ covar_x_xnew</span>
            <span class="c1">#     = (CK + I)^-1 @ C @ k</span>
            <span class="c1">#     = (K + C^-1)^{-1}</span>
            <span class="c1"># This is the substitution method.</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">hlcov_eye</span><span class="p">,</span> <span class="n">hl</span> <span class="o">@</span> <span class="n">covar_x_xnew</span><span class="p">)</span>
            <span class="n">pred_covar</span> <span class="o">=</span> <span class="n">covar_xnew</span> <span class="o">-</span> <span class="p">(</span><span class="n">covar_xnew_x</span> <span class="o">@</span> <span class="n">fac</span><span class="p">)</span>

            <span class="n">output_mean</span><span class="p">,</span> <span class="n">output_covar</span> <span class="o">=</span> <span class="n">pred_mean</span><span class="p">,</span> <span class="n">pred_covar</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar_module</span><span class="o">.</span><span class="n">outputscale</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="n">post</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span>
            <span class="n">mean</span><span class="o">=</span><span class="n">output_mean</span><span class="p">,</span>
            <span class="c1"># output_covar is sometimes non-PSD</span>
            <span class="c1"># perform a cholesky decomposition to check and amend</span>
            <span class="n">covariance_matrix</span><span class="o">=</span><span class="n">RootLinearOperator</span><span class="p">(</span>
                <span class="n">_scaled_psd_safe_cholesky</span><span class="p">(</span>
                    <span class="n">matrix</span><span class="o">=</span><span class="n">output_covar</span><span class="p">,</span>
                    <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
                    <span class="n">jitter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jitter</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">post</span></div>


    <span class="c1"># ============== botorch.models.model.Model interfaces ==============</span>
<div class="viewcode-block" id="PairwiseGP.posterior">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.posterior">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">posterior</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">output_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">observation_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">posterior_transform</span><span class="p">:</span> <span class="n">PosteriorTransform</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Posterior</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Computes the posterior over model outputs at the provided points.</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_shape x q x d`-dim Tensor, where `d` is the dimension</span>
<span class="sd">                of the feature space and `q` is the number of points considered jointly.</span>
<span class="sd">            output_indices: As defined in parent Model class, not used for this model.</span>
<span class="sd">            observation_noise: Ignored (since noise is not identifiable from scale</span>
<span class="sd">                in probit models).</span>
<span class="sd">            posterior_transform: An optional PosteriorTransform.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `Posterior` object, representing joint</span>
<span class="sd">                distributions over `q` points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>  <span class="c1"># make sure model is in eval mode</span>

        <span class="k">if</span> <span class="n">output_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;output_indices is not None. PairwiseGP should not be a&quot;</span>
                <span class="s2">&quot;multi-output model.&quot;</span>
            <span class="p">)</span>

        <span class="n">post</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">posterior</span> <span class="o">=</span> <span class="n">GPyTorchPosterior</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">posterior_transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">posterior_transform</span><span class="p">(</span><span class="n">posterior</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">posterior</span></div>


<div class="viewcode-block" id="PairwiseGP.condition_on_observations">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseGP.condition_on_observations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">condition_on_observations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Model</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Condition the model on new observations.</span>

<span class="sd">        Note that unlike other BoTorch models, PairwiseGP requires Y to be</span>
<span class="sd">        pairwise comparisons.</span>

<span class="sd">        Args:</span>
<span class="sd">            X: A `batch_shape x n x d` dimension tensor X</span>
<span class="sd">            Y: A tensor of size `batch_shape x m x 2`. (i, j) means</span>
<span class="sd">                f_i is preferred over f_j</span>
<span class="sd">            kwargs: Not used.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A (deepcopied) `Model` object of the same type, representing the</span>
<span class="sd">            original model conditioned on the new observations `(X, Y)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_model</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_no_data</span><span class="p">():</span>
            <span class="c1"># If the model previously has no data, set X and Y as the data directly</span>
            <span class="n">new_model</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Can only condition on pairwise comparisons instead of the directly</span>
            <span class="c1"># observed values. Raise a RuntimeError if Y is not a tensor presenting</span>
            <span class="c1"># pairwise comparisons</span>
            <span class="k">if</span> <span class="n">Y</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">)</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Conditioning on non-pairwise comparison observations.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Reshaping datapoints and comparisons by batches</span>
            <span class="n">Y_new_batch_shape</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">new_datapoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                <span class="n">Y_new_batch_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">datapoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="n">new_comparisons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span>
                <span class="n">Y_new_batch_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparisons</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Reshape X since Y may have additional batch dim. from fantasy models</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">Y_new_batch_shape</span> <span class="o">+</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>

            <span class="n">new_datapoints</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">new_datapoints</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">new_datapoints</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">shifted_comp</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">new_comparisons</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">new_comparisons</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">new_comparisons</span><span class="p">,</span> <span class="n">shifted_comp</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># TODO: be smart about how we can update covar matrix here</span>
            <span class="n">new_model</span><span class="o">.</span><span class="n">set_train_data</span><span class="p">(</span><span class="n">new_datapoints</span><span class="p">,</span> <span class="n">new_comparisons</span><span class="p">,</span> <span class="n">update_model</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_model</span></div>
</div>



<div class="viewcode-block" id="PairwiseLaplaceMarginalLogLikelihood">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseLaplaceMarginalLogLikelihood">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PairwiseLaplaceMarginalLogLikelihood</span><span class="p">(</span><span class="n">MarginalLogLikelihood</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Laplace-approximated marginal log likelihood/evidence for PairwiseGP</span>

<span class="sd">    See (12) from [Chu2005preference]_.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">GP</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            likelihood: Used as in args to GPyTorch MarginalLogLikelihood</span>
<span class="sd">            model: Used as in args to GPyTorch MarginalLogLikelihood</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">likelihood</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

<div class="viewcode-block" id="PairwiseLaplaceMarginalLogLikelihood.forward">
<a class="viewcode-back" href="../../../models.html#botorch.models.pairwise_gp.PairwiseLaplaceMarginalLogLikelihood.forward">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">post</span><span class="p">:</span> <span class="n">Posterior</span><span class="p">,</span> <span class="n">comp</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate approximated log evidence, i.e., log(P(D|theta))</span>

<span class="sd">        Note that post will be based on the consolidated/deduped datapoints for</span>
<span class="sd">        numerical stability, but comp will still be the unconsolidated comparisons</span>
<span class="sd">        so that it&#39;s still compatible with fit_gpytorch_*.</span>

<span class="sd">        Args:</span>
<span class="sd">            post: training posterior distribution from self.model (after consolidation)</span>
<span class="sd">            comp: Comparisons pairs (before consolidation)</span>

<span class="sd">        Returns:</span>
<span class="sd">            The approximated evidence, i.e., the marginal log likelihood</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">likelihood</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">unconsolidated_comparisons</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Must train on training data&quot;</span><span class="p">)</span>

        <span class="n">f_map</span> <span class="o">=</span> <span class="n">post</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">likelihood</span><span class="o">.</span><span class="n">log_p</span><span class="p">(</span><span class="n">utility</span><span class="o">=</span><span class="n">f_map</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">D</span><span class="p">)</span>
        <span class="n">neg_log_likelihood_sum</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">log_likelihood</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># 1/2 f_map^T @ covar_inv @ f_map</span>
        <span class="n">inv_prod</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cholesky_solve</span><span class="p">(</span><span class="n">f_map</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">model</span><span class="o">.</span><span class="n">covar_chol</span><span class="p">)</span>
        <span class="n">log_prior</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">f_map</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">inv_prod</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">log_posterior</span> <span class="o">=</span> <span class="n">neg_log_likelihood_sum</span> <span class="o">+</span> <span class="n">log_prior</span>
        <span class="c1"># log_posterior is the S loss function in [Chu2005preference]_</span>
        <span class="n">log_posterior</span> <span class="o">=</span> <span class="o">-</span><span class="n">log_posterior</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">mll</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">covar</span> <span class="o">@</span> <span class="n">model</span><span class="o">.</span><span class="n">likelihood_hess</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">diag_embed</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mll</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">mll</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mll</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">logdet</span><span class="p">(</span><span class="n">mll</span><span class="p">)</span>

        <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span> <span class="o">+</span> <span class="n">log_posterior</span>

        <span class="c1"># Sum up mll first so that when adding parameter prior probs it won&#39;t</span>
        <span class="c1"># propagate and double count</span>
        <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Add log probs of priors on the (functions of) parameters</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">closure</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_priors</span><span class="p">():</span>
            <span class="n">mll</span> <span class="o">=</span> <span class="n">mll</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prior</span><span class="o">.</span><span class="n">log_prob</span><span class="p">(</span><span class="n">closure</span><span class="p">(</span><span class="n">module</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">mll</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>